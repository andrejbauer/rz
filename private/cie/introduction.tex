\section{Introduction}
\label{sec:introduction}

Given a description of a mathematical structure (constants,
functions, relations, and axioms), what should a computer
implementation look like?

For simple cases,
\iflong
the answer is obvious. A
group would have a type whose values represent group elements, as well
as a binary operation that is associative, a constant 
neutral element, and a unary inverse operator.

\else % \iflong
like groups, the answer is obvious.
\fi % \iflong
%
But for more interesting structures, especially those arising in
mathematical analysis, the answer is less clear. How do we
implement the real numbers (a Cauchy-complete Archimedean ordered
field)? Or choose the operations for a compact metric
space or a space of smooth functions? Significant research goes into
finding satisfactory representations~\cite{Wei00,TZ98,Bla97,EL00}, and
implementations of exact real arithmetic~\cite{Mue00,Lam05a} show that
the theory can be put into practice quite successfully.

\iflong
The theory of realizability provides guidance in development of
computable mathematics.  Our work shows that realizability is
not only  a
fundamental tool in logic and computability, but also
has direct application to the design and implementation of programs:
it can
\else % \iflong
Realizability theory can be used to 
\fi % \iflong
produce a description of the data structure (a code interface)
directly corresponding to a mathematical specification.
%
\iflong

\fi % \iflong
%
\iflong
However, doing this by hand quickly grows tedious. 
Worse, different
but logically equivalent sets of axioms correspond to different,
although interdefinable, interfaces for code; one might then want to
compare several variations, since some interfaces will be more useful
than others in practice.
   % this line intentionally left blank
And 
\else
But
\fi % \iflong 
few programmers --- even those with strong backgrounds in
mathematics and classical logic --- are familiar with constructive logic or
realizability. 
\iflong
Programmers are used to language constructs
describing interfaces (e.g., C++ header files, ML signatures, or Java
interfaces) and logical assertions (e.g., preconditions
and postconditions).
\fi

%\bigskip

We have therefore implemented a system, called RZ, to serve as a
bridge between the logical world and the programming
world.\footnote{RZ is publicly available for download at
  \url{http://math.andrej.com/rz/}, together with an \iflong
  abridged\else extended\fi\ version of this paper.} RZ translates
specifications in constructive logic into standard interface code in a
programming language (currently Objective Caml~\cite{ocaml}, but other
languages could be used).

The constructive part of the original specification turns into
interface code, listing types and values to be implemented. The rest
becomes assertions about these types and values. The assertions have
no computational content, so their constructive and classical meanings
agree, and they can be understood by programmers and mathematicians
accustomed to classical logic.

%\bigskip

RZ was designed as a lightweight system
supporting a rich input language. Although transforming complete
proofs into complete code is possible~\cite{komagata+:tr95}, we have not
implemented this. Other good systems, including Coq~\cite{coqart} and
Minlog~\cite{benl98:_proof_theor_work}, can
extract programs from proofs. But they work best managing the entire
task, from specification to code generation. In contrast, interfaces generated by RZ can be
implemented in any fashion as long as the assertions are satisfied.
Code can be written by hand, using imperative, concurrent, and other language features
rather than a ``purely functional'' subset. 
\iflong
At the other
extreme, the output of RZ can be viewed as a possible \emph{input} to
a program extraction tool, where the the distinction between
computational and non-computational parts (in Coq these are
$\mathtt{Set}$ and $\mathtt{Prop}$, respectively) has been
automatically determined; a corresponding implementation would then be
provided through theorem-proving and program extraction.
\else %\iflong
Or, the output can serve as a basis for theorem-proving and code
extraction using another system.
\fi
%\bigskip

\iflong
The paper is organized as follows. In
Section~\ref{sec:typed-realizability} we present a version of
realizability which is most suitable for our purposes.
Sections~\ref{sec:input-language} and~\ref{sec:spec-sign-assert}
describe the input and the output language of RZ, while in
Section~\ref{sec:translation} we explain how RZ translates from one to
the other. Various implementation issues are discussed in
Section~\ref{sec:implementation}, and examples of RZ at work are shown
in Section~\ref{sec:examples}. We conclude with remarks on related
work in Section~\ref{sec:related-work}.
\fi %\iflong

An earlier description of RZ work appears in \cite{bauer+:clase05};
since then, the input syntax and underlying implementation has been
significantly revised and improved, and the support for dependent types and
hoisting is completely new.

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "cie"
%%% End: 
