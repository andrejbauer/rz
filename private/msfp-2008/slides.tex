\documentclass[t]{beamer}

\usepackage{palatino}
\usepackage{amsfonts}
\usepackage{fancyvrb}
%\usepackage[all]{xypic}

% To show source
\DefineVerbatimEnvironment{source}{Verbatim}%
{commandchars=\\\{\}}

\DefineVerbatimEnvironment{sourcex}{Verbatim}%
{fontsize=\footnotesize,commandchars=\\\{\}}


\newcommand{\NN}{\mathbb{N}}
\newcommand{\QQ}{\mathbb{Q}}
\newcommand{\CC}{\mathbb{C}}
\newcommand{\rz}{\Vdash}

\title{Mathematically Structured but\\
not Necessarily Functional Programming}
\author{Andrej Bauer}
\institute{Department of Mathematics and Physics\\
  University of Ljubljana, Slovenia}
\date{Mathematically Structured Functional Programming\\Reykjavik, July 2008}

%\beamerdefaultoverlayspecification{<+->}
\mode<presentation>
% \usetheme{Goettingen}
\usecolortheme{rose}
\usefonttheme{serif}
\setbeamertemplate{navigation symbols}{}

\begin{document}

\begin{frame}
  \titlepage
\end{frame}

\begin{frame}
  \frametitle{Talk outline}

  \begin{itemize}
  \item Program development in type theory
  \item Relizability as an alternative
  \item RZ -- specifications via realizability
  \item Examples of non-functional realizers in constructive mathematics
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Propositions as types (theory)}

  \begin{itemize}
  \item Curry-Howard correspondence:
    %
    \begin{alignat*}{3}
      \mathrm{Type} &= \mathrm{Prop} &= \mathrm{Set} \\
      \mathrm{program} &= \mathrm{proof} &= \mathrm{element}
    \end{alignat*}
  \item Mathematically structured programming:
    %
    \begin{quote}
      ``(Constructive) proofs of mathematically meaningful theorems
      give useful programs.''
    \end{quote}
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Example: Fundamental Theorem of Algebra}

  \begin{itemize}
  \item ``Every non-constant polynomial has a complex root.''
  \item First-order logic:
    \begin{equation*}
      \forall p \in \QQ[x] .\,
      0 < \mathrm{deg}(p) \implies \exists z \in \CC .\, p(z) = 0.
    \end{equation*}
  \item Type theory:
    \begin{equation*}
      \textstyle
      \prod_{p : \mathtt{poly}} \mathtt{less}(0,
      \mathtt{deg}(p)) \to
      \sum_{z : \mathtt{complex}} \mathtt{eq}(p(z),0).
    \end{equation*}
  \item What are $\mathtt{poly}$, $\mathtt{less}$, $\mathtt{complex}$, and $\mathtt{eq}$?
  \item Programming language are usually \emph{not} dependently typed.
  \item Can we get rid of $\mathtt{less}$ and $\mathtt{eq}$ to get simply
    %
    \begin{equation*}
      \mathtt{poly} \to \mathtt{complex} \; ?
    \end{equation*}
  \end{itemize}

\end{frame}

\begin{frame}
  \frametitle{Propositions as Types (practice a la Coq)}

  \begin{itemize}
  \item Distinguish between computational and non-computational types:
    %
    \begin{align*}
      \mathtt{Set} &: \text{the sort of computational types} \\
      \mathtt{Prop} &: \text{the sort of non-computational types}
    \end{align*}
  \item In previous example, $\mathtt{poly}$ and $\mathtt{complex}$
    are computational and $\mathtt{less}$ and $\mathtt{eq}$ are
    non-computational.
  \item Actually, $\mathtt{poly}$ and $\mathtt{complex}$ are
    \emph{setoids}, i.e., types equipped with an equivalence relation.
  \item Coq's extraction mechanism gives an Ocaml or Haskell program of type
    $\mathtt{poly} \to \mathtt{complex}$.
  \end{itemize}
\end{frame}


\begin{frame}
  \frametitle{Problems}

  \begin{itemize}
  \item It can be tricky to write efficient programs by proving
    mathematically meaningful theorems.
  \item Proofs give purely functional code. What if we want to use
    computational effects (store, exceptions, non-termination)?
  \end{itemize}

\end{frame}

\begin{frame}
  \frametitle{Mathematically Structured Programming}

  \begin{itemize}
  \item Write programs directly, not as proofs.
  \item Prove that the programs are correct.
  \item Coq's \textsc{program} extension does this.
  \item By adapting the type theory, we can even handle non-functional
    programs:
    \begin{itemize}
    \item YNot
    \item Separation logic
    \end{itemize}
  \end{itemize}
\end{frame}


\begin{frame}[fragile]
  \frametitle{Not all programs are proofs}

  \begin{itemize}
  \item Consider
    %
    \begin{equation*}
      \forall m : \NN .\, \exists n : \NN .\, m < n
    \end{equation*}
    %
  \item The proof ``take $n$ to be $m+1$'' yields the realizer
    %
\begin{source}
  let r = fun m -> m + 1      
\end{source}
    %
  \item The following realizer does not correspond to a proof:
    %
\begin{source}
  let s =
    let k = ref 0 in
      fun m -> (k := !k + 1; m + k)
\end{source}
    %
    \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Sets and setoids}

  \begin{itemize}
  \item Propositions as types:
    %
    \begin{itemize}
    \item types
    \item setoids
    \end{itemize}
  \item Realizability:
    %
    \begin{itemize}
    \item sets
    \end{itemize}
  \end{itemize}

\end{frame}

\begin{frame}
  \frametitle{Pers}

  Comparison with setoids.

\end{frame}

\begin{frame}
  \frametitle{Propositions as types}

  \begin{itemize}
  \item A proposition $\phi$ is interpreted as a type $|\phi|$ in
    \emph{dependent} type theory:
    %
    \begin{align*}
      |\top| &= \mathtt{unit} \\
      |\phi \land \psi| &= |\phi| \times |\psi| \\
      |\phi \lor \psi| &= |\phi| + |\psi| \\
      |\forall x : A .\, \phi| &= \textstyle\prod_{x : |A|} |\phi| \\
      |\exists x : A .\, \phi| &= \textstyle\sum_{x : |A|} |\phi|
    \end{align*}
  \item All terms of type $|\phi|$ realize $\phi$:
    %
    \begin{equation*}
      \text{``$r$ realizes $\phi$''} \iff r : |\phi|
    \end{equation*}
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Realizability}

  \begin{itemize}
  \item A proposition $\phi$ is interpreted as a type $|\phi|$ in a
    programming language:
    %
    \begin{align*}
      |\top| &= \mathtt{unit} \\
      |\phi \land \psi| &= |\phi| \times |\psi| \\
      |\phi \lor \psi| &= |\phi| + |\psi| \\
      |\forall x : A .\, \phi| &= |A| \to |\phi| \\
      |\exists x : A .\, \phi| &= |A| \times |\phi|
    \end{align*}
  \item \emph{Not} all terms of $|\phi|$ realize $\phi$:
    %
    \begin{equation*}
      \text{``$r$ realizes $\phi$''} \iff \text{$r : |\phi|$ and $r \Vdash \phi$}
    \end{equation*}
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{RZ}

  What it is.
\end{frame}

\begin{frame}
  \frametitle{Example use of RZ}

  Era.
\end{frame}

\begin{frame}
  \frametitle{Translating into Coq}

  Automatic separation of computational and non-computational part.
\end{frame}

\begin{frame}
  \frametitle{Non-functional realizers}

  Realizers which use effects.

  Usually they imply extra reasoning principles.
\end{frame}

\begin{frame}
  \frametitle{Unbounded search and Markov Principle}

  \begin{itemize}
  \item Markov principle: a sequence of $0$'s and $1$'s whose terms
    are not all $0$ contains a $1$.
  \item Provable in classical logic.
  \item Not provable in intuitionistc logic.
  \item As a formula:
    %
    \begin{equation*}
      \forall a : \{0,1\}^\NN .\,
      (\lnot \forall n : \NN .\, a(n) = 0) \implies
      \exists n : \NN .\, a(n) = 1.
    \end{equation*}
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Compactness of Cantor space}

  Escardo's programs.

  Decompile prevents it.
\end{frame}

\begin{frame}
  \frametitle{Continuity principle}

  \begin{itemize}
  \item 
    Every map $f : \NN^\NN \to \NN$ is continuous at every point $a \in
    \NN^\NN$.
  \item 
    In other words, $f(a)$ depends only on a finite prefix of
    $a(0), a(1), a(2), \ldots$.
  \item Incompatible with classical logic.
  \item Cannot be proved in intuitionistic logic.
  \item As a formula:
    % 
    \begin{multline*}
      \forall f \in \NN^{\NN^\NN} .\,
      \forall a \in  \NN^\NN.\,
      \exists n \in \NN .\,
      \forall b \in \NN^\NN .\,\\
      ((\forall k \leq n .\, a(k) = b(k)) \implies f(a) = f(b)).
    \end{multline*}
  \end{itemize}

\end{frame}

\begin{frame}[fragile]
  \frametitle{With store}

\begin{source}
let r f a =
  let k = ref 0 in
  let b n = (k := max !k n; a n) in
    f b ; !k
\end{source}


  Exceptions.

  Can we do it in Haskell?
\end{frame}

\begin{frame}[fragile]
  \frametitle{With exceptions}

\begin{source}
exception Abort
let r f a =
  let rec search k =
    try
      let b n = 
        if n < k then a n else raise Abort
      in
        f b ; k
    with Abort -> search (k+1)
  in
    search 0
\end{source}

  Can we do it in Haskell?
\end{frame}

\begin{frame}
  \frametitle{When is a realizer ``good''?}

  Longley's notion of functional realizer.

  Why it is not suitable.

  Can we do better?
\end{frame}


\end{document}
