\documentclass{article}

\usepackage{fullpage}
\usepackage{times}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{theorem}
\usepackage{fancyvrb}

%% MACROS

\newcommand{\ut}[1]{|#1|}
\newcommand{\tot}[1]{\|#1\|}
\newcommand{\per}[1]{\approx_{#1}}
\newcommand{\PL}{\mathcal{P}}
\newcommand{\Mod}[1]{\mathsf{Mod}(#1)}
\newcommand{\rz}{\Vdash}
\newcommand{\note}[1]{\texttt{[#1]}}
\newcommand{\fst}[1]{\texttt{fst}\,#1}
\newcommand{\snd}[1]{\texttt{snd}\,#1}
\newcommand{\inl}[1]{\texttt{inl}\,#1}
\newcommand{\inr}[1]{\texttt{inr}\,#1}

\newcommand{\comment}[1]{\textbf{[#1]}}

%% THEOREM-LIKE ENVIRONMENTS

{
  \theorembodyfont{\itshape}

%  \newtheorem{theorem}{Theorem}[chapter]
  \newtheorem{theorem}{Theorem}[section]
  \newtheorem{Axiom}{Axiom}[section]
  \newtheorem{lemma}[theorem]{Lemma}
  \newtheorem{proposition}[theorem]{Proposition}
  \newtheorem{corollary}[theorem]{Corollary}
  \newtheorem{conjecture}[theorem]{Conjecture}
%  \newtheorem{exercise}[theorem]{Exercise}

{
  \theorembodyfont{\rmfamily}
  \newtheorem{definition}[theorem]{Definition}
  \newtheorem{example}[theorem]{Example}
  \newtheorem{remark}[theorem]{Remark}
  \newtheorem{question}[theorem]{Question}
  \newtheorem{problem}{Problem}
}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{document}

\twocolumn

\title{Specifications via Realizability}

\author{
  Andrej Bauer\\
  {\small Department of Mathematics and Physics}\\
  {\small University of Ljubljana, Slovenia}\\
  {\small \texttt{Andrej.Bauer@andrej.com}}
  \and
  Christopher Stone\\
  {\small Computer Science Department}\\
  {\small Harvey Mudd College, USA}\\
  {\small \texttt{stone@cs.hmc.edu}}
}

\maketitle

\begin{abstract}
  Foo bar.
\end{abstract}

\section{Introduction}
\label{sec:introduction}

We present a system, called \emph{RZ}, for automatic generation of
program specifications from mathematical theories. We translate
mathematical theories to specifications by computing their
realizability interpretations in an ML-like language augmented with
assertions. While the system is best suited for descriptions of those
programming tasks that can be easily described in mathematical
language (e.g., algorithms on finitely presented groups, exact real
arithmetic, algorithms on graphs, etc.), it also elucidates the
relationship between data structures and constructive mathematics.

We assume throughout that we have chosen a fixed programming
language~$\PL$. We only require that the language has product and
function types. Any ML-like language will do~\note{reference to ML}.
Our implementation of RZ uses ocaml~\note{reference to ocaml} but
could easily be adopted to other variants of ML.


Other points:

As the realizability interpretation validates the laws of
intuitionistic logic, rather than classical one, 


Allow programmer to write the most efficient program. Contrast with
extraction of programs from proofs, where presently one cannot expect
to get useful programs (also, who writes really long formal proofs?)

Bring constructive reasoning closer to programmers.

Overview.

\section{Realizability}
\label{sec:realizability}

Kleene~\cite{KleeneSC:intint} introduced realizability as a model of
intuitionistic arithmetic based on partial computable functions. The
idea has been studied and generalized by various
authors~\cite{TroelstraA:rea,HylandJ:efft,HylandJ:trit,OostenJ:exer}.
We build on the idea of \emph{typed realizability} by
Longley~\cite{Longley00}.

We briefly motivate the main idea of (typed) realizability. When we
represent a set of mathematical objects~$S$ in a programming
language~$\PL$ there are two natural steps to take: first choose an
\emph{underlying datatype~$\ut{S}$} of representing values, and second
specify how the values of type~$\ut{S}$ represent, or \emph{realize},
elements of the set~$S$. For example, consider how we might represent
the set~$D$ of simple finite directed graphs (whose vertices are
labeled by integers). As the underlying datatype we might choose
$\ut{D} = \mathtt{int} \; \mathtt{list} * (\mathtt{int} *
\mathtt{int}) \; \mathtt{list}$, and represent a graph~$G \in D$ as a
pair of lists $(v,e)$ where $v = [x_1; \ldots; x_n]$ is the list of
vertices and $e = [e_1; \ldots; e_m]$ is the list of edges. Formally,
we write
%
\begin{equation*}
  (v, e) \rz_D G
\end{equation*}
%
and read it as ``$(v,e)$ realizes~$G \in D$''. Observe that each graph
is realized by at least one pair of lists, and that no pair of lists
represents more than one graph. This leads us to the definition given
below. We shall abuse notation slightly and write $t \in \ut{S}$ to
mean that $t$ is a closed expression of type $\ut{S}$.

\begin{definition}
  A \emph{modest set}\footnote{Modest sets were so named by Dana
    Scott. They are ``modest'' because their size cannot exceed the
    number of expressions of the underlying datatype.} is a triple
  $(S, \ut{S}, {\rz_S})$ where $S$ is a set, $\ut{S}$ is a type and
  $\rz_S$ is a relation between expressions of type~$\ut{S}$ and
  elements of~$S$, satisfying:
  % 
  \begin{enumerate}
  \item For every $x \in S$ there is $t \in \ut{S}$ such that $t \rz_S
    x$.
  \item If $t \rz_S x$ and $t \rz_S y$ then $x = y$.
  \end{enumerate}
  %
  A \emph{realized function} $f : (S, \ut{S}, {\rz_S}) \to (T, \ut{T},
  {\rz_T})$ between modest sets is a function $f : S \to T$ for which
  there exists $u \in \ut{S} \to \ut{T}$ such that
  %
  \begin{equation*}
    t \rz_S x \implies u\,t \rz_T f(x) \;.
  \end{equation*}
  %
  We say that $u$ \emph{realizes}~$f$.
\end{definition}

The realizer~$u$ of a realized function~$f$ is more commonly known as
an ``implementation of~$f$'' or an ``algorithm for computing~$f$''.

Modest sets and realized functions form a category of \emph{modest
  sets~$\Mod{\PL}$}. In realizability theory this is a well known
category with good properties. It is regular and locally cartesian
closed, which allows us to interpret first-order logic and a rich type
theory. Here we only outline the main ideas behind the realizability
interpretation of logic. See e.g.~\cite{Bauer:00} for details.

In the realizability interpretation of logic, each formula~$\phi$ is
assigned a set of \emph{realizers} which can be thought of as
computations that witness the validity of~$\phi$. The situation is
somewhat similar (but not equivalent) to the propositions-as-types
translation of logic into type theory, where the proofs of a
proposition correspond to terms of the corresponding type. More
precisely, to each formula~$\phi$ we assign an underlying type
$\ut{\phi}$ of realizers. However, unlike in the propositions-as-types
translation, not all terms of type $\ut{\phi}$ are necessarily valid
realizers for~$\phi$. We write $t \rz \phi$ when $t \in \ut{\phi}$ is
in fact a realizer for~$\phi$. The underlying types and the
realizability relation~$\rz$ are defined inductively on the structure
of~$\phi$, see the outline in Figure~\ref{fig:rz-logic}. We say that a
formula~$\phi$ is \emph{valid} in~$\Mod{\PL}$ if it has at least one
realizer.

\begin{figure*}
  \centering
  \parbox[t]{0.35\textwidth}{
    \begin{align*}
      \ut{\top} &= \mathtt{unit} \\
      \ut{\bot} &= \mathtt{void} \\
      \ut{x =_S y} &= \mathtt{unit} \\
      \ut{\phi \land \psi} &= \ut{\phi} * \ut{\psi} \\
      \ut{\phi \implies \psi} &= \ut{\phi} \to \ut{\psi} \\
      \ut{\phi \lor \psi} &= \ut{\phi} + \ut{\psi} \\
      \ut{\forall x \in A .\, \phi(x)} &= \ut{A} \to \ut{\phi} \\
      \ut{\exists x \in A .\, \phi(x)} &= \ut{A} \times \ut{\phi}
    \end{align*}
  }
  \quad
  \parbox[t]{0.5\textwidth}{
    \begin{align*}
      () \rz \top &
      \\
      () \rz x =_S y
        &\quad\text{iff}\quad 
      x \per{S} y
      \\
      (t_1,t_2) \rz \phi \land \psi
        &\quad\text{iff}\quad
        \text{$t_1 \rz \phi$ and $t_2 \rz \psi$}
      \\
      t \rz \phi \implies \psi
        &\quad\text{iff}\quad
        \text{for all $u \in \ut{\phi}$, if $u \rz \phi$ then $t\,u
          \rz \psi$}
      \\
      \inl{t} \rz \phi \lor \psi
        &\quad\text{iff}\quad
        \text{$t \rz \phi$}
      \\
      \inr{t} \rz \phi \lor \psi
        &\quad\text{iff}\quad
        \text{$t \rz \psi$}
      \\
      t \rz \forall x \in A . \phi(x)
        &\quad\text{iff}\quad
        \text{for all $u \in \ut{A}$, if $u \rz_A x$ then $t\,u \rz \phi(x)$}
      \\
      (t_1, t_2) \rz \exists x \in A . \phi(x)
        &\quad\text{iff}\quad
        \text{$t_1 \rz_A x$ and $t_2 \rz \phi(x)$}
    \end{align*}
  }
  \caption{Outline of realizability interpretation of logic}
  \label{fig:rz-logic}
\end{figure*}

We shall not dwell any further on the technicalities involving the
category of modest sets, but rather proceed to a concrete description
of our realizability translation. There is one technical point,
though, which we first take care of. A modest set is a triple $(S,
\ut{S}, {\rz_S})$ in which~$S$ is an arbitrary set. For an automated
system it would be convenient if it did not have to refer to arbitrary
sets but rather just to ingredients that are already present in the
programming language, such as types and sets of expressions. Up to
equivalence of categories, modest sets can be construed as triples
$(\ut{S}, \tot{S}, {\per{S}})$ where $\ut{S}$ is a type, $\tot{S}$ is
a subset of expressions of type~$\ut{S}$, called the \emph{total
  values},\footnote{We do \emph{not} require that a total value must
  be a terminating expression.} and $\per{S}$ is an equivalence
relation on~$\tot{S}$. The relationship between this representation of
a modest set and the original one is as follows:
%
\begin{itemize}
\item $\tot{S}$ is the set of those expressions $t \in \ut{S}$ that
  realize something, i.e., there is $x \in S$ such that $t \rz_S x$.
\item $t \per{S} u$ if $t$ and $u$ realize the same element, i.e.,
  there is $x \in S$ such that $t \rz_S x$ and $u \rz_S x$.
\end{itemize}
%
The alternative view of a modest set $(\ut{S}, \tot{S}, {\per{S}})$
only refers to objects and concepts from the programming language. It
is better suited for our purposes.

Note that the equivalence relation on~$\tot{S}$ is also a
\emph{partial} equivalence relation on~$\ut{S}$, which shows that
modest sets are in fact equivalent to PER models.


\section{Theories and Signatures}
\label{sec:theories-signatures}

In this section we describe first-order theories and signatures.
Our system translates the former into the later.

\subsection{Theories}
\label{sec:theories}

A \emph{theory} is a description of a mathematical structure, such as
a group, a vector space, a directed graph, etc. A theory consists of
%
\begin{itemize}
\item a list of \emph{basic sets},
\item a list of \emph{basic constants} belonging to specified sets,
\item a list of \emph{basic relations} on specified sets,
\item a list of axioms.
\end{itemize}
%
To take a simple example, consider the theory~$T$ of a semigroup in
which every element has a (possibly non-unique) square root; recall
that a semigroup is a set with an associative binary operation and a
neutral element.\footnote{An example of such a semigroup are the
  complex numbers with multiplication as the binary operation.} In our
system it could be written as follows:
%
\begin{Verbatim}
theory T =
thy
  set s
  const e : s
  const ( * ) : s -> s -> s
  implicit x, y, z : s
  axiom unit x =
    x * e = x and e * x = x
  axiom assoc x y z =
    x * (y * z) = (x * y) * z
  axiom sqrt x =
    some y . y * y = x
end
\end{Verbatim}
%
The theory is enclosed by \Verb|thy|\ldots\Verb|end|. This theory
defines one basic set \Verb|s|, and two basic constants: an element
\Verb|e| of \Verb|s|, a (curried) binary infix operator \Verb|*| on
the set \Verb|s|. The \Verb|implicit| operator is not part of the
theory proper, but signals to the type checker that all bound
variables named \Verb|x| or \Verb|y| or \Verb|z| should be assumed to
range over elements in \Verb|s| unless otherwise specified. Finally,
we have three axioms. Axiom arguments, e.g., \Verb|x|, \Verb|y|, and
\Verb|z| in the associativity axiom, name the free variables occuring
in the axiom. It is not too big a mistake to think of them as being
universally quantified.

It is important to note that theories do not include proofs, but
rather just the statements of the axioms (and theorems) specified to
hold. Thus although axioms can be defined, one cannot actually refer
to them within the theory.

There are several features of theories that our system supports other
than those shown in this example above:
%
\begin{itemize}
\item
  As already mentioned, a theory may list basic predicates and relations.
  These can be declared \Verb|stable|, which means that their
  computational interpretation is trivial, see
  Section~\ref{sec:real-transl} for further discussion of this point.
  %
\item The language of sets includes cartesian product, function
  spaces, disjoint unions, subsets, quotients by stable equivalence
  relations, and sets of realizers. The corresponding introduction and
  elimination forms appear in the language of terms.

\item Convenient abbreviations may be defined for constants sets and
  relations. For example, a theory might want to give a name to the
  set of non-zero numbers.

\item A theory can postulate the existence of a model of some
  theory.  For example, a theory of real numbers could start by
  postulating a model \Verb|N| of the theory \Verb|Nat| of natural
  numbers.

\item Axioms can universally quantify over all models of a theory.
  This is useful for describing universaility properties, such as
  initiality of an algebra or finality of a coalgebra.

\item Comments may be included in the theory.

\end{itemize}

\comment{Really, I should create a figure containing the abstract syntax.}

\subsection{Signatures}
\label{sec:signatures}

On the logical side, we have models described by theories.  Thus on
the programming side we should have implementations being described by
specifications.  Our tool thus translates theories into
\emph{signatures}, which are ML's module interfaces.

Signatures allow us to require the existence of certain types, as well
as values of given type.  This allows decidable typechecking, but we
need more expressiveness in order to faithfully translate the content
of a theory.  We therefore generate signatures augmented by assertion
comments, which specify constraints on the values and functions an
implementation beyond their type.  It is the responsibility of the
programmer to check that the implementation satisfies these
assertions, as our tool does not attempt to do any theorem proving.

Assertions are written in ordinary classical first-order logic. Since
programmers typically are not trained in constructive logic, this
may make it easier to verify the assertions.

The output for the \Verb|Group| theory above is then:
\begin{Verbatim}
module type Group = 
sig
  type g
  (**  Assertion per_g =  PER(=g=)
  *)
   
  val e : g
  (**  Assertion e_total =  e : ||g||
  *)
   
  val ( * ) : g -> g -> g
  (**  Assertion ( * )_total =
         all (x:g, y:g).  x =g= y =>
           all (x':g, y':g).  x' =g= y' => 
             x * x' =g= y * y'
  *)
   
  val i : g -> g
  (**  Assertion i_total =  
          all (x:g, y:g).  
             x =g= y => i x =g= i y
  *)
   
  (**  Assertion unit (x:g) =  
          e * x =g= x and x * e =g= x
  *)
   
  (**  Assertion associative (x:g,y:g,z:g) =  
          (x * y) * z =g= x * (y * z)
  *)
   
  (**  Assertion inverse (x:g) =  
          x * i x =g= e and i x * x =g= e
  *)
end
\end{Verbatim}
\comment{Hmm...This really isn't interesting at all.  With the
  exception of the totality predicates, it's just the same as the
  input.  What would a better small example be?  Maybe something
  that produces an obligation?
  }

\subsection{Parameterized Theories and Functor Signatures}
\label{sec:param-theor-funct}


Mention that we can handle parameterized theories and functor
signatures, but avoid explaining everything about them.

\section{Implementation}
\label{sec:impliementation}

After parsing, our implementation does type checking.  The type
checker does rather limited type reconstruction; the types of all
bound variables must either be given at the binding site, given
through an \Verb|implicit| declaration, or be obvious from local
context.  A very small amount of implicit subtyping is done (primarily
between sums).  

The system will also try to insert explicit coercions into or out of
subset types where they were omitted by the theory author.  This can
significantly improve readability.  \comment{give example!}

After typechecking the theories are represented in abstract syntax and
translated into ML signatures as described below.  

Propositions without constructive content have trivial realizers, and
so a final ``unit elimination'' pass removes these and does a few
peephole simplifications of the resulting signature. \comment{give example!}

\comment{I could say more about the typechecker and the optimizer, but
  I'm not sure this audience would care much.}

Here we provide more details about the translation.


\section{Examples}
\label{sec:examples}

Here are some possible examples.

Decidable sets to point out the difference between a general modest
set and one whose equality is actually computable.

The difference between the theory of a group and theory of (finitely
presentable) groups.

Finite sets as the free join-semilattice.

Axiom of choice is not realizable. This example is needed to point out
that we are not doing propositions-as-types. But intensional axiom of
choice is realized.

Real numbers and exact arithmetic, if there is space.

\section{Conclusion}
\label{sec:conclusion}

We are the champions.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Bibliography

\bibliographystyle{alpha}

\bibliography{case}


\end{document}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: t
%%% End: 
