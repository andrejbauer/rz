\documentclass{article}

\usepackage{fullpage}
\usepackage{times}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{theorem}
\usepackage{fancyvrb,xspace}

%% MACROS

\newcommand{\ut}[1]{|#1|}
\newcommand{\tot}[1]{\|#1\|}
\newcommand{\per}[1]{\approx_{#1}}
\newcommand{\PL}{\mathcal{P}}
\newcommand{\Mod}[1]{\mathsf{Mod}(#1)}
\newcommand{\rz}{\Vdash}
\newcommand{\note}[1]{\texttt{[#1]}}
\newcommand{\fst}[1]{\texttt{fst}\,#1}
\newcommand{\snd}[1]{\texttt{snd}\,#1}
\newcommand{\inl}[1]{\texttt{inl}\,#1}
\newcommand{\inr}[1]{\texttt{inr}\,#1}

\newcommand{\comment}[1]{\textbf{[#1]}}

%% THEOREM-LIKE ENVIRONMENTS

{
  \theorembodyfont{\itshape}

%  \newtheorem{theorem}{Theorem}[chapter]
  \newtheorem{theorem}{Theorem}[section]
  \newtheorem{Axiom}{Axiom}[section]
  \newtheorem{lemma}[theorem]{Lemma}
  \newtheorem{proposition}[theorem]{Proposition}
  \newtheorem{corollary}[theorem]{Corollary}
  \newtheorem{conjecture}[theorem]{Conjecture}
%  \newtheorem{exercise}[theorem]{Exercise}
}

{
  \theorembodyfont{\rmfamily}
  \newtheorem{definition}[theorem]{Definition}
  \newtheorem{example}[theorem]{Example}
  \newtheorem{remark}[theorem]{Remark}
  \newtheorem{question}[theorem]{Question}
  \newtheorem{problem}{Problem}
}

\newcommand{\keywd}[1]{\mbox{\texttt{#1}}\xspace}
\newcommand{\ALL}{\keywd{all}}
\newcommand{\AND}{\keywd{and}}
\newcommand{\AXIOM}{\keywd{axiom}}
\newcommand{\BOOL}{\keywd{bool}}
\newcommand{\CONST}{\keywd{const}}
\newcommand{\COROLLARY}{\keywd{corollary}}
\newcommand{\EQUIV}{\keywd{equiv}}
\newcommand{\EQUIVALENCE}{\keywd{equivalence}}
\newcommand{\EQUIVPROP}{\keywd{Equiv}}
\newcommand{\END}{\keywd{end}}
\newcommand{\EXISTS}{\keywd{exists}}
\newcommand{\EXISTSONE}{\keywd{exists1}}
\newcommand{\FALSE}{\keywd{false}}
\newcommand{\FORALL}{\keywd{forall}}
\newcommand{\IMPLICIT}{\keywd{implicit}}
\newcommand{\IFF}{\keywd{iff}}
\newcommand{\IMPLY}{\keywd{implies}}
\newcommand{\IN}{\keywd{in}}
\newcommand{\LAMBDA}{\keywd{lam}}
\newcommand{\LEMMA}{\keywd{lemma}}
\newcommand{\LET}{\keywd{let}}
\newcommand{\MATCH}{\keywd{match}}
\newcommand{\MODEL}{\keywd{model}}
\newcommand{\NOT}{\keywd{not}}
\newcommand{\OR}{\keywd{or}}
\newcommand{\PROP}{\keywd{Prop}}
\newcommand{\PROPOSITION}{\keywd{proposition}}
\newcommand{\PREDICATE}{\keywd{predicate}}
\newcommand{\RELATION}{\keywd{relation}}
\newcommand{\RZ}{\keywd{rz}}
\newcommand{\SET}{\keywd{set}}
\newcommand{\SOME}{\keywd{some}}
\newcommand{\SOMEONE}{\keywd{some1}}
\newcommand{\STABLE}{\keywd{stable}}
\newcommand{\STABLEPROP}{\keywd{Stable}}
\newcommand{\STRUCTURE}{\keywd{structure}}
\newcommand{\THE}{\keywd{the}}
\newcommand{\THEOREM}{\keywd{theorem}}
\newcommand{\THEORY}{\keywd{theory}}
\newcommand{\THY}{\keywd{thy}}
\newcommand{\TRUE}{\keywd{true}}
\newcommand{\UNIT}{\mbox{\Verb| unit |}}
\newcommand{\WITH}{\keywd{with}}

\newcommand{\metav}[1]{\mbox{\textit{#1}}\xspace}

\newcommand{\Case}{\metav{case}}
\newcommand{\Ident}{\metav{name}}
\newcommand{\Identifier}{\Ident}
\newcommand{\Label}{\metav{\Verb|`|label}}
\newcommand{\MIdentifier}{\metav{Modelname}}
\newcommand{\TIdentifier}{\metav{Theoryname}}
\newcommand{\Setexp}{\metav{set}}
\newcommand{\Set}{\metav{set}}
\newcommand{\Specification}{\metav{specification}}
\newcommand{\Proposition}{\metav{proposition}}
\newcommand{\Prop}{\metav{prop}}
\newcommand{\Param}{\metav{param}}
\newcommand{\MParam}{\metav{modelparam}}
\newcommand{\Term}{\metav{term}}
\newcommand{\Theoryexp}{\metav{theory}}

\newcommand{\AAND}{\mbox{\Verb| \&\& |}}
\newcommand{\ARROW}{\mbox{\Verb| -> |}}
\newcommand{\BAR}{\mbox{\Verb+ | +}}
\newcommand{\COLON}{\mbox{\Verb| : |}}
\newcommand{\COMMA}{\mbox{\Verb| , |}}
\newcommand{\EQUALS}{\mbox{\Verb| = |}}
\newcommand{\HASH}{\mbox{\Verb| \# |}}
\newcommand{\IIFF}{\mbox{\Verb| <=> |}}
\newcommand{\IIMPLY}{\mbox{\Verb| => |}}
\newcommand{\LBRACE}{\mbox{\Verb|\{ |}}
\newcommand{\LBRACK}{\mbox{\Verb|[ |}}
\newcommand{\LCOMMENT}{\mbox{\Verb|(* |}}
\newcommand{\LPAREN}{\mbox{\Verb|( |}}
\newcommand{\OOR}{\mbox{\Verb+ || +}}
\newcommand{\ONE}{\mbox{\Verb|1|}}
\newcommand{\PERCENT}{\mbox{\Verb+ \% +}}
\newcommand{\PLUS}{\mbox{\Verb| + |}}
\newcommand{\RBRACE}{\mbox{\Verb| \}|}}
\newcommand{\RBRACK}{\mbox{\Verb| ]|}}
\newcommand{\RCOMMENT}{\mbox{\Verb| *)|}}
\newcommand{\RPAREN}{\mbox{\Verb| )|}}
\newcommand{\PERIOD}{\mbox{\Verb| . |}}
\newcommand{\SUBIN}{\mbox{\Verb| :> |}}
\newcommand{\SUBOUT}{\mbox{\Verb| :< |}}
\newcommand{\TIMES}{\mbox{\Verb| * |}}
\newcommand{\TO}{\mbox{\Verb| -> |}}
\newcommand{\ZERO}{\mbox{\Verb|0|}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{document}

\twocolumn

\title{Specifications via Realizability}

\author{
  Andrej Bauer\\
  {\small Department of Mathematics and Physics}\\
  {\small University of Ljubljana, Slovenia}\\
  {\small \texttt{Andrej.Bauer@andrej.com}}
  \and
  Christopher Stone\\
  {\small Computer Science Department}\\
  {\small Harvey Mudd College, USA}\\
  {\small \texttt{stone@cs.hmc.edu}}
}

\maketitle

\begin{abstract}
  Foo bar.
\end{abstract}

\section{Introduction}
\label{sec:introduction}

We present a system, called \emph{RZ}, for automatic generation of
program specifications from mathematical theories. We translate
mathematical theories to specifications by computing their
realizability interpretations in an ML-like language augmented with
assertions. While the system is best suited for descriptions of those
programming tasks that can be easily described in mathematical
language (e.g., algorithms on finitely presented groups, exact real
arithmetic, algorithms on graphs, etc.), it also elucidates the
relationship between data structures and constructive mathematics.

We assume throughout that we have chosen a fixed programming
language~$\PL$. We only require that the language has product and
function types. Any ML-like language will do~\cite{milner+:definition}.
Our implementation of RZ uses Objective Caml~\cite{ocaml} but
could easily be adopted to other variants of ML.




Other points:

As the realizability interpretation validates the laws of
intuitionistic logic, rather than classical one, 


Allow programmer to write the most efficient program. Contrast with
extraction of programs from proofs, where presently one cannot expect
to get useful programs (also, who writes really long formal proofs?)

Bring constructive reasoning closer to programmers.

Overview.

\section{Realizability}
\label{sec:realizability}

Kleene~\cite{KleeneSC:intint} introduced realizability as a model of
intuitionistic arithmetic based on partial computable functions. The
idea has been studied and generalized by various
authors~\cite{TroelstraA:rea,HylandJ:efft,HylandJ:trit,OostenJ:exer}.
We build on the idea of \emph{typed realizability} by
Longley~\cite{Longley00}.

We briefly motivate the main idea of (typed) realizability. When we
represent a set of mathematical objects~$S$ in a programming
language~$\PL$ there are two natural steps to take: first choose an
\emph{underlying datatype~$\ut{S}$} of representing values, and second
specify how the values of type~$\ut{S}$ represent, or \emph{realize},
elements of the set~$S$. For example, consider how we might represent
the set~$D$ of simple finite directed graphs (whose vertices are
labeled by integers). As the underlying datatype we might choose
$\ut{D} = \mathtt{int} \; \mathtt{list} * (\mathtt{int} *
\mathtt{int}) \; \mathtt{list}$, and represent a graph~$G \in D$ as a
pair of lists $(v,e)$ where $v = [x_1; \ldots; x_n]$ is the list of
vertices and $e = [e_1; \ldots; e_m]$ is the list of edges. Formally,
we write
%
\begin{equation*}
  (v, e) \rz_D G
\end{equation*}
%
and read it as ``$(v,e)$ realizes~$G \in D$''. Observe that each graph
is realized by at least one pair of lists, and that no pair of lists
represents more than one graph. (It happens that in this case most graphs are
represented by many pairs of lists.) This leads us to the definition given
below. We shall abuse notation slightly and write $t \in \ut{S}$ to
mean that $t$ is a closed expression of type $\ut{S}$.

\begin{definition}
  A \emph{modest set}\footnote{Modest sets were so named by Dana
    Scott. They are ``modest'' because their size cannot exceed the
    number of expressions of the underlying datatype.} is a triple
  $(S, \ut{S}, {\rz_S})$ where $S$ is a set, $\ut{S}$ is a type and
  $\rz_S$ is a relation between expressions of type~$\ut{S}$ and
  elements of~$S$, satisfying:
  % 
  \begin{enumerate}
  \item For every $x \in S$ there is $t \in \ut{S}$ such that $t \rz_S
    x$.
  \item If $t \rz_S x$ and $t \rz_S y$ then $x = y$.
  \end{enumerate}
  %
  A \emph{realized function} $f : (S, \ut{S}, {\rz_S}) \to (T, \ut{T},
  {\rz_T})$ between modest sets is a function $f : S \to T$ for which
  there exists $u \in \ut{S} \to \ut{T}$ such that
  %
  \begin{equation*}
    t \rz_S x \implies u\,t \rz_T f(x) \;.
  \end{equation*}
  %
  We say that $u$ \emph{realizes}~$f$.
\end{definition}

The realizer~$u$ of a realized function~$f$ is more commonly known as
an ``implementation of~$f$'' or an ``algorithm for computing~$f$''.

Modest sets and realized functions form a category of \emph{modest
  sets~$\Mod{\PL}$}. In realizability theory this is a well known
category with good properties. It is regular and locally cartesian
closed, which allows us to interpret first-order logic and a rich type
theory. Here we only outline the main ideas behind the realizability
interpretation of logic. See e.g.~\cite{Bauer:00} for details.

In the realizability interpretation of logic, each formula~$\phi$ is
assigned a set of \emph{realizers} which can be thought of as
computations that witness the validity of~$\phi$. The situation is
somewhat similar (but not equivalent) to the propositions-as-types
translation of logic into type theory, where the proofs of a
proposition correspond to terms of the corresponding type. More
precisely, to each formula~$\phi$ we assign an underlying type
$\ut{\phi}$ of realizers. However, unlike in the propositions-as-types
translation, not all terms of type $\ut{\phi}$ are necessarily valid
realizers for~$\phi$. We write $t \rz \phi$ when $t \in \ut{\phi}$ is
in fact a realizer for~$\phi$. The underlying types and the
realizability relation~$\rz$ are defined inductively on the structure
of~$\phi$, see the outline in Figure~\ref{fig:rz-logic}. We say that a
formula~$\phi$ is \emph{valid} in~$\Mod{\PL}$ if it has at least one
realizer.

\begin{figure*}
  \centering
  \parbox[t]{0.35\textwidth}{
    \begin{align*}
      \ut{\top} &= \mathtt{unit} \\
      \ut{\bot} &= \mathtt{void} \\
      \ut{x =_S y} &= \mathtt{unit} \\
      \ut{\phi \land \psi} &= \ut{\phi} * \ut{\psi} \\
      \ut{\phi \implies \psi} &= \ut{\phi} \to \ut{\psi} \\
      \ut{\phi \lor \psi} &= \ut{\phi} + \ut{\psi} \\
      \ut{\forall x \in A .\, \phi(x)} &= \ut{A} \to \ut{\phi} \\
      \ut{\exists x \in A .\, \phi(x)} &= \ut{A} \times \ut{\phi}
    \end{align*}
  }
  \vline
  \quad
  \parbox[t]{0.5\textwidth}{
    \begin{align*}
      () \rz \top &
      \\
      () \rz x =_S y
        &\quad\text{iff}\quad 
      x \per{S} y
      \\
      (t_1,t_2) \rz \phi \land \psi
        &\quad\text{iff}\quad
        \text{$t_1 \rz \phi$ and $t_2 \rz \psi$}
      \\
      t \rz \phi \implies \psi
        &\quad\text{iff}\quad
        \text{for all $u \in \ut{\phi}$, if $u \rz \phi$ then $t\,u
          \rz \psi$}
      \\
      \inl{t} \rz \phi \lor \psi
        &\quad\text{iff}\quad
        \text{$t \rz \phi$}
      \\
      \inr{t} \rz \phi \lor \psi
        &\quad\text{iff}\quad
        \text{$t \rz \psi$}
      \\
      t \rz \forall x \in A . \phi(x)
        &\quad\text{iff}\quad
        \text{for all $u \in \ut{A}$, if $u \rz_A x$ then $t\,u \rz \phi(x)$}
      \\
      (t_1, t_2) \rz \exists x \in A . \phi(x)
        &\quad\text{iff}\quad
        \text{$t_1 \rz_A x$ and $t_2 \rz \phi(x)$}
    \end{align*}
  }
  \caption{Realizability interpretation of logic (outline)}
  \label{fig:rz-logic}
\end{figure*}

We shall not dwell any further on the technicalities involving the
category of modest sets, but rather proceed to a concrete description
of our realizability translation. There is one technical point,
though, which we first take care of. A modest set is a triple $(S,
\ut{S}, {\rz_S})$ in which~$S$ is an arbitrary set. For an automated
system it would be convenient if it did not have to refer to arbitrary
sets but rather just to ingredients that are already present in the
programming language, such as types and sets of expressions. Up to
equivalence of categories, modest sets can be construed as triples
$(\ut{S}, \tot{S}, {\per{S}})$ where $\ut{S}$ is a type, $\tot{S}$ is
a subset of expressions of type~$\ut{S}$, called the \emph{total
  values},\footnote{We do \emph{not} require that a total value must
  be a terminating expression.} and $\per{S}$ is an equivalence
relation on~$\tot{S}$. The relationship between this representation of
a modest set and the original one is as follows:
%
\begin{itemize}
\item $\tot{S}$ is the set of those expressions $t \in \ut{S}$ that
  realize something, i.e., there is $x \in S$ such that $t \rz_S x$.
\item $t \per{S} u$ if $t$ and $u$ realize the same element, i.e.,
  there is $x \in S$ such that $t \rz_S x$ and $u \rz_S x$.
\end{itemize}
%
The alternative view of a modest set $(\ut{S}, \tot{S}, {\per{S}})$
only refers to objects and concepts from the programming language. It
is better suited for our purposes.

Note that the equivalence relation on~$\tot{S}$ is also a
\emph{partial} equivalence relation on~$\ut{S}$, which shows that
modest sets are in fact equivalent to PER models.


\section{Theories and Signatures}
\label{sec:theories-signatures}

In this section we describe first-order theories and signatures.
Our system translates the former into the later.

\subsection{Theories}
\label{sec:theories}

A \emph{theory} is a description of a mathematical structure, such as
a group, a vector space, a directed graph, etc. A theory consists of
%
\begin{itemize}
\item a list of \emph{basic sets},
\item a list of \emph{basic constants} belonging to specified sets,
\item a list of \emph{basic relations} on specified sets,
\item a list of axioms.
\end{itemize}
%
To take a simple example, consider the theory~$T$ of a semigroup in
which every element has a (possibly non-unique) square root; recall
that a semigroup is a set with an associative binary operation and a
neutral element.\footnote{An example of such a semigroup are the
  complex numbers with multiplication as the binary operation.} In our
system it could be written as follows:
%
\VerbatimInput{semigroup.thy}
%
The theory is enclosed by \Verb|thy|\ldots\Verb|end|. This theory
defines one basic set \Verb|s|, and two basic constants: an element
\Verb|e| of \Verb|s|, a (curried) binary infix operator \Verb|*| on
the set \Verb|s|. The \Verb|implicit| operator is not part of the
theory proper, but signals to the type checker that all bound
variables named \Verb|x| or \Verb|y| or \Verb|z| should be assumed to
range over elements in \Verb|s| unless otherwise specified. Finally,
we have three axioms. Axiom arguments, e.g., \Verb|x|, \Verb|y|, and
\Verb|z| in the associativity axiom, name the free variables occuring
in the axiom. It is not too big a mistake to think of them as being
universally quantified.

It is important to note that theories do not include proofs, but
rather just the statements of the axioms (and theorems) specified to
hold. Thus although axioms can be defined, one cannot actually refer
to them within the theory.

There are several features of theories that our system supports other
than those shown in this example above; the input language is
summarized in Figure~\ref{fig:input}, where brackets imply optional
elements.


Theories may declare or define relations.  They may be \Verb|stable|,
i.e., their computational interpretation is trivial (see
Section~\ref{sec:real-transl} for further discussion of this point).
Axioms can universally quantify over all models of a theory.
  This is useful for describing universaility properties, such as
  initiality of an algebra or finality of a coalgebra.
  
  The propositions should are familiar; $\SOMEONE$ is unique
  existance.  In addition to the familiar empty ($\ZERO$) and unit
  ($\ONE$) sets, one can form cartesian products, function spaces,
  tagged disjoint unions, subsets, and quotients by stable equivalence
  relations. The corresponding introduction and elimination forms
  appear in the language of terms.  For example, $\Term\PERCENT\ 
  \metav{relation}$ is the equivalence class under $\metav{relation}$
  containing $\Term$, while $\LET\ x \PERCENT \metav{relation}
  \mbox{\Verb| =|}$ $ \Term_1\ \IN\ \Term_2$ binds $x$ to a
  representative of the equivalence class $\Term_1$ to be used in
  $\Term_2$.  $\Term \SUBIN \Set$ injects $\Term$ into a given subset
  (recording a proof obligation of the term actually being a member of the subset), while $\Term \SUBOUT \Set$ projects $\Term$ from a subset out
 into its superset $\Set$.

\begin{figure}
\[
\begin{array}{l}
\mbox{\textbf{Theory Elements}}\\
\SET\ s\ [\EQUALS\ \mathit{set}\ ]\\
\CONST\ c\ [\COLON \mathit{set}\ ]\ [\EQUALS\ \mathit{term}\ ]\\
{}[\STABLE{}]\ \RELATION\ r\ [\COLON \mathit{set}\ ]\ [\EQUALS \mathit{prop}\ ]\\
\EQUIVALENCE \COLON \mathit{set}\\
\MODEL\ M\COLON\mathit{theory}\\
\AXIOM\ a\ [\ M\COLON\mathit{theory}\ ]^{*}\ [x\COLON\mathit{set}\ ]^*\EQUALS\mathit{prop}\\
\\
\mbox{\textbf{Propositions}}\\
\TRUE\\
\FALSE\\
\NOT\ \Prop\\
\Prop \AAND \Prop\\
\Prop \OOR \Prop\\
\Prop \IIMPLY \Prop\\
\Prop \IIFF \Prop\\
r [\ \Term\ ]^*\\
\Term\EQUALS\Term\\ %[\IN\ \Set]\\
\ALL\ [x\COLON \Set] \PERIOD \Prop\\
\SOME\ [x\COLON \Set] \PERIOD \Prop\\
\SOME1\ [x\COLON \Set] \PERIOD \Prop\\
\\
\mbox{\textbf{Sets}}\\
\ZERO\\
\ONE\\
\BOOL\\
s\\
\mathit{Model}\PERIOD \mathit{name}\\
\Set \TIMES \cdots \TIMES \Set\\
\Setexp \ARROW \Setexp\\
\Label\ [\COLON \Setexp\ ]\ \PLUS \cdots \PLUS \Label\ [\COLON \Setexp\ ]\\
\LBRACE \Ident [\ \COLON \Setexp\ ]\ \BAR \Proposition \RBRACE\\
\Setexp \PERCENT \metav{relation}\\
%\RZ\ \Setexp\\
\\
\mbox{\textbf{Terms}}\\
x\\
\LPAREN \Term\COMMA \cdots \COMMA \Term \RPAREN\\
\Term\PERIOD \metav{n}\\
\Label\ [\ \Term\ ]\\
\MATCH\ \Term\ \WITH\ \mbox{\textit{pattern-matches}}\\
\LAMBDA\ x\COLON\Set\ \PERIOD\ \Term\\
\Term\ \Term\\
\LET\ x\EQUALS\Term\ \IN\ \Term\\
\THE\ x\COLON\Set \PERIOD \Prop\\
\Term \PERCENT \metav{relation}\\
\LET\ x \PERCENT \metav{relation}\ \IN\ \Term\EQUALS\Term\\
\Term \SUBIN \Set\\
\Term \SUBOUT \Set\\
\end{array}
\]  
\caption{Input Language Summary}
\label{fig:input}  
\end{figure}

\subsection{Signatures}
\label{sec:signatures}

On the logical side, we have models described by theories.  Thus on
the programming side we should have implementations being described by
specifications.  Our tool thus translates theories into
\emph{signatures}, which are ML's module interfaces.

Signatures allow us to require the existence of certain types, as well
as values of given type.  This allows decidable typechecking, but we
need more expressiveness in order to faithfully translate the content
of a theory.  We therefore generate signatures augmented by assertion
comments, which specify constraints on the values and functions an
implementation beyond their type.  It is the responsibility of the
programmer to check that the implementation satisfies these
assertions, as our tool does not attempt to do any theorem proving.

Assertions are written in ordinary classical first-order logic. (Since
programmers typically are not trained in constructive logic, this
may make it easier to verify the assertions.)

The output for the theory \Verb|SQGROUP| above is then:
\VerbatimInput{semigroup.mli} 

At the ML level we have required a type \Verb|s|, a value \Verb|e| of
type \Verb|s| and a binary function on \Verb|s|; \comment{I thought
  that names like \Verb|( * )| here were supposed to be translated
  away in the ML code?} these were mentioned explicitly in the theory.
For interestingly, the constructive content of the existential in the
\Verb|sqrt| axiom requires that a witness function be provided as
well; thus, the ML signature further requires a function \Verb|sqrt|
mapping \Verb|s| to \Verb|s|.

Comments contain other properties (not expressible in ML) that further
constrain the allowed implementations.  \Verb|PER(=s=)| requires a
partial equivalence \Verb|=s=| on \Verb|s|; its domain \Verb+||s||+ is the
subset of terms of type $s$ that represent group elements; the
relation equates different implementations corresponding to the same
abstract group element.  \Verb|e| must represent a
group element, and the \Verb|*| operation must not be affected by the
choice of representatives.  These must of course still satisfy the
\Verb|unit| and \Verb|assoc| axioms.  Finally, the new function
\Verb|sqrt| derived from the logic must compute square roots.  Since
the theory requires existence but not uniqueness of square roots, its
computational content does not require that \Verb|sqrt| be invariant
with respect to the partial equivalence relation on \Verb|s|;
different implementations of the same group element are allowed to produce
(implementations of) different square roots.


\subsection{Parameterized Theories}
\label{sec:param-theor-funct}

A theory may be parameterized by one or more models of other theories.
For example, a theory \Verb|Real| of the reals may be parameterized in
terms of a model \Verb|N| of the naturals.  A theory of free groups may be
parameterized in terms of the generating set.

Parameterized theories serve two purposes.  First a model of a
parameterized theory would be a generic implementation that, given any
implementation of the parameters, returns an implementation of the
resulting theory.  At the level of ML, this would be a function from
modules to modules, which is called a \emph{functor}, and so a
parameterized theory can be translated into the signature of a
functor.

Alternatively, once we have described a parameterized theory
\Verb|Real|, we may wish to use it to describe a single specific
implementation of real numbers based on a specific model \Verb|N1|
(implementation) of the natural numbers; this can be described as
an implementation satisfying the theory \Verb|Real(N1)|.

The dual nature of parameterized theories as being both a description
of a parameterized model (a $\Pi$ type) and something which can be
applied to a model to produce a specialized theory (a $\lambda$) is
very reminiscent the type inclusion of Automath~\cite{automath}.  ML
does not permit applications of functor signatures, however, so we
beta-reduce all theory applications before generating signatures;
\Verb|Real(N1)| would produce a signature for a real-number
implementation that refers directly to \Verb|N1| rather than to a
generic parameter \Verb|N|.

\section{Implementation}
\label{sec:implementation}

After parsing, our implementation does type checking.  The type
checker does rather limited type reconstruction; the types of all
bound variables must either be given at the binding site, given
through an \Verb|implicit| declaration, or be obvious from local
context.  A very small amount of implicit subtyping is done (primarily
between sums).  

The system will also try to insert explicit coercions into or out of
subset types where they were omitted by the theory author.  This can
significantly improve readability.  \comment{give example!}

After typechecking the theories are represented in abstract syntax and
translated into ML signatures as described below.  

Propositions without constructive content have trivial realizers, and
so a final ``unit elimination'' pass both removes these and does 
peephole simplification of the resulting signature.   Without the optimizer,
the axioms of the theory \Verb|SQGROUP| would produce
\begin{Verbatim}
val unit : s -> top * top
(**  Assertion unit (x:s) =  
      x * e =s= x and e * x =s= x
*)
   
val assoc : s -> s -> s -> top
(**  Assertion assoc (x:s,y:s,z:s) =
      x * (y * z) =s= (x * y) * z
*)
   
val sqrt : s -> s * top
(**  Assertion sqrt (x:s) =  
      pi0 (sqrt x) : ||s|| and 
      pi0 (sqrt x) * pi0 (sqrt x) =s= x
*)
\end{Verbatim}
requiring the presence of trivial realizers for the first two axioms,
and a more complicated (but not more useful) realizer for the final
axiom.


Here we provide more details about the translation.


The translation of axioms parameterized by models into polymorphism
(instead of functors) is essentially the phase-splitting translation
of Harper, Mitchell, and Moggi \cite{harper+:popl90}.

\section{Examples}
\label{sec:examples}

Here are some possible examples.

Decidable sets to point out the difference between a general modest
set and one whose equality is actually computable.

The difference between the theory of a group and theory of (finitely
presentable) groups.

Finite sets as the free join-semilattice.

Axiom of choice is not realizable. This example is needed to point out
that we are not doing propositions-as-types. But intensional axiom of
choice is realized.

Real numbers and exact arithmetic, if there is space.

\section{Conclusion}
\label{sec:conclusion}

We are the champions.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Bibliography

\bibliographystyle{alpha}

\bibliography{case}


\end{document}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: t
%%% End: 
