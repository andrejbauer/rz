\section{Introduction}
\label{sec:introduction}

We present a system, called~\emph{RZ}, for automatic generation of
program specifications from mathematical theories. We translate
mathematical theories to specifications by computing their
realizability interpretations in an ML-like language augmented with
assertions. While the system is best suited for descriptions of those
programming tasks that can be easily described in mathematical
language (e.g., algorithms on finitely presented groups, exact real
arithmetic, algorithms on graphs, etc.), it also elucidates the
relationship between data structures and constructive mathematics.

As the realizability interpretation validates the laws of
\emph{intuitionistic} logic, our input theories are intuitionistic or
constructive. Thus, RZ is a tool that extracts the computational
meaning of a constructive theory and expresses it as a programming
specification.

We emphasize that RZ does \emph{not} extract programs from proofs---in
fact, there is no way to write a proof in our system. We work ``one
level above'', so to speak, and just determine what the programs are
supposed to do, i.e., we provide specifications for them. We leave it
to the programmer, or to another tool, to construct the programs as he
or she best knows. This leaves the programmer completely free to write
the most efficient programs that do not necessarily correspond to any
proofs.

The original aim of RZ was to help with development of data structures
for computable mathematics. If one sets out to actually compute
realizability interpretations of theories of constructive mathematics,
one quickly wishes for an automated way of doing it. With a tool like
RZ it is much easier to experiment and try out variations of a theory
until a suitable specification is obtained. We have also discovered
that RZ can be used to explain and teach constructive mathematics to
programmers, who are typically trained in classical mathematics,
because it translates constructive statements to easily understood
requirements about programs (expressed in classical logic).

We assume throughout that we have chosen a fixed programming
language~$\PL$. Any ML-like language will
do~\cite{milner+:definition}. Our implementation of RZ uses Objective
Caml~\cite{ocaml} but could easily be adopted to other variants of ML.
The essential features we require of~$\PL$ are product, function, and
sum types, as well as support for module interfaces.

The paper is organized as follows. Section~\ref{sec:realizability}
contains a brief overview of realizability. In
Section~\ref{sec:theories-signatures} we describe theories and
signatures, which are the inputs and the outputs of RZ, respectively. In
Section~\ref{sec:implementation} we discuss various point of
implementation. In Section~\ref{sec:examples} we show typical examples
and conclude with Section~\ref{sec:conclusion}.


%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "case"
%%% End: 
