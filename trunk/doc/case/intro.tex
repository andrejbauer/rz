\section{Introduction}
\label{sec:introduction}

Kleene~\cite{KleeneSC:intint} introduced realizability as a model of
intuitionistic arithmetic based on partial computable functions. The
idea has since been studied and generalized by various
authors~\cite{TroelstraA:rea,HylandJ:efft,HylandJ:trit,OostenJ:exer}.
Building on the idea of \emph{typed realizability} by
Longley~\cite{Longley00}, we have constructed a tool \emph{RZ} to
translate mathematical theories into specifications for code,
explaining what is necessary in order to believe that we have a correct
implementation of the mathematical theory.

As the realizability interpretation validates the laws of
\emph{intuitionistic} logic, our input theories are intuitionistic or
constructive. Thus, \emph{RZ} extracts the computational
meaning of a constructive theory and expresses it as a programming
specification.

We emphasize that RZ does \emph{not} extract programs from proofs---in
fact, there is no way to write a proof in our system. We just
determine what the programs are supposed to do, i.e., we provide
specifications for them. We leave it to the programmer, or to another
tool, to construct the programs as he or she sees fit. This leaves
the programmer completely free to write efficient programs
that need not correspond directly to a formal proof.

The original aim of RZ was to aid development of data structures
for computable mathematics. If one sets out to actually compute
realizability interpretations of theories of constructive mathematics,
one quickly wishes for an automated way of doing it. With a tool like
RZ it is much easier to experiment and try out variations of a theory
until a suitable specification is obtained.  It also appears that
RZ can be used to explain and teach constructive mathematics to
programmers, who are typically trained in classical mathematics; 
it translates constructive statements into easily understood
requirements about programs (expressed in classical logic).

%We assume throughout that we have chosen a fixed programming
%language~$\PL$. %Any ML-like language will do~\cite{milner+:definition}. 
Our implementation of \emph{RZ} produces interfaces in Objective
Caml~\cite{ocaml} but could easily be adopted to other similar typed
languages.  The essential features we require of the target language
are product, function, and sum types, as well as support for module
interfaces.

The paper is organized as follows. Section~\ref{sec:realizability}
contains a brief overview of realizability. In
Section~\ref{sec:theories-signatures} we describe theories and
signatures, which are the inputs and the outputs of RZ, respectively. In
Section~\ref{sec:implementation} we discuss various point of
implementation. In Section~\ref{sec:examples} we show typical examples
and conclude with Section~\ref{sec:conclusion}.


%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "case"
%%% End: 
