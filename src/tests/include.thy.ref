[Processing ./include.thy]
module type A =
 sig
   type a
    
   (** predicate (=a=) : a -> a -> bool *)
   (**  Assertion symmetric_a [Definitional] = 
          forall x:a, y:a,  x =a= y -> y =a= x
         
        Assertion transitive_a [Definitional] = 
          forall x:a, y:a, z:a,  x =a= y /\ y =a= z -> x =a= z
   *)
 end
 
module type B =
 sig
   type a
    
   (** predicate (=a=) : a -> a -> bool *)
   (**  Assertion symmetric_a [Definitional] = 
          forall x:a, y:a,  x =a= y -> y =a= x
         
        Assertion transitive_a [Definitional] = 
          forall x:a, y:a, z:a,  x =a= y /\ y =a= z -> x =a= z
   *)
    
   type b
    
   (** predicate (=b=) : b -> b -> bool *)
   (**  Assertion symmetric_b [Definitional] = 
          forall x:b, y:b,  x =b= y -> y =b= x
         
        Assertion transitive_b [Definitional] = 
          forall x:b, y:b, z:b,  x =b= y /\ y =b= z -> x =b= z
   *)
 end
 
module type C =
 sig
   type a
    
   (** predicate (=a=) : a -> a -> bool *)
   (**  Assertion symmetric_a [Definitional] = 
          forall x:a, y:a,  x =a= y -> y =a= x
         
        Assertion transitive_a [Definitional] = 
          forall x:a, y:a, z:a,  x =a= y /\ y =a= z -> x =a= z
   *)
    
   type b
    
   (** predicate (=b=) : b -> b -> bool *)
   (**  Assertion symmetric_b [Definitional] = 
          forall x:b, y:b,  x =b= y -> y =b= x
         
        Assertion transitive_b [Definitional] = 
          forall x:b, y:b, z:b,  x =b= y /\ y =b= z -> x =b= z
   *)
    
   type d = a * b
   (**  Assertion d_def_support = 
          forall p:d,  p : ||d|| <-> pi0 p : ||a|| /\ pi1 p : ||b||
         
        Assertion d_def_per = 
          forall p:d, q:d,  p =d= q <-> pi0 p =a= pi0 q /\ pi1 p =b= pi1 q
   *)
 end

