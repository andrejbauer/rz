[Processing ./dependent_product.thy]
module type T =
 sig
   type s
    
   (**{v predicate (=s=) : s -> s -> bool v}*)
   (**  {v assertion symmetric_s :  forall x:s, y:s,  x =s= y -> y =s= x v}
         
        {v assertion transitive_s : 
          forall x:s, y:s, z:s,  x =s= y /\ y =s= z -> x =s= z v}
   *)
    
   (**{v predicate ||s|| : s -> bool v}*)
   (**  {v assertion support_def_s :  forall x:s,  x : ||s|| <-> x =s= x v}
   *)
    
   type t
    
   (**{v predicate (=t=) : s -> t -> t -> bool v}*)
   (**  {v assertion strict_t : 
          forall x:s, y:t, z:t,  y =(t x)= z -> x : ||s|| v}
         
        {v assertion extensional_t : 
          forall x:s, y:s, z:t, w:t,  x =s= y -> z =(t x)= w -> z =(t y)= w v}
         
        {v assertion symmetric_t : 
          forall x:s, y:t, z:t,  y =(t x)= z -> z =(t x)= y v}
         
        {v assertion transitive_t : 
          forall x:s, y:t, z:t, w:t,  y =(t x)= z /\ z =(t x)= w ->
            y =(t x)= w v}
   *)
    
   (**{v predicate ||t|| : s -> t -> bool v}*)
   (**  {v assertion support_def_t : 
          forall x:s, y:t,  y : ||t x|| <-> y =(t x)= y v}
   *)
    
   val a : s * t
   (**  {v assertion a_support :  pi0 a : ||s|| /\ pi1 a : ||t (pi0 a)|| v}
   *)
    
   val b : s * t
   (**  {v assertion b_support :  pi0 b : ||s|| /\ pi1 b : ||t (pi0 b)|| v}
   *)
    
   
   (**  {v assertion eq :  pi0 a =s= pi0 b /\ pi1 a =(t (pi0 a))= pi1 b v}
   *)
 end

