[Processing ./misc.thy]
module type T =
 sig
   type s
   (**  Assertion per_s [Definitional] = 
          (forall x:s, y:s,  x =s= y -> y =s= x) /\ 
          (forall x:s, y:s, z:s,  x =s= y /\ y =s= z -> x =s= z)
   *)
    
   type t
   (**  Assertion per_t [Definitional] = 
          forall x:s,  x : ||s|| ->
            (forall y:t, z:t,  y =(t x)= z -> z =(t x)= y) /\ 
            (forall y:t, z:t, w:t,  y =(t x)= z /\ z =(t x)= w -> y =(t x)= w)
   *)
    
   type www = t
   (**  Assertion www_def_total = 
          forall (x:||s||),  forall y:www,  y : ||www x|| <-> y : ||t x||
         
        Assertion www_def_per = 
          forall (x:||s||), 
            forall y:www, z:www,  y =(www x)= z <-> y =(t x)= z
   *)
    
   type u
   (**  Assertion per_u [Definitional] = 
          forall x:s,  x : ||s|| ->
            forall y:s,  y : ||s|| ->
              (forall z:u, w:u,  z =(u x y)= w -> w =(u x y)= z) /\ 
              (forall z:u, w:u, x':u,  z =(u x y)= w /\ w =(u x y)= x' ->
                 z =(u x y)= x')
   *)
    
   type wwww = u
   (**  Assertion wwww_def_total = 
          forall (x:||s||, y:||s||), 
            forall z:wwww,  z : ||wwww x y|| <-> z : ||u x y||
         
        Assertion wwww_def_per = 
          forall (x:||s||, y:||s||), 
            forall z:wwww, w:wwww,  z =(wwww x y)= w <-> z =(u x y)= w
   *)
    
   val a : s -> s
   (**  Assertion a_total =  forall x:s, y:s,  x =s= y -> a x =s= a y
   *)
    
   val b : s -> s
   (**  Assertion b_total =  forall x:s, y:s,  x =s= y -> b x =s= b y
   *)
    
   val c : s
   (**  Assertion c_total =  c : ||s||
   *)
    
   val d : s
   (**  Assertion d_total =  d : ||s||
   *)
    
   val m : s -> s * [`or0 | `or1]
   (**  Assertion m = 
          forall (x:||s||), 
            let (p,q) = m x in p : ||s|| /\ (q = `or0 cor q = `or1)
   *)
    
   val n : s
   (**  Assertion n_def =  n : ||s|| /\ 
          n =s= (assure y:s. (y : ||s|| /\ (forall (y':||s||),  y =s= y'))
                   in y)
   *)
    
   type uu = t
   (**  Assertion uu_def_total =  forall x:uu,  x : ||uu|| <-> x : ||t n||
         
        Assertion uu_def_per =  forall x:uu, y:uu,  x =uu= y <-> x =(t n)= y
   *)
    
   type q = s -> s
   (**  Assertion q_def_total = 
          forall f:q,  f : ||q|| <->
            (forall x:s, y:s,  x =s= y -> f x =s= f y)
         
        Assertion q_def_per = 
          forall f:q, g:q,  f =q= g <->
            (forall x:s, y:s,  x =s= y -> f x =s= g y)
   *)
    
   val dd : q
   (**  Assertion dd_def =  dd =q= a
   *)
    
   val yy : s * t * s
   (**  Assertion yy_total =  pi0 yy : ||s|| /\ pi1 yy : ||t (pi0 yy)|| /\ 
          pi2 yy : ||s||
   *)
    
   val zz : s -> t -> s
   (**  Assertion zz_total = 
          forall x:s, y:s,  x =s= y ->
            forall z:t, w:t,  z =(t x)= w -> zz x z =s= zz y w
   *)
    
   val ww : s -> s -> u
   (**  Assertion ww_total = 
          forall x:s, y:s,  x =s= y ->
            forall z:s, w:s,  z =s= w -> ww x z =(u x z)= ww y w
   *)
    
   val yy0 : s
   (**  Assertion yy0_def =  yy0 =s= pi0 yy
   *)
    
   val yy1 : t
   (**  Assertion yy1_def =  yy1 =(t (pi0 yy))= pi1 yy
   *)
    
   val yy2 : s
   (**  Assertion yy2_def =  yy2 =s= pi2 yy
   *)
    
   val wwcd : u
   (**  Assertion wwcd_def =  wwcd =(u c d)= ww c d
   *)
 end
 
module type U =
 sig
   type s
   (**  Assertion per_s [Definitional] = 
          (forall x:s, y:s,  x =s= y -> y =s= x) /\ 
          (forall x:s, y:s, z:s,  x =s= y /\ y =s= z -> x =s= z)
   *)
    
   type t = s
   (**  Assertion t_def_total =  forall x:t,  x : ||t|| <-> x : ||s||
         
        Assertion t_def_per =  forall x:t, y:t,  x =t= y <-> x =s= y
   *)
    
   val n : s * s
   (**  Assertion n_total =  pi0 n : ||s|| /\ pi1 n : ||s||
   *)
 end
 
module type Iteration =
 sig
   type a
   (**  Assertion per_a [Definitional] = 
          (forall x:a, y:a,  x =a= y -> y =a= x) /\ 
          (forall x:a, y:a, z:a,  x =a= y /\ y =a= z -> x =a= z)
   *)
    
   val x : a
   (**  Assertion x_total =  x : ||a||
   *)
    
   val s : a -> a
   (**  Assertion s_total =  forall y:a, z:a,  y =a= z -> s y =a= s z
   *)
 end
 
module type DenseLinearOrder =
 sig
   type s
   (**  Assertion per_s [Definitional] = 
          (forall x:s, y:s,  x =s= y -> y =s= x) /\ 
          (forall x:s, y:s, z:s,  x =s= y /\ y =s= z -> x =s= z)
   *)
    
   type ty_less
   (**  Assertion predicate_(<) = 
          (forall x:s, y:s, a:ty_less,  a |= (<) x y -> x : ||s|| /\ 
             y : ||s||) /\ 
          (forall (x:||s||, y:||s||, z:||s||, w:||s||), 
             forall a:ty_less,  x =s= z /\ y =s= w -> a |= (<) x y ->
               a |= (<) z w)
   *)
    
   
   (**  Assertion irreflexive = 
          forall (x:||s||),  forall y:ty_less,  not (y |= (<) x x)
   *)
    
   val transitive : s -> s -> s -> ty_less * ty_less -> ty_less
   (**  Assertion transitive = 
          forall (x:||s||, y:||s||, z:||s||), 
            forall p:ty_less * ty_less,  pi0 p |= (<) x y /\ 
              pi1 p |= (<) y z -> transitive x y z p |= (<) x z
   *)
    
   
   (**  Assertion assymetric = 
          forall (x:||s||, y:||s||), 
            forall p:ty_less * ty_less, 
              not (pi0 p |= (<) x y /\ pi1 p |= (<) y x)
   *)
    
   val linear : s -> s -> s -> ty_less -> [`or0 of ty_less | `or1 of ty_less]
   (**  Assertion linear = 
          forall (x:||s||, y:||s||, z:||s||), 
            forall w:ty_less,  w |= (<) x y ->
              let i = linear x y z w
              in (exists t:ty_less,  i = `or0 t /\ t |= (<) x z) cor 
              (exists t:ty_less,  i = `or1 t /\ t |= (<) z y)
   *)
    
   val dense : s -> s -> ty_less -> s * (ty_less * ty_less)
   (**  Assertion dense = 
          forall (x:||s||, y:||s||), 
            forall z:ty_less,  z |= (<) x y ->
              let (p,q) = dense x y z in p : ||s|| /\ pi0 q |= (<) x p /\ 
              pi1 q |= (<) p y
   *)
 end
 
module type Sums =
 sig
   type s
   (**  Assertion per_s [Definitional] = 
          (forall x:s, y:s,  x =s= y -> y =s= x) /\ 
          (forall x:s, y:s, z:s,  x =s= y /\ y =s= z -> x =s= z)
   *)
    
   val a : s
   (**  Assertion a_total =  a : ||s||
   *)
    
   val b : s
   (**  Assertion b_total =  b : ||s||
   *)
    
   val c : s
   (**  Assertion c_total =  c : ||s||
   *)
    
   type sum = [`yes of s | `no of unit | `maybe]
   (**  Assertion sum_def_total = 
          forall i:sum,  i : ||sum|| <->
            (exists j:s,  i = `yes j /\ j : ||s||) cor i = `no () cor 
            i = `maybe
         
        Assertion sum_def_per = 
          forall i:sum, j:sum,  i =sum= j <->
            (exists k:s, m:s,  i = `yes k /\ j = `yes m /\ k =s= m) cor 
            i = `no () /\ j = `no () cor i = `maybe /\ j = `maybe
   *)
    
   val tmp1 : [`yes of s]
   (**  Assertion tmp1_def =  (exists i:s,  tmp1 = `yes i /\ i =s= a)
   *)
    
   val tmp2 : sum
   (**  Assertion tmp2_def =  tmp2 =sum= tmp1
   *)
    
   val d : s * unit
   (**  Assertion d_def = 
          pi0 d =s= pi0 (match tmp2 with
                           `yes(q:s) -> (q,()) 
                         | `no(r:unit) -> (c,r) 
                         | `maybe -> (a,()) 
                         ])
        *)
    
   val e : s
   (**  Assertion e_def =  e =s= pi0 d
   *)
   end
 
module type TestSubset =
 sig
   type s
   (**  Assertion per_s [Definitional] = 
          (forall x:s, y:s,  x =s= y -> y =s= x) /\ 
          (forall x:s, y:s, z:s,  x =s= y /\ y =s= z -> x =s= z)
   *)
    
   type p
   (**  Assertion predicate_p = 
          (forall x:s, a:p,  a |= p x -> x : ||s||) /\ 
          (forall (x:||s||, y:||s||), 
             forall a:p,  x =s= y -> a |= p x -> a |= p y)
   *)
    
   type q
   (**  Assertion predicate_q = 
          (forall t:s * p, a:q,  a |= q t -> pi0 t : ||s|| /\ 
             pi1 t |= p (pi0 t)) /\ 
          (forall t:s * p,  pi0 t : ||s|| /\ pi1 t |= p (pi0 t) ->
             forall u:s * p,  pi0 u : ||s|| /\ pi1 u |= p (pi0 u) ->
               forall a:q,  pi0 t =s= pi0 u -> a |= q t -> a |= q u)
   *)
    
   type r
   (**  Assertion predicate_r = 
          (forall x:s, y:s, a:r,  a |= r x y -> x : ||s|| /\ y : ||s||) /\ 
          (forall (x:||s||, y:||s||, z:||s||, w:||s||), 
             forall a:r,  x =s= z /\ y =s= w -> a |= r x y -> a |= r z w)
   *)
    
   type t = s * r
   (**  Assertion t_def_total = 
          forall u:t,  u : ||t|| <-> pi0 u : ||s|| /\ 
            pi1 u |= r (pi0 u) (pi0 u)
         
        Assertion t_def_per = 
          forall u:t, p':t,  u =t= p' <-> pi1 u |= r (pi0 u) (pi0 u) /\ 
            pi1 p' |= r (pi0 p') (pi0 p') /\ pi0 u =s= pi0 p'
   *)
    
   val c : t
   (**  Assertion c_total =  c : ||t||
   *)
    
   val warning : q
   (**  Assertion warning = 
          warning |= q (pi0 c,(assure a:p. (a |= p (pi0 c)) in a))
   *)
    
   val foo : s -> p -> q
   (**  Assertion foo = 
          forall (x:||s||), 
            forall y:p,  y |= p x ->
              foo x y |= q (x,(assure a:p. (a |= p x) in a))
   *)
    
   val bar : s -> p -> q
   (**  Assertion bar = 
          forall (x:||s||), 
            forall y:p,  y |= p x ->
              bar x y |= q (x,(assure a:p. (a |= p x) in a))
   *)
    
   val baz : t -> r
   (**  Assertion baz =  forall (x:||t||),  baz x |= r (pi0 x) (pi0 x)
   *)
 end
 
module type Choice =
 sig
   type a
   (**  Assertion per_a [Definitional] = 
          (forall x:a, y:a,  x =a= y -> y =a= x) /\ 
          (forall x:a, y:a, z:a,  x =a= y /\ y =a= z -> x =a= z)
   *)
    
   type b
   (**  Assertion per_b [Definitional] = 
          (forall x:b, y:b,  x =b= y -> y =b= x) /\ 
          (forall x:b, y:b, z:b,  x =b= y /\ y =b= z -> x =b= z)
   *)
    
   type r
   (**  Assertion predicate_r = 
          (forall x:a, y:b, c:r,  c |= r x y -> x : ||a|| /\ y : ||b||) /\ 
          (forall (x:||a||, y:||b||, z:||a||, w:||b||), 
             forall c:r,  x =a= z /\ y =b= w -> c |= r x y -> c |= r z w)
   *)
    
   val choice : (a -> b * r) -> (a -> b) * (a -> r)
   (**  Assertion choice = 
          forall f:a -> b * r, 
            (forall (x:||a||),  let (p,q) = f x in p : ||b|| /\ q |= r x p) ->
            let (g,h) = choice f
            in (forall x:a, y:a,  x =a= y -> g x =b= g y) /\ 
            (forall (x:||a||),  h x |= r x (g x))
   *)
    
   val intensionalChoice : (a -> b * r) -> (a -> b) * (a -> r)
   (**  Assertion intensionalChoice = 
          forall f:a -> b * r, 
            (forall (x:||a||),  let (p,q) = f x in p : ||b|| /\ q |= r x p) ->
            let (g,h) = intensionalChoice f
            in (forall x:a, y:a,  y : ||a|| -> g x =b= g y) /\ 
            (forall (x':||a||),  h x' |= r x' (g x'))
   *)
 end
 
module type Quotients =
 sig
   type s
   (**  Assertion per_s [Definitional] = 
          (forall x:s, y:s,  x =s= y -> y =s= x) /\ 
          (forall x:s, y:s, z:s,  x =s= y /\ y =s= z -> x =s= z)
   *)
    
   
   (**  Assertion predicate_(<<) = 
          (forall x:s, y:s,  (<<) x y -> x : ||s|| /\ y : ||s||) /\ 
          (forall (x:||s||, y:||s||, z:||s||, w:||s||),  x =s= z /\ 
             y =s= w -> (<<) x y -> (<<) z w)
   *)
    
   
   (**  Assertion predicate_r = 
          (forall x:s, y:s,  r x y -> x : ||s|| /\ y : ||s||) /\ 
          (forall (x:||s||, y:||s||, z:||s||, w:||s||),  x =s= z /\ 
             y =s= w -> r x y -> r z w)
   *)
    
   
   (**  Assertion equiv_r =  (forall (x:||s||),  r x x) /\ 
          (forall (x:||s||, y:||s||),  r x y -> r y x) /\ 
          (forall (x:||s||, y:||s||, z:||s||),  r x y /\ r y z -> r x z)
   *)
    
   
   (**  Assertion reflexive =  forall (x:||s||),  (<<) x x
   *)
    
   
   (**  Assertion transitive = 
          forall (x:||s||, y:||s||, z:||s||),  (<<) x y /\ (<<) y z ->
            (<<) x z
   *)
    
   type eq = top
   (**  Assertion eq_def = 
          forall (x:||s||, y:||s||),  eq x y <->
            (assure (forall (z:||s||),  (<<) z z) /\ 
                 (forall (z:||s||, w:||s||, t:||s||),  (<<) z w /\ 
                    (<<) w z /\ (<<) w t /\ (<<) t w -> (<<) z t /\ (<<) t z)
               in (<<) x y /\ (<<) y x)
   *)
    
   type s2 = s
   (**  Assertion s2_def_total =  forall x:s2,  x : ||s2|| <-> x : ||s||
         
        Assertion s2_def_per =  forall x:s2, y:s2,  x =s2= y <-> eq x y
   *)
    
   val surj : s -> s
   (**  Assertion surj = 
          forall (e:||s||),  let p = surj e in p : ||s|| /\ r e p
   *)
    
   
   (**  Assertion bar = 
          forall f:s -> s,  (forall x:s, y:s,  x =s= y -> f x =s= f y) ->
            forall (a:||s||, e:||s||), 
              r a (assure (forall x:s,  r e x -> f e =s= f x) in f e)
   *)
 end

