[Processing hoist.thy]
module type HoistTerms = 
sig
  type s
  (**  Assertion per_s =  PER(=s=)
  *)
   
  val a : s
  (**  Assertion a_total =  a : ||s||
  *)
   
  val b : s
  (**  Assertion b_total =  b : ||s||
  *)
   
  val c : s
  (**  Assertion c_total =  c : ||s||
  *)
   
  type p
  (**  Assertion predicate_p =  PREDICATE(p, p)
  *)
   
  val f : s -> s
  (**  Assertion f_total =  forall x:s, y:s,  x =s= y -> f x =s= f y
  *)
   
  val emptyTuple : unit
  (**  Assertion emptyTuple_def =  true
  *)
   
  val var : s
  (**  Assertion var_def =  var =s= a
  *)
   
  val tuple : (s * p) * s * (s * p)
  (**  Assertion tuple_def =  pi1 (pi0 tuple) |= p (pi0 (pi0 tuple)) /\ 
         pi0 (pi0 tuple) =s= (assure x:s, y:p.
                                  (x : ||s|| /\ y |= p x /\ 
                                   (forall (x':||s||), 
                                      forall z:p,  z |= p x' -> x =s= x'))
                                in x) /\ pi1 tuple =s= b /\ 
         pi1 (pi2 tuple) |= p f (pi0 (pi2 tuple)) /\ 
         pi0 (pi2 tuple) =s= (assure x:s, y:p.
                                  (x : ||s|| /\ y |= p f x /\ 
                                   (forall (x':||s||), 
                                      forall z:p,  z |= p f x' -> x =s= x'))
                                in x)
  *)
   
  val proj : s
  (**  Assertion proj_def =  proj =s= b
  *)
   
  val g : (s -> s) -> s
  (**  Assertion g_def = 
         forall x:s -> s, y:s -> s, 
           (forall x':s, y':s,  x' =s= y' -> x x' =s= y y') ->
           g x =s= y
                     (assure x':s, y':p.
                          (x' : ||s|| /\ y' |= p x' /\ 
                           (forall (x'':||s||), 
                              forall z:p,  z |= p x'' -> x' =s= x'')) in x')
  *)
   
  val application : s
  (**  Assertion application_def = 
         application =s= (assure h:(s -> s) -> s.
                              ((forall x:s -> s, y:s -> s, 
                                  (forall x':s, y':s,  x' =s= y' ->
                                     x x' =s= y y') -> h x =s= h y) /\ 
                               (forall x:s -> s, y:s -> s, 
                                  (forall x':s, y':s,  x' =s= y' ->
                                     x x' =s= y y') -> g x =s= h y) /\ 
                               (forall h':(s -> s) -> s, 
                                  (forall x:s -> s, y:s -> s, 
                                     (forall x':s, y':s,  x' =s= y' ->
                                        x x' =s= y y') -> h' x =s= h' y) ->
                                  (forall x:s -> s, y:s -> s, 
                                     (forall x':s, y':s,  x' =s= y' ->
                                        x x' =s= y y') -> g x =s= h' y) ->
                                  forall x:s -> s, y:s -> s, 
                                    (forall x':s, y':s,  x' =s= y' ->
                                       x x' =s= y y') -> h x =s= h' y))
                            in h
                                 (fun x : s =>
                                  assure y:s, x':p.
                                      (y : ||s|| /\ x' |= p y /\ 
                                       (forall (y':||s||), 
                                          forall z:p,  z |= p y' -> y =s= y'))
                                    in y))
  *)
   
  val description : s * p
  (**  Assertion description_def = 
         let x' = assure x:s, y:p.
                      (x : ||s|| /\ 
                       y |= p (assure y':s.
                                   (y' : ||s|| /\ y' =s= x /\ 
                                    (forall (y'':||s||),  y'' =s= x ->
                                       y' =s= y'')) in y') /\ 
                       (forall (x':||s||), 
                          forall z:p, 
                            z |= p (assure y':s.
                                        (y' : ||s|| /\ y' =s= x' /\ 
                                         (forall (y'':||s||),  y'' =s= x' ->
                                            y' =s= y'')) in y') -> x =s= x'))
                    in (x,y)
         in pi1 description |= p (assure y:s.
                                      (y : ||s|| /\ y =s= pi0 description /\ 
                                       (forall (y':||s||), 
                                          y' =s= pi0 description -> y =s= y'))
                                    in y) /\ 
         pi1 x' |= p (assure y:s.
                          (y : ||s|| /\ y =s= pi0 x' /\ 
                           (forall (y':||s||),  y' =s= pi0 x' -> y =s= y'))
                        in y) /\ 
         pi0 description =s= pi0 x'
  *)
   
  val cases : s
  (**  Assertion cases_def = 
         let x' = assure ((forall (___3:||s||),  b =s= c))
                    in assure x':s.
                           (x' : ||s|| /\ x' =s= b /\ 
                            (forall (x'':||s||),  x'' =s= b -> x' =s= x''))
                         in x'
         in cases =s= b /\ x' =s= b /\ cases =s= x'
  *)
   
  val r : s
  (**  Assertion r_total =  r : ||s||
  *)
   
  val rzquot : s
  (**  Assertion rzquot_def =  rzquot =s= r
  *)
   
  val rzchoose : s
  (**  Assertion rzchoose_def = 
         rzchoose =s= (assure x:s.
                           (x : ||s|| /\ a =s= x /\ 
                            (forall (x':||s||),  a =s= x' -> x =s= x')) in x)
  *)
   
  
  (**  Assertion predicate_eq =  PREDICATE(eq)
  *)
   
  val quot : s
  (**  Assertion quot_def = 
         eq quot (assure x:s.
                      (x : ||s|| /\ x =s= a /\ 
                       (forall (x':||s||),  x' =s= a -> x =s= x')) in x)
  *)
   
  val choose_term : s
  (**  Assertion choose_term_def = 
         let x = assure w:s.
                     (w : ||s|| /\ eq w quot /\ 
                      (forall (w':||s||),  eq w' quot -> eq w w')) in w
         in eq choose_term (assure (forall x':s,  eq x x' ->
                                      eq (assure y':s.
                                              (y' : ||s|| /\ x =s= y' /\ 
                                               (forall (y'':||s||), 
                                                  x =s= y'' -> y' =s= y''))
                                            in y') (assure y:s.
                                                        (y : ||s|| /\ 
                                                         x' =s= y /\ 
                                                         (forall (y':||s||), 
                                                            x' =s= y' ->
                                                            y =s= y')) in y))
                              in assure y:s.
                                     (y : ||s|| /\ x =s= y /\ 
                                      (forall (y':||s||),  x =s= y' ->
                                         y =s= y')) in y)
  *)
   
  val let_term : s * s
  (**  Assertion let_term_def = 
         let x = assure x:s.
                     (x : ||s|| /\ x =s= a /\ 
                      (forall (x':||s||),  x' =s= a -> x =s= x')) in x
         in pi0 let_term =s= x /\ 
         pi1 let_term =s= (assure y:s.
                               (y : ||s|| /\ x =s= y /\ 
                                (forall (y':||s||),  x =s= y' -> y =s= y'))
                             in y)
  *)
   
  val subin : s * p
  (**  Assertion subin_def =  pi1 subin |= p (pi0 subin) /\ 
         (assure x:p. (x |= p a) in x) |= p a /\ pi0 subin =s= a
  *)
   
  (** fishy *)
   
  val d : s * p
  (**  Assertion d_total =  pi0 d : ||s|| /\ pi1 d |= p (pi0 d)
  *)
   
  val subout : s
  (**  Assertion subout_def =  subout =s= pi0 d
  *)
end


-------------------------------
WARNING:
Shadowing of x detected.
-------------------------------


-------------------------------
WARNING:
Shadowing of f detected.
-------------------------------

