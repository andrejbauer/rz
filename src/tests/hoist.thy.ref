[Processing hoist.thy]
module type HoistTerms =
 sig
   type s
   (**  Assertion per_s = 
          (forall x:s, y:s, z:s,  y =s= z /\ x =s= y -> x =s= z)
   *)
    
   val a : s
   (**  Assertion a_total =  a : ||s||
   *)
    
   val b : s
   (**  Assertion b_total =  b : ||s||
   *)
    
   val c : s
   (**  Assertion c_total =  c : ||s||
   *)
    
   type p
   (**  Assertion predicate_p = 
          (forall (x:||s||, y:||s||), 
             forall d:p,  x =s= y -> d |= p x -> d |= p y) /\ 
          (forall x:s, d:p,  d |= p x -> x : ||s||)
   *)
    
   val f : s -> s
   (**  Assertion f_total =  forall x:s, y:s,  x =s= y -> f x =s= f y
   *)
    
   val emptyTuple : unit
   (**  Assertion emptyTuple_def =  true
   *)
    
   val var : s
   (**  Assertion var_def =  var =s= a
   *)
    
   val tuple : (p * s) * s * (p * s)
   (**  Assertion tuple_def = 
          let q = assure x:s, d:p.
                      ((forall (x':||s||), 
                          forall a':p,  a' |= p x' -> x =s= x') /\ 
                       d |= p x /\ x : ||s||) in (d,x)
          in let t = assure x:s, d:p.
                         ((forall (x':||s||), 
                             forall a':p,  a' |= p (f x') -> x =s= x') /\ 
                          d |= p (f x) /\ x : ||s||) in (d,x)
             in pi0 (pi2 tuple) =s= pi0 t /\ pi1 t |= p (f (pi0 t)) /\ 
             pi1 (pi2 tuple) |= p (f (pi0 (pi2 tuple))) /\ 
             pi1 tuple =s= b /\ pi0 (pi0 tuple) =s= pi0 q /\ 
             pi1 q |= p (pi0 q) /\ pi1 (pi0 tuple) |= p (pi0 (pi0 tuple))
   *)
    
   val proj : s
   (**  Assertion proj_def =  proj =s= b
   *)
    
   val g : (s -> s) -> s
   (**  Assertion g_def = 
          forall h:s -> s, r:s -> s, 
            (forall x:s, y:s,  x =s= y -> h x =s= r y) ->
            g h =s= r
                      (assure x:s, d:p.
                           ((forall (x':||s||), 
                               forall a':p,  a' |= p x' -> x =s= x') /\ 
                            d |= p x /\ x : ||s||) in x)
   *)
    
   val application : s
   (**  Assertion application_def = 
          application =s= (assure h:(s -> s) -> s.
                               ((forall h':(s -> s) -> s, 
                                   (forall r:s -> s, f':s -> s, 
                                      (forall x:s, y:s,  x =s= y ->
                                         r x =s= f' y) -> h' r =s= h' f') ->
                                   (forall r:s -> s, f':s -> s, 
                                      (forall x:s, y:s,  x =s= y ->
                                         r x =s= f' y) -> g r =s= h' f') ->
                                   forall r:s -> s, f':s -> s, 
                                     (forall x:s, y:s,  x =s= y ->
                                        r x =s= f' y) -> h r =s= h' f') /\ 
                                (forall r:s -> s, f':s -> s, 
                                   (forall x:s, y:s,  x =s= y -> r x =s= f' y) ->
                                   g r =s= h f') /\ 
                                (forall r:s -> s, f':s -> s, 
                                   (forall x:s, y:s,  x =s= y -> r x =s= f' y) ->
                                   h r =s= h f'))
                             in h
                                  (fun x : s =>
                                   assure y:s, d:p.
                                       ((forall (y':||s||), 
                                           forall a':p,  a' |= p y' ->
                                             y =s= y') /\ d |= p y /\ 
                                        y : ||s||) in y))
   *)
    
   val description : p * s
   (**  Assertion description_def = 
          let x = assure x:s, d:p.
                      ((forall (x':||s||), 
                          forall a':p, 
                            a' |= p (assure y:s.
                                         ((forall (y':||s||),  y' =s= x' ->
                                             y =s= y') /\ y =s= x' /\ 
                                          y : ||s||) in y) -> x =s= x') /\ 
                       d |= p (assure y:s.
                                   ((forall (y':||s||),  y' =s= x -> y =s= y') /\ 
                                    y =s= x /\ y : ||s||) in y) /\ x : ||s||)
                    in (d,x)
          in pi0 description =s= pi0 x /\ 
          pi1 x |= p (assure y:s.
                          ((forall (y':||s||),  y' =s= pi0 x -> y =s= y') /\ 
                           y =s= pi0 x /\ y : ||s||) in y) /\ 
          pi1 description |= p (assure y:s.
                                    ((forall (y':||s||), 
                                        y' =s= pi0 description -> y =s= y') /\ 
                                     y =s= pi0 description /\ y : ||s||) in y)
   *)
    
   val cases : s
   (**  Assertion cases_def = 
          let x = assure ((forall (Z__1:||s||),  b =s= c))
                    in assure x:s.
                           ((forall (x':||s||),  x' =s= b -> x =s= x') /\ 
                            x =s= b /\ x : ||s||) in x
          in cases =s= x /\ x =s= b /\ cases =s= b
   *)
    
   val r : s
   (**  Assertion r_total =  r : ||s||
   *)
    
   val rzquot : s
   (**  Assertion rzquot_def =  rzquot =s= (assure q:s. (q : ||s||) in q)
   *)
    
   val rzchoose : s
   (**  Assertion rzchoose_def = 
          rzchoose =s= (assure (forall x:s, 
                                  (assure q:s. (q : ||s||) in q) =s= 
                                  (assure q:s. (q : ||s||) in q))
                          in assure q:s. (q : ||s||) in q)
   *)
    
   type eq = top
   (**  Assertion predicate_eq = 
          (forall (x:||s||, y:||s||, z:||s||, w:||s||),  y =s= w /\ 
             x =s= z -> eq y x -> eq w z) /\ 
          (forall x:s, y:s,  eq y x -> y : ||s|| /\ x : ||s||)
   *)
    
   
   (**  Assertion equiv_eq = 
          (forall (x:||s||, y:||s||, z:||s||),  eq z y /\ eq y x -> eq z x) /\ 
          (forall (x:||s||, y:||s||),  eq y x -> eq x y) /\ 
          (forall (x:||s||),  eq x x)
   *)
    
   val quot : s
   (**  Assertion quot_def = 
          eq (assure x:s.
                  ((forall (x':||s||),  x' =s= a -> x =s= x') /\ x =s= a /\ 
                   x : ||s||) in x) quot
   *)
    
   val choose_term : s
   (**  Assertion choose_term_def = 
          let x = assure w:s.
                      ((forall (w':||s||),  eq quot w' -> eq w' w) /\ 
                       eq quot w /\ w : ||s||) in w
          in eq (assure (forall x':s,  eq x' x ->
                           eq (assure y:s.
                                   ((forall (y':||s||),  x' =s= y' ->
                                       y =s= y') /\ x' =s= y /\ y : ||s||)
                                 in y) (assure y:s.
                                            ((forall (y':||s||),  x =s= y' ->
                                                y =s= y') /\ x =s= y /\ 
                                             y : ||s||) in y))
                   in assure y:s.
                          ((forall (y':||s||),  x =s= y' -> y =s= y') /\ 
                           x =s= y /\ y : ||s||) in y) choose_term
   *)
    
   val let_term : s * s
   (**  Assertion let_term_def = 
          let x = assure x:s.
                      ((forall (x':||s||),  x' =s= a -> x =s= x') /\ 
                       x =s= a /\ x : ||s||) in x
          in pi1 let_term =s= (assure y:s.
                                   ((forall (y':||s||),  x =s= y' -> y =s= y') /\ 
                                    x =s= y /\ y : ||s||) in y) /\ 
          pi0 let_term =s= x
   *)
    
   val subin : p * s
   (**  Assertion subin_def =  pi0 subin =s= a /\ 
          (assure d:p. (d |= p a) in d) |= p a /\ pi1 subin |= p (pi0 subin)
   *)
    
   (** fishy *)
    
   val d : p * s
   (**  Assertion d_total =  pi1 d |= p (pi0 d) /\ pi0 d : ||s||
   *)
    
   val subout : s
   (**  Assertion subout_def =  subout =s= pi0 d
   *)
 end

