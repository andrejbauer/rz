[Processing ./terms.thy]
module type Terms =
 sig
   type s
   (**  Assertion per_s [Definitional] = 
          (forall x:s, y:s,  x =s= y -> y =s= x) /\ 
          (forall x:s, y:s, z:s,  x =s= y /\ y =s= z -> x =s= z)
   *)
    
   val a : s
   (**  Assertion a_total =  a : ||s||
   *)
    
   val b : s
   (**  Assertion b_total =  b : ||s||
   *)
    
   val c : s
   (**  Assertion c_total =  c : ||s||
   *)
    
   type p
   (**  Assertion predicate_p = 
          (forall x:s, d:p,  d |= p x -> x : ||s||) /\ 
          (forall (x:||s||, y:||s||), 
             forall d:p,  x =s= y -> d |= p x -> d |= p y)
   *)
    
   val emptyTuple : unit
   (**  Assertion emptyTuple_def =  true
   *)
    
   val var : s
   (**  Assertion var_def =  var =s= a
   *)
    
   val tuple : s * s * s
   (**  Assertion tuple_def =  pi0 tuple =s= a /\ pi1 tuple =s= b /\ 
          pi2 tuple =s= c
   *)
    
   val proj : s
   (**  Assertion proj_def =  proj =s= b
   *)
    
   val g : (s -> s) -> s -> s
   (**  Assertion g_def = 
          forall f:s -> s, h:s -> s, 
            (forall x:s, y:s,  x =s= y -> f x =s= h y) ->
            forall x:s, y:s,  x =s= y -> g f x =s= h y
   *)
    
   val application : s -> s
   (**  Assertion application_def = 
          forall x:s, y:s,  x =s= y ->
            application x =s= g (fun x' : s => a) y
   *)
    
   val description : s * p
   (**  Assertion description_def = 
          let x = assure x:s, d:p.
                      (x : ||s|| /\ d |= p x /\ 
                       (forall (x':||s||), 
                          forall a':p,  a' |= p x' -> x =s= x')) in (x,d)
          in pi1 description |= p (pi0 description) /\ pi1 x |= p (pi0 x) /\ 
          pi0 description =s= pi0 x
   *)
    
   val cases : s
   (**  Assertion cases_def =  cases =s= b
   *)
    
   val r : s
   (**  Assertion r_total =  r : ||s||
   *)
    
   val rzquot : s
   (**  Assertion rzquot_def =  rzquot =s= r
   *)
    
   val rzchoose : s
   (**  Assertion rzchoose_def = 
          rzchoose =s= (assure (forall x:s,  x : ||s|| -> a =s= x) in a)
   *)
    
   
   (**  Assertion predicate_eq = 
          (forall x:s, y:s,  eq x y -> x : ||s|| /\ y : ||s||) /\ 
          (forall (x:||s||, y:||s||, z:||s||, w:||s||),  x =s= z /\ 
             y =s= w -> eq x y -> eq z w)
   *)
    
   
   (**  Assertion equiv_eq =  (forall (x:||s||),  eq x x) /\ 
          (forall (x:||s||, y:||s||),  eq x y -> eq y x) /\ 
          (forall (x:||s||, y:||s||, z:||s||),  eq x y /\ eq y z -> eq x z)
   *)
    
   val quot : s
   (**  Assertion quot_def =  eq quot a
   *)
    
   val choose_term : s
   (**  Assertion choose_term_def =  eq choose_term quot
   *)
    
   val let_term : s * s
   (**  Assertion let_term_def =  pi0 let_term =s= a /\ pi1 let_term =s= a
   *)
    
   val subin : s * p
   (**  Assertion subin_def =  pi1 subin |= p (pi0 subin) /\ 
          (assure d:p. (d |= p a) in d) |= p a /\ pi0 subin =s= a
   *)
    
   (** fishy *)
    
   val d : s * p
   (**  Assertion d_total =  pi0 d : ||s|| /\ pi1 d |= p (pi0 d)
   *)
    
   val subout : s
   (**  Assertion subout_def =  subout =s= pi0 d
   *)
 end

