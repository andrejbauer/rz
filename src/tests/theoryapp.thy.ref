[Processing theoryapp.thy]
module type A = 
sig
  type a
  (**  Assertion per_a =  PER(=a=)
  *)
   
  val n : a
  (**  Assertion n_total =  n : ||a||
  *)
   
  
  (**  Assertion q =  all (x:||a||).  x =a= x
  *)
end

module type B = 
sig
  type a
  (**  Assertion per_a =  PER(=a=)
  *)
   
  
  (**  Assertion q =  all (x:||a||).  x =a= x
  *)
   
  val n : a
  (**  Assertion n_total =  n : ||a||
  *)
   
  val m : a
  (**  Assertion m_total =  m : ||a||
  *)
end

module type C = 
functor (M : A) ->
 sig
   type b = M.a
   (**  Assertion b_def_total =  all (x:M.a).  x : ||b|| <=> x : ||M.a||
         
        Assertion b_def_per =  all (y:M.a, z:M.a).  y =b= z <=> y =M.a= z
   *)
    
   type c = M.a
   (**  Assertion c_def_total =  all (x:M.a).  x : ||c|| <=> x : ||M.a||
         
        Assertion c_def_per =  all (y:M.a, z:M.a).  y =c= z <=> y =M.a= z
   *)
 end

module X : B

module type D = 
C(X)

