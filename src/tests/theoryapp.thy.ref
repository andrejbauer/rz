[Processing ./theoryapp.thy]
module type A =
 sig
   type a
   (**  Assertion per_a [Definitional] = 
          (forall x:a, y:a,  x =a= y -> y =a= x) /\ 
          (forall x:a, y:a, z:a,  x =a= y /\ y =a= z -> x =a= z)
   *)
    
   val n : a
   (**  Assertion n_total =  n : ||a||
   *)
    
   val m : a
   (**  Assertion m_def =  m =a= n
   *)
    
   
   (**  Assertion q =  true
   *)
 end
 
module type B =
 sig
   type a
   (**  Assertion per_a [Definitional] = 
          (forall x:a, y:a,  x =a= y -> y =a= x) /\ 
          (forall x:a, y:a, z:a,  x =a= y /\ y =a= z -> x =a= z)
   *)
    
   val n : a
   (**  Assertion n_total =  n : ||a||
   *)
    
   val p : a
   (**  Assertion p_total =  p : ||a||
   *)
    
   
   (**  Assertion q =  true
   *)
    
   val m : a
   (**  Assertion m_def =  m =a= n
   *)
 end
 
module type C =
 functor (M : A) ->
 sig
   type b = M.a
   (**  Assertion b_def_total =  forall x:b,  x : ||b|| <-> x : ||M.a||
         
        Assertion b_def_per =  forall x:b, y:b,  x =b= y <-> x =M.a= y
   *)
    
   type c = M.a
   (**  Assertion c_def_total =  forall x:c,  x : ||c|| <-> x : ||M.a||
         
        Assertion c_def_per =  forall x:c, y:c,  x =c= y <-> x =M.a= y
   *)
 end
 
module X : B
 
module type D = C(X)

