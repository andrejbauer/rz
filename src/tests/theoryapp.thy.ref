[Processing ./theoryapp.thy]
module type A =
 sig
   type a
    
   (** predicate (=a=) : a -> a -> bool *)
   (**  Assertion symmetric_a =  forall x:a, y:a,  x =a= y -> y =a= x
         
        Assertion transitive_a = 
          forall x:a, y:a, z:a,  x =a= y /\ y =a= z -> x =a= z
   *)
    
   val n : a
   (**  Assertion n_support =  n : ||a||
   *)
    
   val m : a
   (**  Assertion m_def =  m =a= n
   *)
 end
 
module type B =
 sig
   type a
    
   (** predicate (=a=) : a -> a -> bool *)
   (**  Assertion symmetric_a =  forall x:a, y:a,  x =a= y -> y =a= x
         
        Assertion transitive_a = 
          forall x:a, y:a, z:a,  x =a= y /\ y =a= z -> x =a= z
   *)
    
   val n : a
   (**  Assertion n_support =  n : ||a||
   *)
    
   val p : a
   (**  Assertion p_support =  p : ||a||
   *)
    
   val m : a
   (**  Assertion m_def =  m =a= n
   *)
 end
 
module type C =
 functor (M : A) ->
 sig
   type b = M.a
    
   (** predicate ||b|| : b -> bool *)
   (**  Assertion b_def_support =  forall x:b,  x : ||b|| <-> x : ||M.a||
   *)
    
   (** predicate (=b=) : b -> b -> bool *)
   (**  Assertion b_def_per =  forall x:b, y:b,  x =b= y <-> x =M.a= y
   *)
    
   type c = M.a
    
   (** predicate ||c|| : c -> bool *)
   (**  Assertion c_def_support =  forall x:c,  x : ||c|| <-> x : ||M.a||
   *)
    
   (** predicate (=c=) : c -> c -> bool *)
   (**  Assertion c_def_per =  forall x:c, y:c,  x =c= y <-> x =M.a= y
   *)
 end
 
module X : B
 
module type D =
 sig
   type b = X.a
    
   (** predicate ||b|| : b -> bool *)
   (**  Assertion b_def_support =  forall x:b,  x : ||b|| <-> x : ||X.a||
   *)
    
   (** predicate (=b=) : b -> b -> bool *)
   (**  Assertion b_def_per =  forall x:b, y:b,  x =b= y <-> x =X.a= y
   *)
    
   type c = X.a
    
   (** predicate ||c|| : c -> bool *)
   (**  Assertion c_def_support =  forall x:c,  x : ||c|| <-> x : ||X.a||
   *)
    
   (** predicate (=c=) : c -> c -> bool *)
   (**  Assertion c_def_per =  forall x:c, y:c,  x =c= y <-> x =X.a= y
   *)
 end

