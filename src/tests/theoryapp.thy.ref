[Processing theoryapp.thy]
module type A = 
sig
  type a
  (**  Assertion per_a =  PER(=a=)
  *)
   
  val n : a
  (**  Assertion n_total =  n : ||a||
  *)
   
  val m : a
  (**  Assertion m_def =  m =a= n
  *)
   
  
  (**  Assertion q =  forall (x:||a||),  x =a= x
  *)
end

module type B = 
sig
  type a
  (**  Assertion per_a =  PER(=a=)
  *)
   
  val n : a
  (**  Assertion n_total =  n : ||a||
  *)
   
  val p : a
  (**  Assertion p_total =  p : ||a||
  *)
   
  
  (**  Assertion q =  forall (x:||a||),  x =a= (let y = x in y)
  *)
   
  val m : a
  (**  Assertion m_def = 
         m =a= (match `yes n with
                  `no -> p 
                | `yes(z : a) -> z 
                ])
       *)
  end

module type C = 
functor (M : A) ->
 sig
   type b = M.a
   (**  Assertion b_def_total =  forall x:M.a,  x : ||b|| <-> x : ||M.a||
         
        Assertion b_def_per =  forall y:M.a, z:M.a,  y =b= z <-> y =M.a= z
   *)
    
   type c = M.a
   (**  Assertion c_def_total =  forall x:M.a,  x : ||c|| <-> x : ||M.a||
         
        Assertion c_def_per =  forall y:M.a, z:M.a,  y =c= z <-> y =M.a= z
   *)
 end

module X : B

module type D = 
C(X)

