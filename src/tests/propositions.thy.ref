[Processing propositions.thy]
Is this a Dagger which I see before me?
module type P = 
sig
  
  (**  Assertion tst_false =  false
  *)
   
  
  (**  Assertion tst_true =  true
  *)
   
  type s
  (**  Assertion per_s =  PER(=s=)
  *)
   
  type p
  (**  Assertion predicate_p =  PREDICATE(p, p)
  *)
   
  
  (**  Assertion predicate_p2 =  PREDICATE(p2)
  *)
   
  
  (**  Assertion predicate_p3 =  PREDICATE(p3)
  *)
   
  type phi
  (**  Assertion predicate_phi =  PREDICATE(phi, phi)
  *)
   
  type psi
  (**  Assertion predicate_psi =  PREDICATE(psi, psi)
  *)
   
  type rho
  (**  Assertion predicate_rho =  PREDICATE(rho, rho)
  *)
   
  val tst_and : phi * (psi * rho)
  (**  Assertion tst_and =  pi0 tst_and |= phi  and 
         pi0 (pi1 tst_and) |= psi  and pi1 (pi1 tst_and) |= rho 
  *)
   
  val tst_imply : phi -> psi
  (**  Assertion tst_imply =  forall x:phi,  x |= phi  -> tst_imply x |= psi 
  *)
   
  val tst_iff : (phi -> psi) * (psi -> phi)
  (**  Assertion tst_iff = 
         (forall x:phi,  x |= phi  -> (pi0 tst_iff) x |= psi ) and 
         (forall y:phi,  y |= psi  -> (pi1 tst_iff) y |= phi )
  *)
   
  val tst_or : [`or0 of phi | `or1 of [`or0 of psi | `or1 of rho]]
  (**  Assertion tst_or = 
         (exists x:phi,  tst_or = `or0 x and x |= phi ) cor 
         (exists x:[`or0 of psi | `or1 of rho],  tst_or = `or1 x and 
            ((exists x':psi,  x = `or0 x' and x' |= psi ) cor 
             (exists x':rho,  x = `or1 x' and x' |= rho )))
  *)
   
  val tst_forall : s -> p
  (**  Assertion tst_forall =  forall (x:||s||),  tst_forall x |= p x
  *)
   
  val tst_exists : s * p
  (**  Assertion tst_exists =  pi0 tst_exists : ||s|| and 
         pi1 tst_exists |= p (pi0 tst_exists)
  *)
   
  val tst_exists1 : s * p
  (**  Assertion tst_exists1 =  pi0 tst_exists1 : ||s|| and 
         pi1 tst_exists1 |= p (pi0 tst_exists1) and 
         (forall u:s * p,  pi0 u : ||s|| and pi1 tst_exists1 |= p (pi0 u) ->
            pi0 tst_exists1 =s= pi0 u)
  *)
   
  
  (**  Assertion tst_not =  forall r:phi,  not (r |= phi )
  *)
   
  val x0 : s
  (**  Assertion x0_total =  x0 : ||s||
  *)
   
  val y0 : s
  (**  Assertion y0_total =  y0 : ||s||
  *)
   
  
  (**  Assertion tst_equal =  x0 =s= y0
  *)
   
  type q = p
  (**  Assertion q_def = 
         forall (z:||s||),  forall r:p,  r |= q z <-> (z =s= x0 -> r |= p z)
  *)
   
  val tst_papp : p
  (**  Assertion tst_papp =  tst_papp |= q y0
  *)
   
  type r1 = top
  (**  Assertion r1_def = 
         forall (x:||s||, y:||s||),  r1 x y <->
           (forall r':p, 
              not (r' |= p x and (forall r'':p,  not (r'' |= p y))))
  *)
   
  type r2 = top
  (**  Assertion r2_def = 
         forall (x:||s||, y:||s||),  r2 x y <->
           (assure EQUIV((pmfun x : s(||s||) => pmfun y : s(||s||) => r1 x y), s) in
              r1 x y)
  *)
   
  val w : [`foo | `bar of (s * s)]
  (**  Assertion w_total =  w = `foo cor 
         (exists w':s * s,  w = `bar w' and pi0 w' : ||s|| and pi1 w' : ||s||)
  *)
   
  val tst_pcase : [`bar of p | `foo of p]
  (**  Assertion tst_pcase = 
         match tst_pcase, w with
           `bar (r' : p), `bar (u : s * s) =>
              pi0 u : ||s|| and pi1 u : ||s|| and r' |= p (pi0 u) 
         | `foo (r' : p), `foo  => r' |= p x0 
         
  *)
end

