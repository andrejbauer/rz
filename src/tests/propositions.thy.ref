[Processing ./propositions.thy]
module type P =
 sig
   
   (**  Assertion tst_false =  false
   *)
    
   
   (**  Assertion tst_true =  true
   *)
    
   type s
   (**  Assertion per_s [Definitional] = 
          (forall x:s, y:s,  x =s= y -> y =s= x) /\ 
          (forall x:s, y:s, z:s,  x =s= y /\ y =s= z -> x =s= z)
   *)
    
   type p
    
   (* proposition p : s->p->prop *)
   (**  Assertion predicate_p = 
          (forall x:s, a:p,  a |= p x -> x : ||s||) /\ 
          (forall (x:||s||, y:||s||), 
             forall a:p,  x =s= y -> a |= p x -> a |= p y)
   *)
    
   (* proposition p2 : s->prop *)
   (**  Assertion predicate_p2 =  (forall x:s,  p2 x -> x : ||s||) /\ 
          (forall (x:||s||, y:||s||),  x =s= y -> p2 x -> p2 y)
   *)
    
   (* proposition p3 : s->s->prop *)
   (**  Assertion predicate_p3 = 
          (forall x:s, y:s,  p3 x y -> x : ||s|| /\ y : ||s||) /\ 
          (forall (x:||s||, y:||s||, z:||s||, w:||s||),  x =s= z /\ 
             y =s= w -> p3 x y -> p3 z w)
   *)
    
   
   (**  Assertion equiv_p3 =  (forall (x:||s||),  p3 x x) /\ 
          (forall (x:||s||, y:||s||),  p3 x y -> p3 y x) /\ 
          (forall (x:||s||, y:||s||, z:||s||),  p3 x y /\ p3 y z -> p3 x z)
   *)
    
   type phi
    
   (* proposition phi : phi->prop *)
   (**  Assertion predicate_phi =  true
   *)
    
   type psi
    
   (* proposition psi : psi->prop *)
   (**  Assertion predicate_psi =  true
   *)
    
   type rho
    
   (* proposition rho : rho->prop *)
   (**  Assertion predicate_rho =  true
   *)
    
   val tst_and : phi * psi * rho
   (**  Assertion tst_and =  pi0 tst_and |= phi  /\ pi1 tst_and |= psi  /\ 
          pi2 tst_and |= rho 
   *)
    
   val tst_imply : phi -> psi
   (**  Assertion tst_imply = 
          forall x:phi,  x |= phi  -> tst_imply x |= psi 
   *)
    
   val tst_iff : (phi -> psi) * (psi -> phi)
   (**  Assertion tst_iff = 
          (forall x:phi,  x |= phi  -> (pi0 tst_iff) x |= psi ) /\ 
          (forall x:psi,  x |= psi  -> (pi1 tst_iff) x |= phi )
   *)
    
   val tst_or : [`or0 of phi | `or1 of psi | `or2 of rho]
   (**  Assertion tst_or = 
          (exists x:phi,  tst_or = `or0 x /\ x |= phi ) cor 
          (exists x:psi,  tst_or = `or1 x /\ x |= psi ) cor 
          (exists x:rho,  tst_or = `or2 x /\ x |= rho )
   *)
    
   val tst_forall : s -> p
   (**  Assertion tst_forall =  forall (x:||s||),  tst_forall x |= p x
   *)
    
   val tst_exists : s * p
   (**  Assertion tst_exists =  pi0 tst_exists : ||s|| /\ 
          pi1 tst_exists |= p (pi0 tst_exists)
   *)
    
   val tst_exists1 : s * p
   (**  Assertion tst_exists1 =  pi0 tst_exists1 : ||s|| /\ 
          pi1 tst_exists1 |= p (pi0 tst_exists1) /\ 
          (forall q:s * p,  pi0 q : ||s|| /\ pi1 tst_exists1 |= p (pi0 q) ->
             pi0 tst_exists1 =s= pi0 q)
   *)
    
   
   (**  Assertion tst_not =  forall x:phi,  not (x |= phi )
   *)
    
   val x0 : s
   (**  Assertion x0_total =  x0 : ||s||
   *)
    
   val y0 : s
   (**  Assertion y0_total =  y0 : ||s||
   *)
    
   
   (**  Assertion tst_equal =  x0 =s= y0
   *)
    
   type q = p
    
   (* proposition q : s->q->prop *)
   (**  Assertion q_def = 
          forall (z:||s||),  forall a:q,  a |= q z <-> (z =s= x0 -> a |= p z)
   *)
    
   val tst_papp : q
   (**  Assertion tst_papp =  tst_papp |= q y0
   *)
    
   (* proposition r1 : s->s->prop *)
   (**  Assertion r1_def = 
          forall (x:||s||, y:||s||),  r1 x y <->
            (forall t:p,  not (t |= p x /\ (forall z:p,  not (z |= p y))))
   *)
    
   (* proposition r2 : s->s->prop *)
   (**  Assertion r2_def = 
          forall (x:||s||, y:||s||),  r2 x y <->
            (assure (forall (z:||s||),  r1 z z) /\ 
                 (forall (z:||s||, w:||s||),  r1 z w -> r1 w z) /\ 
                 (forall (z:||s||, w:||s||, t:||s||),  r1 z w /\ r1 w t ->
                    r1 z t) in r1 x y)
   *)
    
   val w : [`foo | `bar of (s * s)]
   (**  Assertion w_total =  w = `foo cor 
          (exists i:s * s,  w = `bar i /\ pi0 i : ||s|| /\ pi1 i : ||s||)
   *)
    
   val tst_pcase : [`bar of p | `foo of p]
   (**  Assertion tst_pcase = 
          match (tst_pcase,w) with
            (`bar(x:p),`bar(u:s * s)) =>
               pi0 u : ||s|| /\ pi1 u : ||s|| /\ x |= p (pi0 u) 
          | (`foo(x:p),`foo) => x |= p x0 
          
   *)
 end

