\section{Typed realizability}
\label{sec:typed-realizability}

RZ is based on \emph{typed realizability} by John
Longley~\cite{Longley99}. It is a variant of realizability that most
directly corresponds to the informal view that a programmer has in
mind when thinking about an implementation of a structure.

We motivate and explain typed realizability and its relationship with
real-world programming by way of example. Suppose we are asked to
design a data structure for the set $\mathcal{G}$ of all finite
simple\footnote{There is at most one arrow between any two vertices.}
directed graphs with vertices labeled by integers. An exemplar
directed graph~$G$ is shown in Figure~\ref{fig:digraph}.
%
\begin{figure}
  \centering
  \includegraphics[width=0.4\textwidth]{digraph}
  \caption{A finite directed graph $G$}
  \label{fig:digraph}
\end{figure}
%
A common representation is a pair of lists $(\ell_V, \ell_A)$, where
$\ell_V$ is the list of vertices and $\ell_A$ the list of arrows,
known as the \emph{adjacency list}. In our example, $\ell_V = [1; 2;
3; 4]$ and $\ell_A = [(1,2); (2,2); (2,3); (3,2); (3;1)]$. Thus we
define the datatype of graphs to be\footnote{We use Ocaml notation in
  which $\clist{t}$ means lists of elements of type~$t$, and
  $t_1 * t_2$ means the type of ordered pairs whose first component
  has type $t_1$ and second type $t_2$.}
%
\begin{equation*}
  \ctype \mathtt{graph} = \clist{\cint} * \clist{(\cint * \cint)}
\end{equation*}
%
However, this is not a complete description of the representation, as
there are representation invariants and conditions which are not
expressed directly in the programming language, such as:
%
\begin{enumerate}
\item The order in which vertices and arrows are listed is not
  important, e.g., $[1;2;3;4]$ and $[4;1;2;3]$ represent the same vertices.
\item Each vertex and arrow must be listed exactly once.
\item Infinite, cyclic lists, and non-terminating values are not valid
  representations, e.g.,
  %
  \begin{equation*}
    \cwhile{\ctrue}{()}; [(1,2);(2,2);(2,3);(3,2);(3;1)]
  \end{equation*}
  %
  is not a valid adjacency list, and neither is an expression that
  raises an exception.
\item We ought to decide which computational effects, if any, are
  allowed, e.g., is
  %
  \begin{equation*}
    \cprint{\cstring{Hello}}; [(1,2);(2,2);(2,3);(3,2);(3;1)]
  \end{equation*}
  %
  a valid adjacency list?
\end{enumerate}
%
To summarize, an implementation of the set~$\mathcal{G}$ should tell
us not only what the underlying datatype $\mathtt{graph}$ is, but also
which values of type $\mathtt{graph}$ represent which elements
of~$\mathcal{G}$. As we shall see next, all of this can be expressed
either as a \emph{realizability relation} or a \emph{partial
  equivalence relation (per)}.

We now give the formal definition of typed realizability, as it
applies to Ocaml. Other general-purpose programming languages could be
used instead, as long as they provide the usual ground types, product
and function types. Additionally, it is convenient to work with a
language that supports sum types, as this allows a more natural
representation of disjoint unions.

Let $\Type$ be the collection of all (non-parametric) Ocaml types. To
each type $t \in \Type$ we assign the set $\terminating{t}$ of
terminating values of type~$t$ which behave \emph{functionally} in the
sense of~\cite{longley99when}. Such values may not diverge, raise
exceptions, or return different results on different invocations,
although they \emph{may} use exceptions, store, and other
computational effects, as long as they behave as if they did not. A
useful example of a functional value using store is presented in
Section~\ref{sec:we-show-modulus-of-continuity-example}. Note also
that a terminating value of a functional type may diverge as soon as
it is applied, e.g., if we define $\cletrec{f\;x}{f\;(x+1)}$ then $f
\in \terminating{\cint \to \cint}$. The collection $\Type$ with the
assignment of terminating values $|t|$ to each $t \in \Type$ forms a
\emph{typed partial combinatory algebra (TPCA)}, which provides a
theoretical basis for the definition of a realizability model that
suits our needs.

Going back to our example, we see that to implement the set of
directed graphs $\mathcal{G}$ is to specify a datatype
$\typeOf{\mathcal{G}} = \mathtt{graph}$ together with a
\emph{realizability relation} $\rz_{\mathcal{G}}$ between
$\mathcal{G}$ and $\terminating{\mathtt{graph}}$. The meaning of
$(\ell_V, \ell_A) \rz_\mathcal{G} G$ is ``value $(\ell_V, \ell_A)$
represents (realizes, implements) graph $G$''. There are two natural
conditions that $\rz_\mathcal{G}$ ought to satisfy: (1) for every $G
\in \mathcal{G}$ there should be at least one realizer $(\ell_V,
\ell_A)$ representing it, and (2) if $(\ell_V, \ell_A)$ represents
both $G$ and $G'$ then $G = G'$. The latter condition is called
\emph{modesty} and is not strictly necessary for the development of
the theory, though it is something that programmers would naturally
expect to hold. If $(\ell_V, \ell_A)$ and $(\ell'_V, \ell'_A)$
represent the same graph, we say that they are \emph{equivalent} and
write $(\ell_V, \ell_A) \per_\mathcal{G} (\ell'_V, \ell'_A)$. The
relation $\per_\mathcal{G}$ is a partial equivalence relation
(symmetric and transitive), and may be defined in terms of
$\rz_\mathcal{G}$ by
%
\begin{equation*}
  u \per_\mathcal{G} v
  \iff
  \some{G}{\mathcal{G}}{u \rz_\mathcal{G} G \land v \rz_\mathcal{G} G}
  \;.
\end{equation*}


A general definition is in order. A \emph{modest set} is a triple
$\modestSet{A}$ where $A$ is a set, $\typeOf{A} \in \Type$, and
$\rz_A$ is a relation between $\terminating{\typeOf{A}}$ and $A$,
satisfying
% 
\begin{enumerate}
\item \emph{totality:} for every $x \in A$ there is $v$ such that $v
  \rz_A x$, and
\item \emph{modesty:} if $u \rz_A x$ and $u \rz_A y$ then $x = y$.
\end{enumerate}
%
The \emph{support} of $A$ is the set $\support{A}$ of those values
which realize something,
%
\begin{equation*}
  \support{A} = \set{v \in \typeOf{A} \such \xsome{x}{A}{v \rz_A x}} \;.
\end{equation*}
%
We define the relation $\per_A$ on $\terminating{\typeOf{A}}$ by
%
\begin{equation*}
  u \per_A v
  \iff
  \some{x}{A}{u \rz_A x \land v \rz_A x} \;.
\end{equation*}
%
From totality and modesty of $\rz_A$ it follows that $\rz_A$ is a per,
ie., symmtric and transitive. Observe that $\support{A} = \set{v \in
  \typeOf{A} \such v \per_A v}$, whence $\per_A$ restricted to
$\support{A}$ is an equivalence relation. Even more, we may recover a
modest set up to isomorphism from $\typeOf{A}$ and $\per_A$ by taking
$A$ to be the set of equivalence classes of $\per_A$, and $v \rz_A x$
to mean $v \in x$.

We have developed two equivalent views of implementations: as modest
sets $(A, \typeOf{A}, {\rz_A})$, and as pers $(\typeOf{A}, {\per_A})$.
In RZ we use pers because they refer only to types and values, as
opposed to arbitrary sets. Nevertheless, it is useful to undestand how
modest sets and pers arise from natural considerations about
programming practice.

- canonical constructions



\bigskip\bigskip


Outline:
%
\begin{enumerate}
\item explain how PER models are a natural semantic model for a
  programmer, because they capture ideas like
\item choice of representation and representation invariants,
\item definition of a PER model, which makes things more precise, in
  particular
\item what computational model we use (ML-like language, terminating
  values are used to represent things), and
\item what the category of PER's is (but sweep categories under the
  rug)
\item discuss relationship with ``ordinary'' realizability a la
  Kleene~\cite{KleeneSC:intint}, since logicians and theoreticians
  usually know that kind
\end{enumerate}

There ought to be some examples here.

\section{Singatures and specifications}
\label{sec:sing-spec}

Outline:
%
\begin{enumerate}
\item We introduce assertions by saying that signatures only describe a
  part of a specification
\item Our assertions talk about per's
\item They are written in the negative fragment,
\end{enumerate}


\section{The Input Language}
\label{sec:input-language}

Explain the input language and its semantics.

\section{Translation}
\label{sec:translation}

Explain the translation.




%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "cie"
%%% End: 
