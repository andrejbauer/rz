\section{Examples}
\label{sec:examples}

In this section we look at several examples which demonstrate various
points of RZ. Unfortunately, serious examples from computable
mathematics take too much space\footnote{The most basic structure
  in analysis (the real numbers) alone 
  requires several operations and a dozen or more axioms.} and will have to
be presented separately. The main theme is that constructively
reasonable axioms yield computationally reasonable operations.

\subsection{Decidable sets}
\label{sec:decidable-sets}

A set $S$ is said to be decidable when, for all $x, y \in S$, $x = y$
or $\lnot (x = y)$. In classical mathematics all sets are decidable
because decidability of equality is just an instance of the law of
excluded middle. However, RZ computes from
%
\[
\footnotesize
\begin{array}{l}
\iParameter{\mathtt{s}}{\iSet}.\\
\iAxiom{\mathtt{eq}}{\forall\mathtt{x},\mathtt{y}:\mathtt{s}.\ \ \mathtt{x} = \mathtt{y} \lor \lnot(\mathtt{x} = \mathtt{y})}.\\
\end{array}
\]
%
that the realizer for the axiom $\mathtt{eq}$ is specified by
%
\begin{source}
val eq : s -> s -> [`or0 | `or1]
(**  Assertion eq =
       forall (x:||s||, y:||s||),
         (match eq x y with
            `or0 => x =s= y
          | `or1 => not (x =s= y) )
*)
\end{source}
%
We read this as follows: $\mathtt{eq}$ is a function which takes
arguments~$x$ and~$y$ of type~$s$ and returns $\mathtt{`or0}$ or
$\mathtt{`or1}$. If it returns $\mathtt{`or0}$, then $x \per_s y$, and
if it returns $\mathtt{`or1}$, then $\lnot (x \per_s y)$. In other
words $\mathtt{eq}$ is a decision procedure which tells when
values~$x$ and~$y$ represent the same element of the modest set.

\subsection{Examples with obligations}
\label{sec:exampl-with-oblig}

In this section we show how RZ produces obligations, is sometimes able
to optimize them away, and show the effect of hoisting.

Consider how we might define division of real numbers. Assuming the
set of real numbers~$\mathtt{real}$, a constant $\mathtt{zero}$, and
multiplication operation~$\mathtt{*}$ have already been declared and
axiomatized, we might write:
%
\[
\footnotesize
\begin{array}{l}
\iDefinition{\mathtt{nonZeroReal}}{\isubset{\mathtt{x}}{\mathtt{real}}{\lnot(\mathtt{x}=\mathtt{zero})}}.\\
\iParameter{\mathtt{inv}}{\mathtt{nonZeroReal}\to\mathtt{real}}.\\
\iAxiom{\mathtt{inverse}}{\forall\mathtt{x}:\mathtt{real}.\ \lnot(\mathtt{x}=\mathtt{zero}) \Rightarrow \mathtt{x}\,\mathtt{*}\,(\mathtt{inv\ x}) = \mathtt{one}}.\\
\iDefinition{\mathtt{(/)}\ (\mathtt{x}:\mathtt{real})\ (\mathtt{y}:\mathtt{nonZeroReal})} {\mathtt{x}\,\mathtt{*}\,(\mathtt{inv\ y})}.\\
\end{array}
\]
\iffalse
\begin{source}
Definition nonZeroReal := {x : real | not (x = zero)}.
Parameter inv : nonZeroReal -> real.
Axiom inverse : forall x : real, (not x = zero) -> x * (inv x) = one.
Definition (/) (x : real) (y : nonZeroReal) := x * (inv y).
\end{source}
\fi
%
We have defined the set of non-zero reals $\mathtt{nonZeroReal}$ and
the inverse operation~$\mathtt{inv}$ on it. Division $x/y$ is defined
as $x * \mathtt{inv}\,y$. This does \emph{not} mean that the
programmer must necessarily implement division this way, only that the
implementation of $x/y$ must be equivalent to $x * \mathtt{inv}\,y$.

In the axiom $\mathtt{inverse}$, RZ encounters the subexpression
$\mathtt{inv}\;x$. Because $x$ is quantified as an element of
$\mathtt{real}$ rather than $\mathtt{nonZeroReal}$, the typechecking
phase inserts a coercion that makes the expression well-typed.
Translation sees $\mathtt{inv}(x \mathbin{{:}}
\mathtt{nonZeroReal})$ instead of $\mathtt{inv\ x}$ and translates this to
%
\begin{source}
inv (assure u:unit . not (x =real= zero) in (x, u))
\end{source}
%
If this were the final output, the programmer would have to verify
that~$x$ is not zero, and provide a trivial realizer for it. However,
in this case the thinning phase first removes the trivial realizer,
%
\iflong
\begin{source}
inv (assure not (x =real= zero) in x)
\end{source}
\fi % \iflong
%
and then the optimizer determines that the obligation is not needed
because the whole expressions appears under the hypothesis that~$x$ is
not zero. So in the end the programmer sees
%
\begin{source}
(**  Assertion inverse =
  forall (x:||real||),  not (x =real= zero) -> (x * inv x) =real= one
*)
\end{source}
%
Assuming further that a strict linear order $<$ on~$\mathtt{real}$ has
been axiomatized, we might proceed by relating it to $\mathtt{inv}$:
%
\begin{source}
Axiom inv_positive: forall x : real, zero < x -> zero < inv x.
\end{source}
%
Once again $\mathtt{inv}\;x$ appears in the input, bt this time the
optimizer is unable to remove the obligation, so the output is
%
\begin{source}
(**  Assertion inv_positive =
       forall (x:||real||),  zero < x ->
         zero < inv (assure (not (x =real= zero)) in x)
*)
\end{source}
%
Local obligations can sometimes be hard to read, but if we activate the hoisting phase
(see Section~\ref{sec:implementation}), the obligation can be moved
to the top level. As this is done, the hypotheses under which the
obligation appears are collected, and we get
%
\begin{source}
(**  Assertion inv_positive =
  assure (forall (x:||real||),  zero < x -> not (x =real= zero))
    in forall (x:||real||),  zero < x -> zero < inv x
*)
\end{source}
%
Now it is easier to understand what must be checked, namely that
positive reals are not zero---an easy consequence of irreflexivity
of~$<$, but not something that RZ optimizer is aware of.

\iflong
Lastly, we could define the golden ratio as the positive solution of
$x^2 = x + 1$,
%
\begin{source}
the x : real, (zero < x /\ x*x = x + one)
\end{source}
%
Not surprisingly, RZ cannot determine that there is a unique such~$x$,
so it outputs an obligation:
%
\begin{source}
assure x:real.
  (x : ||real|| /\ zero < x /\ x * x =real= x + one /\
     (forall (x':||real||),  zero < x' /\ x' * x' =real= x' + one ->
        x =real= x'))
  in x
\end{source}
\fi % \iflong

\subsection{Finite sets}
\label{sec:finite-sets}

\begin{figure}[t]
  \centering
\[
\begin{array}{l}
\iDefinition{\mathtt{Semilattice}}{\mathsf{thy}}\\
\qquad \iParameter{\mathtt{s}}{\iSet}.\\
\qquad \iParameter{\mathtt{zero}}{\mathtt{s}}.\\
\qquad \iParameter{\mathtt{join}}{\mathtt{s}\to\mathtt{s}\to\mathtt{s}}.\\
\\
\qquad \iAxiom{\mathtt{commutative}}{\forall \mathtt{x},\mathtt{y}:\mathtt{s}.\ \mathtt{join\ x\ y} = \mathtt{join\ y\ x}}.\\
\qquad \iAxiom{\mathtt{associative}}{\forall \mathtt{x},\mathtt{y},\mathtt{z}:\mathtt{s}.\ \mathtt{join}\,(\mathtt{join\ x\ y})\,\mathtt{z} = \mathtt{join}\,\mathtt{x}\, (\mathtt{join\ y\ z})}.\\
\qquad \iAxiom{\mathtt{idempotent}}{\forall \mathtt{x}:\mathtt{s}.\ \mathtt{join\ x\ x} = \mathtt{x}}.\\
\qquad \iAxiom{\mathtt{neutral}}{\forall \mathtt{x}:\mathtt{s}.\ \mathtt{join\ x\ zero} = \mathtt{x}}.\\
\mathsf{end}.
\end{array}
\]
  \caption{The theory of a semilattice}
  \label{fig:semilattice}
\end{figure}

There are many characterizations of finite sets, but the one that
works best constructively is due to Kuratowski, who identified the
finite subsets of~$A$ as the least family~$K(A)$ of subsets of~$A$
that contains the empty set and is closed under unions with
singletons. This characterization relies on powersets, which are not
available in RZ. But the gist of it, namely that $K(A)$ is an
\emph{inital} structure a suitable sort, can be expressed as follows.

Recall that a \emph{$\vee$-semilattice} is a set~$S$ with a
constant~$0 \in S$ and an associative, commutative, and idempotent
operation ``join'' $\vee$ on~$S$ such that $0$ is the neutral element
for~$\vee$, see Figure~\ref{fig:semilattice} for RZ axiomatization of
semilattices.
%
The Kuratowski finite sets~$K(A)$ are the \emph{free} semilattice
generated by a set~$A$, where $\vee$ is union and $0$ is the empty
set. This is formalized in RZ as shown in Figure~\ref{fig:kuratowski}.
%
\begin{figure}
\[
\begin{array}{l}
\iDefinition{\texttt{K}\ (\texttt{A} : \mathtt{thy}\ \  \iParameter{\mathtt{a}}{\iSet}.\ \  \texttt{end})}{\mathtt{thy}}\\
\qquad \iInclude{\mathtt{Semilattice}}.\\
\qquad \iParameter{\mathtt{singleton}}{\mathtt{A.a} \to \mathtt{s}}.\\
\qquad \iDefinition{\mathtt{fin}}{\mathtt{s}}.\\
\qquad \iDefinition{\mathtt{emptyset}}{\mathtt{zero}}.\\
\qquad \iDefinition{\mathtt{union}}{\mathtt{join}}.\\
\\
\qquad \iAxiom{\mathtt{free}}{} \forall \mathtt{S}:\mathtt{Semilattice}.\ \forall\mathtt{f}:{\mathtt{A.a}\to\mathtt{S.s}}.\ \exists!g:\mathtt{fin}{\to}{\mathtt{S.s}}.\\
\qquad \qquad \qquad \qquad \qquad \mathtt{g\ emptyset} = \mathtt{S.zero}\ \land\\
\qquad \qquad \qquad \qquad \qquad \forall\mathtt{x}:\mathtt{A.a}.\ \mathtt{f\ x} = \mathtt{g}(\mathtt{singleton\ x})\ \land\\
\qquad \qquad \qquad \qquad \qquad \forall\mathtt{u},\mathtt{v}:\mathtt{fin}.\ \mathtt{g}(\mathtt{union\ u\ v}) = \mathtt{S.join}\,(\mathtt{g\ u})\,(\mathtt{g\ v}).\\
\mathtt{end}.
\end{array}
\]
  \caption{Kuratowski finite sets}
  \label{fig:kuratowski}
\end{figure}
%
The theory $K$ is parametrized by a model~$A$ which contains a
set~$a$. In the first line we include the theory of semilattices. Then
we postulate an operation $\mathtt{singleton}$ which injects the
generators into the semilattice. The three definitions are just a
convenience, so that we can refer to the parts of $K(A)$ by their
natural names, e.g., $\mathtt{emptyset}$ instead of $\mathtt{zero}$.
The axiom $\mathtt{free}$ expresses the fact that $K(A)$ is the free
semilattice on~$A.a$: for every semilattice $S$ and a map $f : A.a \to
S.s$ from the generators to the underlying set of~$S$, there exists a
unique semilattice homomorphism $g : \mathtt{fin} \to S.s$ such that
$f(x) = g(\set{x})$.

The output for $\mathtt{Semilattice}$ and~$\mathtt{K}$ specifies
values of suitable types for each declared constant and operation. All
axioms but the last one are equations and have straightforward
translations in terms of underlying pers. The output for the axiom
$\mathtt{free}$ is shown in Figure~\ref{fig:free}.
%
\begin{figure}
  \centering
\begin{source}
module Free : functor (S : Semilattice) ->
sig
val free : (A.a -> S.s) -> fin -> S.s
(**  Assertion free = 
forall (f:||A.a -> S.s||), 
  let g = free f in g : ||fin -> S.s|| /\ 
  g emptyset =S.s= S.zero /\ 
  (forall (x:||A.a||),  f x =S.s= g (singleton x)) /\ 
  (forall (u:||fin||, v:||fin||), g (union u v) =S.s= S.join (g u) (g v)) /\ 
  (forall h:fin -> S.s,  h : ||fin -> S.s|| /\ 
     h emptyset =S.s= S.zero /\ 
     (forall (x:||A.a||), f x =S.s= h (singleton x)) /\ 
     (forall (u:||fin||, v:||fin||), 
        h (union u v) =S.s= S.join (h u) (h v)) ->
     forall x:fin, y:fin,  x =fin= y -> g x =S.s= h y)
*)
end
\end{source}
  \caption{Output of axiom $\texttt{free}$.}
  \label{fig:free}
\end{figure}
%
Because the axiom quantifies over all models~$S$ of the theory
$\mathtt{Semilattice}$ its translation is a functor~$\mathtt{Free}$
which accepts an implementation of a semilattice~$S$ and yields a
realizer $\mathtt{free}$ validating the axiom. The computational
meaning of $\mathtt{free}$ is a folding operation on finite sets: take
a map $f : A.a \to S.s$ and a finite set~$u = \set{x_1, \ldots, x_n}$,
and return $f(x_1) \vee \cdots \vee f(x_n)$, where $\vee$ is the join
operation on the semilattice~$S$.

Applying phase-splitting to this axiom yields the even simpler
specification
appearing in the output of the Kuratowski example can be replaced by the single polymorphic function
\[
\mathsf{val}\ \mathtt{free} : \alpha \to (\alpha \to \alpha \to \alpha) \to (\mathtt{A.a}\to\alpha) \to \mathtt{fin} \to \alpha	
\]
(with an appropriate assertion)
which replaces the module parameter \texttt{S} by two extra term arguments term (corresponding to the module components \texttt{S.zero} and \texttt{S.join}) 
and a type argument $\alpha$ for the type of lattice elements (corresponding to the module input \texttt{S.s}).  This is even
more recognizable as a folding operation over the set.


It is important to note that, in contrast to \texttt{fold} operators found in typical functional
languages, \texttt{free} is only guaranteed to work for suitable \texttt{join} arguments (e.g., idempotent and order independent).  These
sets are thus not the typical finite-set data structure: there is no membership predicate, nor
is there a way to compute the size of a set.  This occurs because there was no
assumption that equality is decidable for set elements; we could have a finite set
of exact real numbers, for example.  Deciding equality
is required both for membership and for detecting
whether the same element has been added twice to the same set\footnote{The natural implementation would thus
be an unordered collection of elements, possibly with duplicates.}.

However, there are nevertheless computable operations on such sets.  Using \texttt{free} one
can determine whether a finite set is empty or not.  In the case of a set of exact
real numbers, we cannot compute their sum, but we could compute maximum or minimum.

More common set implementations (e.g., the \texttt{Set} module in the OCaml standard library)
implement sets over values with either decidable total order; these could also be
formalized in RZ.

% Chris: INDUCTIVE TYPES EXAMPLE USED TO BE HERE BEFORE I MOVED IT TO THE APPENDIX



\subsection{Axiom of choice}
\label{sec:axiom-choice}

RZ can help explain why a generally
accepted axiom is not constructively valid. Consider the Axiom of
Choice:
%
\sourcefile{choice.thy}
%
The relevant part of the output is
%
\begin{source}
val ac : (a -> b * ty_r) -> (a -> b) * (a -> ty_r)
(**  Assertion ac =
  forall f:a -> b * ty_r,
    (forall (x:||a||),  let (p,q) = f x in p : ||b|| /\ r x p q) ->
    let (g,h) = ac f in g : ||a -> b|| /\
    (forall (x:||a||),  r x (g x) (h x))
*)
\end{source}
%
This requires a function $\mathtt{ac}$ which accepts a function $f$
and computes a pair of functions $(g,h)$. The input function~$f$ takes
an $\ototal{x}{a}$ and returns a pair $(p,q)$ such that $q$ realizes
the fact that $r\,x\,p$ holds. The output functions $g$ and $h$ taking
$\ototal{x}{a}$ as input must be such that $h\,x$ realizes
$r\,x\,(g\,x)$. Crucially, the requirement $\ototal{g}{\oarrow{a}{b}}$
says tht $g$ must be extensional, i.e., map equivalent realizers to
equivalent realizers. We could define~$h$ as the first component
of~$f$, but we cannot hope to implement~$g$ in general because the
second component of~$f$ is not assumed to be extensional.

The \emph{Intensional} Axiom of Choice allows the choice function to
depend on the realizers:
%
\sourcefile{ichoice.thy} Now the output is
%
\begin{source}
val iac : (a -> b * ty_r) -> (a -> b) * (a -> ty_r)
(**  Assertion iac =
  forall f:a -> b * ty_r,
    (forall (x:||a||),  let (p,q) = f x in p : ||b|| /\ r x p q) ->
    let (g,h) = iac f in (forall x:a,  x : ||a|| -> g x : ||b||) /\
    (forall (x:||a||),  r x (g x) (h x))
*)
\end{source}
%
which is exactly the same as before, \emph{except} that the
troublesome requirement $\ototal{g}{\oarrow{a}{b}}$ turned into
$\oforall{x}{a}{(\oimply{\ototal{x}{a}}{\ototal{g\,x}{b}})}$, which
is weaker. We can impement $\mathtt{iac}$ as
%
\begin{source}
let iac f = (fun x -> fst (f x)), (fun x -> snd (f x))
\end{source}
%

The Intensional Axiom of Choice is in fact just an instance of the
usual Axiom of Choice applied to~$\irz{A}$ and~$B$. Combined with the
fact that~$\irz{A}$ covers~$A$, this establishes the validity of
\emph{Presentation Axiom}~\cite{barwise75:_admis_sets_struc}, which
states that every set is an image of one satisfying the axiom of
choice.

\subsection{Modulus of Continuity}
\label{sec:we-show-modulus-of-continuity-example}

As a last example we show how certain constructive principles require
the use of computational effects. To keep the example short, we
presume that we are already given the set of natural
numbers~$\mathtt{nat}$ with the usual structure.

A \emph{type 2 functional} is a map $f : (\mathtt{nat} \to \mathtt{nat})
\to \mathtt{nat}$. It is said to be continuous if the output of $f(a)$
depends only on an initial segment of the sequence~$a$. We can express
this axiom in RZ as follows:
%
\begin{source}
Axiom continuity:
forall f : (nat -> nat) -> nat, forall a : nat -> nat,
  exists k, forall b : nat -> nat,
    (forall m, m <= k -> a m = b m) -> f a = f b.
\end{source}
%
The axiom says that for any $f$ and $a$ there exists $k \in
\mathtt{nat}$ such that $f(b) = f(a)$ as soon as the sequences~$a$
and~$b$ agree on the first $k$ terms. The axiom is translated to the
specification
%
\begin{source}
val continuity : ((nat -> nat) -> nat) -> (nat -> nat) -> nat
(**  Assertion continuity =
forall (f:||(nat -> nat) -> nat||, a:||nat -> nat||),
  let p = continuity f a in p : ||nat|| /\
  (forall (b:||nat -> nat||),
     (forall (m:||nat||),  m <= p -> a m =nat= b m) -> f a =nat= f b)
*)
\end{source}
%
which says that $\mathtt{continuity}\,f\,a$ is a number~$p$ such that
$f(a) = f(b)$ whenever $a$ and $b$ agree on the first~$p$ terms. In
other words, $\mathtt{continuity}$ is a \emph{modulus of continuity}
functional. It cannot be implemented in a purely functional
language,\footnote{There are models of $\lambda$-calculus which validate
  the choice principle~$AC_{2,0}$, but this principle contradicts the
  existence of a modulus of continuity functional,
  see~\cite[9.6.10]{Troelstra:van-Dalen:88:2}.} but with the use of
store we can implement it as
%
\begin{source}
let continuity f a =
  let p = ref 0 in
  let a' n = (p := max !p n; a n) in
    f a' ; !p
\end{source}
%
To compute a modulus for~$f$ at~$a$, the program creates a
function~$a'$ which is just like~$a$ except that it stores in~$p$ the
largest argument at which it has been called. Then $f\,a'$ is
computed, its value it discarded, and the value of~$p$ is returned.
The program works because~$f$ is assumed to be extensional and must
therefore not distinguish between extensionally equal sequences~$a$
and~$a'$.



%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "cie"
%%% End: 
