\section{Examples}
\label{sec:examples}

In this section we look at several examples which demonstrate various
points of RZ. Unfortunately, serious examples from computable
mathematics take too much space\footnote{The most basic structure
  in analysis (the real numbers) alone 
  requires several operations and a dozen or more axioms.} and will have to
be presented separately. The main theme is that constructively
reasonable axioms yield computationally reasonable operations.

\subsection{Decidable sets}
\label{sec:decidable-sets}

A set $S$ is said to be decidable when, for all $x, y \in S$, $x = y$
or $\lnot (x = y)$. In classical mathematics all sets are decidable
because decidability of equality is just an instance of the law of
excluded middle. However, RZ computes from
%
\sourcefile{decidable1.thy}
%
that the realizer for the axiom $\mathtt{eq}$ is specified by
%
\begin{source}
val eq : s -> s -> [`or0 | `or1]
(**  Assertion eq =
       forall (x:||s||, y:||s||),
         (match eq x y with
            `or0 => x =s= y
          | `or1 => not (x =s= y)
          )
*)
\end{source}
%
We read this as follows: $\mathtt{eq}$ is a function which takes
arguments~$x$ and~$y$ of type~$s$ and returns $\mathtt{`or0}$ or
$\mathtt{`or1}$. If it returns $\mathtt{`or0}$, then $x \per_s y$, and
if it returns $\mathtt{`or1}$, then $\lnot (x \per_s y)$. In other
words $\mathtt{eq}$ is a decision procedure which tells when
values~$x$ and~$y$ represent the same element of the modest set.

\subsection{Examples with obligations}
\label{sec:exampl-with-oblig}

In this section we show several small examples in which RZ outputs
obligations.

Consider how we might define division of real numbers. Given the set
of real numbers~$\mathtt{real}$ and a constant $\mathtt{zero}$
denoting~$0$, we might write
%
\sourcefile{real.thy}

\internal{Andrej}{Unfinished section.}


\subsection{Finite sets}
\label{sec:finite-sets}

There are many characterizations of finite sets, but the one that
works best constructively is due to Kuratowski, who identified the
finite subsets of~$A$ as the least family~$K(A)$ of subsets of~$A$
that contains the empty set and is closed under unions with
singletons. This characterization relies on powersets, which are not
available in RZ. But the gist of it, namely that $K(A)$ is an
\emph{inital} structure a suitable sort, can be expressed as follows.

Recall that a \emph{$\vee$-semilattice} is a set~$S$ with a
constant~$0 \in S$ and an associative, commutative, and idempotent
operation ``join'' $\vee$ on~$S$ such that $0$ is the neutral element
for~$\vee$, see Figure~\ref{fig:semilattice} for RZ axiomatization of
semilattices.
%
\begin{figure}
  \centering
\begin{source}
Definition Semilattice :=
thy
  Parameter s : Set.
  Parameter zero : s.
  Parameter join : s -> s -> s.
  Implicit Type x y z : s.
  Axiom commutative: forall x y,   join x y = join y x.
  Axiom associative: forall x y z, join (join x y) z = join x (join y z).
  Axiom idempotent:  forall x,     join x x = x.
  Axiom neutral:     forall x,     join x zero = x.
end.
\end{source}
  \caption{The theory of a semilattice}
  \label{fig:semilattice}
\end{figure}
%
The Kuratowski finite sets~$K(A)$ are the \emph{free} semilattice
generated by a set~$A$, where $\vee$ is union and $0$ is the empty
set. This is formalized in RZ as shown in Figure~\ref{fig:kuratowski}.
%
\begin{figure}
\centering
\begin{source}
Definition K (A : thy 
                Parameter a : Set.
              end) :=
thy
  include Semilattice.
  Parameter singleton : A.a -> s.
  Definition fin := s.
  Definition emptyset := zero.
  Definition union := join.

  Axiom free :
    forall S : Semilattice, forall f : A.a -> S.s,
    exists1 g : fin -> S.s, 
      g emptyset = S.zero /\
        (forall x : A.a, f x = g (singleton x))/\
        (forall u v : fin, g (union u v) = S.join (g u) (g v)).
end.
\end{source}
  \caption{Kuratowski finite sets}
  \label{fig:kuratowski}
\end{figure}
%
The theory $K$ is parametrized by a model~$A$ which contains a
set~$a$. In the first line we include the theory of semilattices. Then
we postulate an operation $\mathtt{singleton}$ which injects the
generators into the semilattice. The three definitions are just a
convenience, so that we can refer to the parts of $K(A)$ by their
natural names, e.g., $\mathtt{emptyset}$ instead of $\mathtt{zero}$.
The axiom $\mathtt{free}$ expresses the fact that $K(A)$ is the free
semilattice on~$A.a$: for every semilattice $S$ and a map $f : A.a \to
S.s$ from the generators to the underlying set of~$S$, there exists a
unique semilattice homomorphism $g : \mathtt{fin} \to S.s$ such that
$f(x) = g(\set{x})$.

The output for $\mathtt{Semilattice}$ and~$\mathtt{K}$ specifies
values of suitable types for each declared constant and operation. All
axioms but the last one are equations and have straightforward
translations in terms of underlying pers. The output for the axiom
$\mathtt{free}$ is shown in Figure~\ref{fig:free}.
%
\begin{figure}
  \centering
\begin{source}
module Free : functor (S : Semilattice) ->
sig
val free : (A.a -> S.s) -> fin -> S.s
(**  Assertion free = 
forall (f:||A.a -> S.s||), 
  let g = free f in g : ||fin -> S.s|| /\ 
  g emptyset =S.s= S.zero /\ 
  (forall (x:||A.a||),  f x =S.s= g (singleton x)) /\ 
  (forall (u:||fin||, v:||fin||), g (union u v) =S.s= S.join (g u) (g v)) /\ 
  (forall h:fin -> S.s,  h : ||fin -> S.s|| /\ 
     h emptyset =S.s= S.zero /\ 
     (forall (x:||A.a||), f x =S.s= h (singleton x)) /\ 
     (forall (u:||fin||, v:||fin||), 
        h (union u v) =S.s= S.join (h u) (h v)) ->
     forall x:fin, y:fin,  x =fin= y -> g x =S.s= h y)
*)
end
\end{source}
  \caption{Output of axiom $\texttt{free}$.}
  \label{fig:free}
\end{figure}
%
Because the axiom quantifies over all models~$S$ of the theory
$\mathtt{Semilattice}$ its translation is a functor~$\mathtt{Free}$
which accepts an implementation of a semilattice~$S$ and yields a
realizer $\mathtt{free}$ validating the axiom. The computational
meaning of $\mathtt{free}$ is a folding operation on finite sets: take
a map $f : A.a \to S.s$ and a finite set~$u = \set{x_1, \ldots, x_n}$,
and return $f(x_1) \vee \cdots \vee f(x_n)$, where $\vee$ is the join
operation on the semilattice~$S$.

The OCaml standard library contains a module $\mathtt{Set}$
implementing finite sets, which however is \emph{not} an
implementation of Kuratowski finite sets presented here. Rather,
$\mathtt{Set}$ implements something close to Kuratowski finite sets
over a set~$A$ equipped with a decidable linear order.


\subsection{Inductive types}
\label{sec:inductive-types}

To demonstrate the use of dependent types we show how RZ handles
general inductive types, also known as
\emph{W-types}~\cite{w-type-reference}. Recall that a W-type is a set
of well-founded trees, where the branching types of trees are
described by a family of sets $B = \set{T(x)}_{x \in S}$. Each node in
a tree has a \emph{branching type}~$x \in S$, which determines that
the successors of the node are labeled by the elements of~$T(x)$. For
example, to get non-empty binary trees whose leaves are labeled by
natural numbers, define
%
\begin{align*}
  S &= \set{\mathtt{cons}} \cup \set{\mathtt{leaf}(n) \such n \in \NN}
  \\
  T(\mathtt{cons}) &= \set{\mathtt{left}, \mathtt{right}}
  \\
  T(\mathtt{leaf}(n)) &= \emptyset.
\end{align*}
%
Then a node of type $\mathtt{cons}$ has two successors, indexed by
constants $\mathtt{left}$ and $\mathtt{right}$, while a node of type
$\mathtt{leaf}(n)$ does not have any successors.

Figure~\ref{fig:wtype} shows an RZ axiomatization of W-types.
%
\begin{figure}
  \centering
  \sourcefile{wtype.thy}
  \caption{General inductive types}
  \label{fig:wtype}
\end{figure}
%
The theory $\mathtt{Branching}$ describes that a branching type
consits of a set~$s$ and a set~$t$ depending on~$s$. The theory~$W$ is
parametrized by a branching type~$B$. It specifies a set~$w$ of
well-founded trees and a tree-forming operation $\mathtt{tree}$ with a
dependent type $\prod_{x \in B.s} (B.t(x) \to w) \to w$. Given a
branching type~$x$ and a map $f : B.t(x) \to w$, $\mathtt{tree}\,x\,f$
is the tree whose root has branching type~$x$ and whose successor
labeled by $\ell \in B.t(x)$ is the tree~$f(\ell)$. The inductive
nature of~$w$ is expressed with the axiom $\mathtt{induction}$, which
states that for every property $M.p$, if $M.p$ is an inductive
property then every tree satsifies it. A property is said to be
\emph{inductive} if a tree $\mathtt{tree}\,x\,f$ satisfies it whenever
all its successors satisfy it.

In the translation, see Appendix~\ref{sec:outp-induct-types},
dependencies at the level of types and terms disappear. A branching
type is determined by a pair of non-dependent types~$s$ and~$t$ but
the per $\per_t$ depends on~$\values{s}$. The theory~$W$ turns into a
signature for a functor receiving a branching type~$B$ and returning a
type~$w$, and an operation $\mathtt{tree}$ of type $B.s \to (B.t \to
w) \to w$. In this example we use phase-splitting (see
Section~\ref{sec:implementation}) to translate axiom
$\mathtt{induction}$ into a specification of a polymorphic function
(compare with output for axiom \texttt{free} in the previous example)
%
\begin{equation*}
  \mathtt{induction}:
  (B.s \to (B.t \to w) \to (B.t \to \poly{ty\_p}) \to \poly{ty\_p}) \to w \to \poly{ty\_p},
\end{equation*}
%
which is a form of recursion on well-founded trees. Instead of trying
to explain what $\mathtt{induction}$ is supposed to do, we show in
Figure~\ref{fig:wtype-implementation} a surprisingly simple, complete
hand-written implementation of W-types. The reader may entertain
himself by figuring out how $\mathtt{induction}$ works.
%
\begin{figure}
  \centering
  \sourcefile{wtype.ml}
  \caption{An implementation of general inductive types.}
  \label{fig:wtype-implementation}
\end{figure}


\subsection{Axiom of choice}
\label{sec:axiom-choice}

In this example we show how RZ can help explain why a generally
accepted axiom is not constructively valid. Consider the Axiom of
Choice:
%
\sourcefile{choice.thy}
%
The relevant part of the output is
%
\begin{source}
val ac : (a -> b * ty_r) -> (a -> b) * (a -> ty_r)
(**  Assertion ac =
  forall f:a -> b * ty_r,
    (forall (x:||a||),  let (p,q) = f x in p : ||b|| /\ r x p q) ->
    let (g,h) = ac f in g : ||a -> b|| /\
    (forall (x:||a||),  r x (g x) (h x))
*)
\end{source}
%
This requires a function $\mathtt{ac}$ which accepts a function $f$
and computes a pair of functions $(g,h)$. The input function~$f$ takes
an $\ototal{x}{a}$ and returns a pair $(p,q)$ such that $q$ realizes
the fact that $r\,x\,p$ holds. The output functions $g$ and $h$ taking
$\ototal{x}{a}$ as input must be such that $h\,x$ realizes
$r\,x\,(g\,x)$. Crucially, the requirement $\ototal{g}{\oarrow{a}{b}}$
says tht $g$ must be extensional, i.e., map equivalent realizers to
equivalent realizers. We could define~$h$ as the first component
of~$f$, but we cannot hope to implement~$g$ in general because the
second component of~$f$ is not assumed to be extensional.

The \emph{Intensional} Axiom of Choice allows the choice function to
depend on the realizers:
%
\sourcefile{ichoice.thy} Now the output is
%
\begin{source}
val iac : (a -> b * ty_r) -> (a -> b) * (a -> ty_r)
(**  Assertion iac =
  forall f:a -> b * ty_r,
    (forall (x:||a||),  let (p,q) = f x in p : ||b|| /\ r x p q) ->
    let (g,h) = iac f in (forall x:a,  x : ||a|| -> g x : ||b||) /\
    (forall (x:||a||),  r x (g x) (h x))
*)
\end{source}
%
which is exactly the same as before, \emph{except} that the
troublesome requirement $\ototal{g}{\oarrow{a}{b}}$ turned into
$\oforall{x}{a}{(\oimply{\ototal{x}{a}}{\ototal{g\,x}{b}})}$, which
is weaker. We can impement $\mathtt{iac}$ as
%
\begin{source}
let iac f = (fun x -> fst (f x)), (fun x -> snd (f x))
\end{source}
%

The Intensional Axiom of Choice is in fact just an instance of the
usual Axiom of Choice applied to~$\irz{A}$ and~$B$. Combined with the
fact that~$\irz{A}$ covers~$A$, this establishes the validity of
\emph{Presentation Axiom}~\cite{barwise75:_admis_sets_struc}, which
states that every set is an image of one satisfying the axiom of
choice.

\subsection{Modulus of Continuity}
\label{sec:we-show-modulus-of-continuity-example}

As a last example we show how certain constructive principles require
the use of computational effects. To keep the example short, we
presume that we are already given the set of natural
numbers~$\mathtt{nat}$ with the usual structure.

A \emph{type 2 function} is a map $f : (\mathtt{nat} \to \mathtt{nat})
\to \mathtt{nat}$. It is said to be continuous if the output of $f(a)$
depends only on an initial segment of the sequence~$a$. We can express
this axiom in RZ as follows:
%
\begin{source}
Axiom continuity:
forall f : (nat -> nat) -> nat, forall a : nat -> nat,
  exists k, forall b : nat -> nat,
    (forall m, m <= k -> a m = b m) -> f a = f b.
\end{source}
%
The axiom says that for any $f$ and $a$ there exists $k \in
\mathtt{nat}$ such that $f(b) = f(a)$ as soon as the sequences~$a$
and~$b$ agree on the first $k$ terms. The axiom is translated to the
specification
%
\begin{source}
val continuity : ((nat -> nat) -> nat) -> (nat -> nat) -> nat
(**  Assertion continuity =
forall (f:||(nat -> nat) -> nat||, a:||nat -> nat||),
  let p = continuity f a in p : ||nat|| /\
  (forall (b:||nat -> nat||),
     (forall (m:||nat||),  m <= p -> a m =nat= b m) -> f a =nat= f b)
*)
\end{source}
%
which says that $\mathtt{continuity}\,f\,a$ is a number~$p$ such that
$f(a) = f(b)$ whenever $a$ and $b$ agree on the first~$p$ terms. In
other words, $\mathtt{continuity}$ is a \emph{modulus of continuity}
functional. It cannot be implemented in a purely functional
language~\cite{modulus-violates-ac2}, but with the use of store we can
implement it as
%
\begin{source}
let continuity f a =
  let k = ref 0 in
  let a' n = (k := max !k n; a n) in
    f a' ; !k
\end{source}
%
To compute a modulus for~$f$ at~$a$, the program creates a
function~$a'$ which is just like~$a$ except that it stores in~$p$ the
largest argument at which it has been called. Then $f\,a'$ is
computed, its value it discarded, and the value of~$p$ is returned.
The program works because~$f$ is assumed to be extensional and must
therefore not distinguish between extensionally equal sequences~$a$
and~$a'$.



%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "cie"
%%% End: 
