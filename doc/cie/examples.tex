\section{Examples}
\label{sec:examples}

In this section we look at serveral examples which demonstrate various
points of RZ. Unfortunately, serious examples from computable
mathematics take too much space\footnote{Simply because even to
  describe real numbers, the most basic structure in analysis, it
  takes several operations and a dozen axioms or so.} and will have to
be presented separately.

\subsection{Decidable sets}
\label{sec:decidable-sets}

A set $S$ is said to be decidable when, for all $x, y \in S$, $x = y$
or $\lnot (x = y)$. In classical mathematics all sets are decidable
because decidability of equality is just an instance of the law of
exluced middle. However, RZ computes from
%
\sourcefile{decidable1.thy}
%
that the realizer for the axiom $\mathtt{eq}$ is specified by
%
\begin{source}
val eq : s -> s -> [`or0 | `or1]
(**  Assertion eq =
       forall (x:||s||, y:||s||),
         (match eq x y with
            `or0 => x =s= y
          | `or1 => not (x =s= y)
          )
*)
\end{source}
%
We read this as follows: $\mathtt{eq}$ is a function which takes
arguments~$x$ and~$y$ of type~$s$ and returns $\mathtt{`or0}$ or
$\mathtt{`or1}$. If it returns $\mathtt{`or0}$, then $x \per_s y$, and
if it returns $\mathtt{`or1}$, then $\lnot (x \per_s y)$. In other
words $\mathtt{eq}$ is a decision procedure which tells when
values~$x$ and~$y$ represent the same element of the modest set.

\subsection{Examples with obligations}
\label{sec:exampl-with-oblig}


\subsection{Finite sets}
\label{sec:finite-sets}

There are many characterizations of finite sets, but the one that
works best constructively is due to Kuratowski, who identified the
finite subsets of~$A$ as the least family~$K(A)$ of subsets of~$A$
that contains the empty set and is closed under unions with
singletons. This characterization relies on powersets, which are not
available in RZ. We can reformulate it in the language of algebra as
follows.

Recall that a \emph{semilattice} is a set~$S$ with a constant~$0 \in
S$ and an associative, commutative, and idempotent operation ``join''
$\vee$ on~$S$ such that $0$ is the neutral element for~$\vee$, see
Figure~\ref{fig:semilattice} for RZ axiomatization of semilattices.
%
\begin{figure}
  \centering
\begin{source}
Definition Semilattice :=
thy
  Parameter s : Set.
  Parameter zero : s.
  Parameter join : s -> s -> s.
  Implicit Type x y z : s.
  Axiom commutative: forall x y,   join x y = join y x.
  Axiom associative: forall x y z, join (join x y) z = join x (join y z).
  Axiom idempotent:  forall x,     join x x = x.
  Axiom neutral:     forall x,     join x zero = x.
end.
\end{source}
  \caption{The theory of a semilattice}
  \label{fig:semilattice}
\end{figure}
%
The Kuratowski finite sets~$K(A)$ are the \emph{free} semilattice
generated by a set~$A$, where $\vee$ is union and $0$ is $\emptyset$.
This is formalized in RZ as shown in Figure~\ref{fig:kuratowski}.
%
\begin{figure}
\centering
\begin{source}
Definition Kuratowski (A : thy 
                              Parameter a : Set.
                           end) :=
thy
  include Semilattice.
  Parameter singleton : A.a -> s.
  Definition fin := s.
  Definition emptyset := zero.
  Definition union := join.

  Axiom initial :
    forall S : Semilattice, forall f : A.a -> S.s,
    exists1 g : fin -> S.s, 
      g emptyset = S.zero /\
        (forall x : A.a, f x = g (singleton x))/\
        (forall u v : fin, g (union u v) = S.join (g u) (g v)).
end.
\end{source}
  \caption{Kuratowski finite sets}
  \label{fig:kuratowski}
\end{figure}
%
The theory $\mathtt{K}$ is parametrized by a model~$\mathtt{A}$ which
contains a set~$a$. We wrote $\mathtt{emptyset}$ instead of~$0$ and
$\mathtt{union}$ instead of~$a$.

\internal{Andrej}{This section not finished yet.}


\subsection{Inductive types}
\label{sec:inductive-types}

We show how general inductive types can be expressed in RZ with
dependent sets.

\begin{figure}
  \centering
  \sourcefile{wtype.thy}
  \caption{General inductive types}
  \label{fig:wtype}
\end{figure}

\subsection{Axiom of choice}
\label{sec:axiom-choice}

In this example we show how RZ can help explain why a generally
accepted axiom is not constructively valid. Consider the Axiom of
Choice:
%
\sourcefile{choice.thy}
%
The output for the axiom of choice is
%
\begin{source}
val ac : (a -> b * ty_r) -> (a -> b) * (a -> ty_r)
(** Assertion ac =
    forall f:a -> b * ty_r,
      (forall (x:||a||),  let (p,q) = f x in p : ||b|| /\ r x p q) ->
      let (g,h) = ac f in (forall x:a, y:a,  x =a= y -> g x =b= g y) /\
      (forall (x:||a||),  r x (g x) (h x))
*)
\end{source}
%
In general we cannot hope to implement this because
$\iapp{\mathtt{ac}}{f}$ is supposed to compute a pair of functions
$(g,h)$, where~$g$ is extensional. Because~$f$ is not required to be
extensional, this is impossible in general.

The \emph{Intensional} Axiom of Choice allows the choice function
$\mathtt{c}$ to depend on the realizers:
%
\sourcefile{ichoice.thy}
%
This principle is related to Aczels's presentation
axiom~\cite{aczel:presentation} (discuss further). Now the output is
exactly the same as before \emph{except} for the requirement that the
choice function be continuous:
%
\begin{source}
val iac : (a -> b * ty_r) -> (a -> b) * (a -> ty_r)
(** Assertion iac =
    forall f:a -> b * ty_r,
      (forall (x:||a||),  let (p,q) = f x in p : ||b|| /\ r x p q) ->
      let (g,h) = iac f in (forall x:a,  x : ||a|| -> g x : ||b||) /\
      (forall (x:||a||),  r x (g x) (h x))
*)
\end{source}
%
The value $\mathtt{iac}$ can be easily implemented, e.g. with
%
\begin{source}
let iac f = (fun x -> fst (f x)), (fun x -> snd (f x))
\end{source}

\subsection{Modulus of Continuity}
\label{sec:we-show-modulus-of-continuity-example}

As a last example we show how certain constructive principles require
the use of computational effects. 

\sourcefile{modulus.thy}


%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "cie"
%%% End: 
