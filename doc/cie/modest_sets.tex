\section{Typed realizability}
\label{sec:typed-realizability}

RZ is based on \emph{typed realizability} by John
Longley~\cite{Longley99}.   This variant of realizability corresponds most
directly to programmers' intuition about implementations.

We motivate and explain typed realizability and its relationship to
real-world programming by way of example. Suppose we are asked to
design a data structure for the set $\mathcal{G}$ of all finite
simple%
\iflong
\footnote{At most one arrow between any two vertices.}
\fi % \iflong
directed graphs with vertices labeled by distinct integers. 
%
\iflong
An exemplar
directed graph~$G$ is shown in Figure~\ref{fig:digraph}.
%
\begin{figure}
  \centering
  \includegraphics[width=0.3\textwidth]{digraph}
  \caption{A finite directed graph $G$}
  \label{fig:digraph}
\end{figure}
\fi % \iffull
%
A common representation is a pair of lists $(\ell_V, \ell_A)$, where
$\ell_V$ is the list of vertex labels and $\ell_A$ is the \emph{adjacency list} 
representing the arrows by pairing the labels of each source and target%
\iflong
.
In our example,
\else % \iflong
, e.g.,
\fi % \iflong
%
$\ell_V = [1; 2;
3; 4]$ and $\ell_A = [(1,2); (2,2); (2,3); (3,2); (3;1)]$. Thus we
define the datatype of graphs to be\footnote{We use OCaml notation in
  which $\clist{t}$ classifies finite lists of elements of type~$t$, and
  $t_1 * t_2$ classifies pairs containing a value of type $t_1$ and and 
  value of type $t_2$.}
%
\begin{equation*}
  \ctype \mathtt{graph} = \clist{\cint} \ \ * \ \ \clist{(\cint * \cint)}
\end{equation*}
%
However, this is not a complete description of the representation, as
there would be representation invariants and conditions not expressed by the type, e.g.,
%
\begin{enumerate}
\item The order in which vertices and arrows are listed is not
  important%
\iflong
; for example, $[1;2;3;4]$ and $[4;1;2;3]$ represent the same vertices.\footnote{
  A different implementation with the same representation type could require
  that only sorted vertex lists are legal.}
\fi %\iflong
\item Each vertex and arrow must be listed exactly once.
\item The source and target of each arrow must appear in the list of vertices.
\end{enumerate}
%
Thus, to implement the mathematical set~$\mathcal{G}$, we must not
only decide on the underlying datatype $\mathtt{graph}$, but also
determine what values of that type represent which elements
of~$\mathcal{G}$.  As we shall see next, this can be expressed
either using a \emph{realizability relation} or a \emph{partial
  equivalence relation (per)}.

\subsection{Modest sets and pers}
\label{sec:modest-sets-pers}

We now define typed realizability as it
applies to OCaml. Other general-purpose programming languages could be
used instead, as long as they provide the usual ground types, product
and function types.\footnote{It is also convenient to work with a
language that supports sum types, as this allows a more natural
representation of disjoint unions.}

Let $\Type$ be the collection of all (non-parametric) OCaml types. To
each type $t \in \Type$ we assign the set $\values{t}$ of values of
type~$t$ that behave \emph{functionally} in the sense
of Longley~\cite{longley99when}. Such values are represented by terminating
expressions that do not throw exceptions or return different results
on different invocations.  They may \emph{use} exceptions,
store, and other computational effects, provided they appear
functional from the outside; a useful example using computational effects is
presented in Section~\ref{sec:we-show-modulus-of-continuity-example}.
Note also that a functional value with a function type may diverge as
soon as it is applied.   The collection $\Type$ with the assignment of functional
values $\values{t}$ to each $t \in \Type$ forms a \emph{typed partial
  combinatory algebra (TPCA)}, which provides a theoretical basis for
the definition of a realizability model that suits our needs.

Going back to our example, we see that an implementation of 
directed graphs $\mathcal{G}$ specifies a datatype
$\typeOf{\mathcal{G}} = \mathtt{graph}$ together with a
\emph{realizability relation} $\rz_{\mathcal{G}}$ between
$\mathcal{G}$ and $\values{\mathtt{graph}}$. The meaning of $(\ell_V,
\ell_A) \rz_\mathcal{G} G$ is ``OCaml value $(\ell_V, \ell_A)$ 
represents/realizes/implements graph $G$''. There are two natural conditions
that $\rz_\mathcal{G}$ ought to satisfy: (1) for every $G \in
\mathcal{G}$ there should be at least one realizer $(\ell_V, \ell_A)$
representing it, and (2) if $(\ell_V, \ell_A)$ represents both $G$ and
$G'$ then $G = G'$.%
\iflong
\footnote{The latter condition is called \emph{modesty} and
is not strictly necessary for the development of the theory, though 
programmers would naturally expect it to hold.}
\fi % \iflong
If
$(\ell_V, \ell_A)$ and $(\ell'_V, \ell'_A)$ represent the same graph 
(e.g., because $\ell_V$ is a permutation of $\ell'_V$, and similarly for $\ell_A$ and $\ell'_A$)
we say that they are \emph{equivalent} and write $(\ell_V, \ell_A)
\per_\mathcal{G} (\ell'_V, \ell'_A)$. The relation $\per_\mathcal{G}$
is a \emph{partial} equivalence relation (symmetric and transitive,
but not reflexive) because not every $(\ell_V, \ell_A) \in
\values{\mathtt{graph}}$ represents a graph.

\smallskip

A general definition is in order. A \emph{modest set} is a triple $A =
(\setOf{A}, \typeOf{A}, {\rz_A})$ where $\setOf{A}$ is the
\emph{underlying set}, $\typeOf{A} \in \Type$ is the \emph{underlying
  type}, and $\rz_A$ is a \emph{realizability relation} between
$\values{\typeOf{A}}$ and $\setOf{A}$, satisfying
% 
\begin{enumerate}
\item \emph{totality:} for every $x \in \setOf{A}$ there is $v \in
  \values{\typeOf{A}}$ such that $v \rz_A x$, and
\item \emph{modesty:} if $u \rz_A x$ and $u \rz_A y$ then $x = y$.
\end{enumerate}
%
The \emph{support} of $A$ is the set $\support{A} = \set{v \in
  \values{\typeOf{A}} \such \xsome{x}{\setOf{A}}{v \rz_A x}}$ of those
values that realize something. We define the relation $\per_A$ on
$\values{\typeOf{A}}$ by
%
\begin{equation*}
  u \per_A v
  \iff
  \some{x}{\setOf{A}}{u \rz_A x \land v \rz_A x} \;.
\end{equation*}
%
From totality and modesty of $\rz_A$ it follows that $\per_A$ is a per,
i.e., symmetric and transitive. Observe that $\support{A} = \set{v \in
  \values{\typeOf{A}} \such v \per_A v}$, whence $\per_A$
restricted to $\support{A}$ is an equivalence relation. In fact, we
may recover a modest set up to isomorphism from $\typeOf{A}$ and
$\per_A$ by taking $\setOf{A}$ to be the set of equivalence classes of
$\per_A$, and $v \rz_A x$ to mean $v \in x$.

The two views of implementations, as modest sets $(\setOf{A},
\typeOf{A}, {\rz_A})$, and as pers $(\typeOf{A}, {\per_A})$, are
equivalent.\footnote{And there is a third one, as a partial surjection
  $\delta_A : {\subseteq}\values{\typeOf{A}} \epito \setOf{A}$, with
  $\delta_A(v) = x$ when $v \rz_A x$. This is how realizability is
  presented in Type Two Effectivity~\cite{Wei00}.} In RZ we use pers
because they refer only to types and values, as opposed to arbitrary
sets. Nevertheless, it is useful to understand how modest sets and
pers arise from natural programming practice.

Modest sets form a category whose objects are modest sets and
morphisms are the realized functions. A \emph{realized function} $f :
A \to B$ is a function $f : \setOf{A} \to \setOf{B}$ for which there
exists $v \in \values{\typeOf{A} \to \typeOf{B}}$ such that, for all
$x \in \setOf{A}$ and $u \in \typeOf{A}$,
%
\iflong
\begin{equation}
\else %\iflong
$
\fi %\iflong
  \label{eq:rz-function-space}
  u \rz_A x \implies v\;u \rz_B f(x) \;.
\iflong
\end{equation}
\else % \iflong
$
\fi
%
This condition is just a mathematical expression of the usual idea
that~$v$ is an implementation of~$f$ if it does to realizers
what~$f$ does to the elements they represent.

The equivalent category of pers has as objects pairs $A = (\typeOf{A},
{\per_A})$ where $\typeOf{A} \in \Type$ and $\per_A$ is a per on
$\values{\typeOf{A}}$. A morphism $A \to B$ is represented by 
a function $v\in \values{\typeOf{A} \to \typeOf{B}}$
\iflong
such that, for all $u, u'
\in \support{A}$,
%
\begin{equation}
  \label{eq:per-exponential}
  u \per_A u' \implies v\;u \per_B v\;u' \;.
\end{equation}
%
Values $v$ and $v'$ that both satisfy~\eqref{eq:per-exponential}
represent the same morphism if, for all $u, u' \in \support{A}$,
%
\begin{equation*}
  u \per_A u' \implies v\;u \per_B v'\;u' \;.
\end{equation*}
\else % \iflong
that maps equivalent arguments to equivalent results.
\fi % \iflong

\iflong
The category of modest sets has a very rich structure.
For example, we
may form a cartesian product $A \times B$ of modest sets $A$ and $B$
by
%
\begin{align*}
  \setOf{A \times B} &= \setOf{A} \times \setOf{B},\\
  \typeOf{A \times B} &= \typeOf{A} * \typeOf{B},\\
  p \rz_{A \times B} (x,y) &\iff
  \cfst{p} \rz_A x \land \csnd{p} \rz_B y.
\end{align*}
%
The projections $\pi_1 : A \times B \to A$ and $\pi_2 : A \times B \to
B$ are realized by $\mathtt{fst}$ and $\mathtt{snd}$, respectively.

The morphisms between modest sets~$A$ and~$B$ again form a modest set
$B^A$, also written as $A \to B$, called the \emph{exponential} of~$A$
and~$B$, with the underlying set
%
\begin{equation*}
  \setOf{B^A} =
  \set{f : \setOf{A} \to \setOf{B} \such \text{$f$ is a realized function}},
\end{equation*}
%
the underlying type
%
\begin{equation*}
  \typeOf{B^A} = \typeOf{A} \to \typeOf{B},
\end{equation*}
%
and the realizability relation $\rz_{B^A}$ defined
by~\eqref{eq:rz-function-space}. The evaluation map $e : B^A \times A
\to B$, $e(f,x) = f(x)$ is realized by OCaml application,
$\cfun{(u,v)}{u\;v}$. If a function $f : C \times A \to B$ is realized
by $v$, then its transpose $\tilde{f} : C \to B^A$, $\tilde{f}(z)(x) =
f(z,x)$, is realized by $\cfun{z\;x}{v \; (z,x)}$. This shows that the
category of modest sets is cartesian closed. In
Section~\ref{sec:transl-sets-terms} we review other canonical
constructions on modest sets.

\bigskip
\else % \iflong
\fi % \iflong


\iflong
As an example we consider the cyclic group on seven elements $(\ZZ_7,
0, {-}, {+})$. To implement the group, we must give a representation
of $\ZZ_7$ as a modest set~$Z = (\ZZ_7, \typeOf{Z}, {\rz_Z})$, and
provide realizers for the neutral element~$0$, negation~$-$, and
addition~$+$. 

One possibility is to choose $\cint$ as the underlying type $\typeOf{Z}$,
and to let $\support{Z}$ be only the integers \texttt{0} through \texttt{6}.
Then negation and addition must work modulo \texttt{7} (i.e., must return an integer in the
range \texttt{0}--\texttt{6} when given integers in this range).
The neutral element would be the integer constant \texttt{0}, and the
equivalence $\per_Z$ would be integer equality.

Alternatively, we could take $\cint$ as the underlying type
$\typeOf{Z}$, but let $\support{Z}$ include all integers. In this
case, negation and addition could be simply integer addition and
negation\footnote{Taking care to prevent integer
  overflow.}. Here the neutral element could be implemented as any
integer multiple of \texttt{7}, and the equivalence $\per_Z$ would be
equivalence-modulo-7.

Both of these modest sets happen to have \emph{decidable equality},
i.e., the characteristic map $\mathrm{eq} : \ZZ_7 \times
\ZZ_7 \to \set{\mathtt{false}, \mathtt{true}}$ of equality can be 
realized, by code for integer equality and code for integer equivalence-modulo-7
respectively.
\else
A modest set $A$ has \emph{decidable equality},
i.e., the characteristic map $\mathrm{eq} : A \times
A \to \set{\mathtt{false}, \mathtt{true}}$ of equality can be 
realized.
\fi % \iflong
%
Not all modest sets have decidable
equality.  Examples include implementations of semigroups with an undecidable word
problem~\cite{post47:_recur_unsol_probl_thue}%
\iflong
, implementations of computable sets of integers (which might be realized by
membership functions of type $\cint\to\cbool$),
\fi
and implementations of computable real numbers (which might be realized
by infinite Cauchy sequences).  Every modest set induces a partial equivalence relation, but there is no
presupposition that this equivalence is computable (implementable).

We can require decidable equivalence
by adding an axiom that any two elements are either equivalent
or not equivalent; see Section~\ref{sec:decidable-sets}.

\iflong\else\goodbreak\fi

\subsection{Interpretation of logic}
\label{sec:interpretation-logic}

In the realizability interpretation of logic, each formula~$\phi$ is
assigned a set of \emph{realizers}, which can be thought of as
computations that witness the validity of~$\phi$. The situation is
somewhat similar, but not equivalent, to the propositions-as-types
translation of logic into type theory, where the proofs of a
proposition correspond to terms of the corresponding type. More
precisely, to each formula~$\phi$ we assign an underlying type
$\typeOf{\phi}$ of realizers, but unlike in the propositions-as-types
translation, not all terms of type $\typeOf{\phi}$ are necessarily
valid realizers for~$\phi$, and some terms that are realizers may not
correspond to any proofs, for example, if they denote partial
functions or use computational effects.

We write $t \rz \phi$ when $t \in \values{\typeOf{\phi}}$ is a
realizer for~$\phi$. The underlying types and the realizability
relation~$\rz$ are defined inductively on the structure of~$\phi$; an
outline is shown in Figure~\ref{fig:rz-logic}. We say that a
formula~$\phi$ is \emph{valid} if it has at least one realizer.
%
\begin{figure*}
  \textbf{Underlying types of realizers:}
  \begin{xalignat*}{2}
    \typeOf{\itrue} &= \mathtt{unit} &
    \typeOf{\ifalse} &= \mathtt{unit} \\
    \typeOf{\iequal{x}{y}} &= \mathtt{unit} &
    \typeOf{\iand{\phi}{\psi}} &= \oprod{\typeOf{\phi}}{\typeOf{\psi}} \\
    \typeOf{\iimply{\phi}{\psi}} &= \oarrow{\typeOf{\phi}}{\typeOf{\psi}} &
    \typeOf{\ior{\phi}{\psi}} &=
    \osumtyx{\mathtt{or}_1}{\typeOf{\phi_1}}{\mathtt{or}_2}{\typeOf{\phi_2}} \\
    \typeOf{\iforall{x}{A}{\phi}} &= \oarrow{\typeOf{A}}{\typeOf{\phi}} &
    \typeOf{\iexists{x}{A}{\phi}} &= \oprod{\typeOf{A}}{\typeOf{\phi}}
  \end{xalignat*}
  \textbf{Realizers:}
  \begin{align*}
    () \rz \itrue & \\
    () \rz \iequal{x}{y}
    &\quad\text{iff}\quad 
    x = y
    \\
    (t_1,t_2) \rz \iand{\phi}{\psi}
    &\quad\text{iff}\quad
    \text{$t_1 \rz \phi$ and $t_2 \rz \psi$}
    \\
    t \rz \iimply{\phi}{\psi}
    &\quad\text{iff}\quad
    \text{for all $u \in \typeOf{\phi}$, if $u \rz \phi$ then $t\,u
      \rz \psi$}
    \\
    \oinj{\mathtt{or}_1}{t} \rz \ior{\phi}{\psi}
    &\quad\text{iff}\quad
    \text{$t \rz \phi$}
    \\
    \oinj{\mathtt{or}_2}{t} \rz \ior{\phi}{\psi}
    &\quad\text{iff}\quad
    \text{$t \rz \psi$}
    \\
    t \rz \iforall{x}{A}{\phi(x)}
    &\quad\text{iff}\quad
    \text{for all $u \in \typeOf{A}$, if $u \rz_A x$ then $t\,u \rz \phi(x)$}
    \\
    (t_1, t_2) \rz \iexists{x}{A}{\phi(x)}
    &\quad\text{iff}\quad
    \text{$t_1 \rz_A x$ and $t_2 \rz \phi(x)$}
  \end{align*}
  \caption{Realizability interpretation of logic (outline)}
  \label{fig:rz-logic}
\end{figure*}

In classical mathematics, a predicate on a set~$X$ may be viewed as a
subset of~$X$ or a (possibly non-computable) function $X \to \oProp$,
where $\oProp = \set{\ofalse, \otrue}$ is the set of truth values.
Accordingly, since in realizability propositions are witnessed by
realizers, a predicate~$\phi$ on a modest set~$A$ may be viewed as a
subset of $\setOf{A} \times \values{\typeOf{\phi}}$, or a (possibly
non-computable) function $\setOf{A} \times \values{\typeOf{\phi}} \to
\set{\ofalse, \otrue}$. In terms of pers, which is what RZ uses, a
predicate~$\phi$ on a per~$A = (\typeOf{A}, {\per_A})$ is a (possibly
non-computable) function $\phi : \values{\typeOf{A}} \times
\values{\typeOf{\phi}} \to \oProp$ that is
%
\begin{itemize}
\item \emph{strict:} if $\phi(u,v)$ then $u \in \support{A}$, and
\item \emph{extensional:} if $\phi(u_1,v)$ and $u_1 \per_A u_2$ then
  $\phi(u_2,v)$.
\end{itemize}

We illustrate how the realizability interpretation extracts the
computational content of a proposition. To make an interesting
example, suppose we already implemented the structure of real
numbers~$\RR$ as a modest set~$R = (\RR, \mathtt{real}, {\rz_R})$, and
consider the statement that every cubic $x^3 + a x + b$ has a root,
%
\begin{equation}
  \label{eq:square-root}%
  \iforall{a}{R}{\iforall{b}{R}{\iexists{x}{R}{\iequal{x^3 + a x + b}{0}}}}.
\end{equation}
%
By computing according to Figure~\ref{fig:rz-logic}, we find out that
a realizer is a value~$r$ of type
$\oarrow{\mathtt{real}}{\oarrow{\mathtt{real}}{\oprod{\mathtt{real}}{\mathtt{unit}}}}$
such that, whenever $t$ realizes $a \in \RR$ and $u$ realizes $b \in
\RR$, then $\oapp{\oapp{r}{t}}{u} = (v, w)$ with $v$ realizing a real
number~$x$ such that $x^3 + a x + b = 0$, and $w$ is trivial. This
can be ``optimized'' to a realizer of type
$\oarrow{\mathtt{real}}{\oarrow{\mathtt{real}}{\mathtt{real}}}$ that
does not bother to compute~$w$. In essence then, a realizer~$r$
for~\eqref{eq:square-root} computes a root of the cubic equation. Note
that $r$ is \emph{not} extensional, i.e., different realizers~$t$
and~$u$ for the same~$a$ and~$b$ may result in different roots of the
cubic. To put this in another way, $r$ realizes a \emph{multi-valued}
function\footnote{The multi-valued nature of the realizer comes from
  the fact that it computes \emph{any one} of many values, not that it
  computes \emph{all} of the many values.} rather than a modest set
morphism. It is well known in computable mathematics that certain
operations, such as equation solving, are only computable if we allow
them to be multi-valued. They arise naturally in RZ as translations of
$\forall\exists$~statements.

There are propositions whose realizers are ``irrelevant'' or free of
computational content. For example, realizers for $\itrue$ and
equality have type $\ounit$. Another example is a negation
$\inot{\phi}$, which is defined to be the same as
$\iimply{\phi}{\ifalse}$, whose realizers have type
$\oarrow{\typeOf{\phi}}{\ounit}$. Such realizers do not compute
anything useful, and we may as well throw them away. Sometimes only a
part of a realizer is computationally irrelevant, as we saw in the
last example. Propositions that are free of computational content
are characterized as the \emph{$\lnot\lnot$-stable propositions}. A
proposition~$\phi$ is said to be $\lnot\lnot$-stable, or just
\emph{stable} for short, when $\iimply{\inot{\inot{\phi}}}{\phi}$ is
valid. Any \emph{negative} proposition, i.e., one built from $\itrue$,
$\ifalse$, $=$, $\land$, $\Rightarrow$ and $\forall$ is stable, but
there may be other propositions that are stable and are not written
in the negative form.

\iflong
It would be unproductive to bother the programmer with requirements
for useless code.  On input, RZ allows users to specify that  
predicates will have no computational content.  On output, extracted
realizers also go through a \emph{thinning} phase, see Section~\ref{sec:translation}, which
optimizes away references to irrelevant realizers.
\fi

\subsection{Uniform families of modest sets}
\label{sec:uniform-families}

Many structures are naturally viewed as families of sets, or sets
depending on parameters, or \emph{dependent types} as they are called
in type theory. For example, the $n$-dimensional Euclidean space
$\RR^n$ depends on the dimension $n \in \NN$, the Banach space
$\mathcal{C}([a,b])$ of uniformly continuous real functions on the
closed interval $[a,b]$ depends on $a, b \in \RR$ such that $a < b$,
etc. In general, a family of sets $\family{A_i}{i \in I}$ is an
assignment of a set $A_i$ to each $i \in I$ from an \emph{index
  set}~$I$.

In the category of modest sets the appropriate notion is that of a
\emph{uniform} family~$\family{A_i}{i \in I}$, which is an assignment
of a modest set $A_i = (\setOf{A_i}, \typeOf{A}, {\rz_{A_i}})$ to each
$i \in \setOf{I}$, where $I$ is an index modest
set~\cite[6.3]{JacobsB:cltt}. The uniformity comes from the
requirement that all the~$A_i$'s share the same underlying
type~$\typeOf{A_i} = \typeOf{A}$. It is a desirable restriction from
the implementation point of view, because it removes dependencies at
the level of types. Note also that there is no dependency on the
realizers, only on the elements of the underlying set.

We may express uniform families in terms of pers, just as for
predicates. A uniform family $\family{A_i}{i \in I}$ of pers indexed
by a per~$I$ is given by an underlying type $\typeOf{A}$ and a family
of pers $(\per_{A_i})_{i \in \values{\typeOf{I}}}$ that is
% 
\begin{itemize}
\item \emph{strict:} if $u \per_{A_i} v$ then $i \in \support{I}$, and
\item \emph{extensional:} if $u \per_{A_i} v$ and $i \per_I j$ then $u
  \per_{A_j} v$.
\end{itemize}
%
A morphism $f : \family{A_i}{i \in I} \to \family{B_i}{i \in I}$ is a
family $\family{f_i : \setOf{A_i} \to \setOf{B_i}}{i \in I}$ of
uniformly realized maps, which means that there exists $u \in
\values{\typeOf{I} \to \typeOf{A} \to \typeOf{B}}$ such that,
%
\begin{equation*}
  v \rz_I i \land w \rz_{A_i} x \implies u\; v \; w \rz_{B_i} f_i(x)
\end{equation*}
%
for all $i \in I$, $v \in \values{\typeOf{I}}$, $x \in \setOf{A_i}$,
and $w \in \values{\typeOf{A}}$.

\iflong
We may form the \emph{sum} $\depsum{i \in I}{A_i}$ of a uniform family
$\family{A_i}{i \in I}$ as
%
\begin{align*}
  \setOf{\depsum{i \in I}{A_i}} &=
  \set{\pair{i,x} \such i \in \setOf{I} \land x \in \setOf{A_i}}
  \\
  \typeOf{\depsum{i \in I}{A_i}} &=
  \typeOf{I} \times \typeOf{A}
  \\
  (u,v) \rz_{\depsum{i \in I}{A_i}} (i,x)
  &\iff
  u \rz_I i \land v \rz_{A_i} x
\end{align*}
%
and the \emph{product} $\depprod{i \in I}{A_i}$ as
%
\begin{align*}
  \setOf{\depprod{i \in I}{A_i}} &=
  \set{f : \setOf{I} \to {\textstyle \bigcup_{i \in \setOf{I}} \setOf{A_i}} \such
    \xall{i}{\setOf{I}}{f(i) \in \setOf{A_i}}}
  \\
  \typeOf{\depprod{i \in I}{A_i}} &=
  \typeOf{I} \to \typeOf{A}
  \\
  u \rz_{\depprod{i \in I}{A_i}} f
  &\iff
  \xall{i}{I}{\all{v}{\values{\typeOf{I}}}{
      v \rz_I i \implies
      u \; v \rz_{A_i} f(i)
    }}.
\end{align*}
%
These constructions allow us to interpret (extensional) dependent type
theory in the category of modest sets.
\else
We can also form the \emph{sum} $\depsum{i \in I}{A_i}$ or
\emph{product} $\depprod{i \in I}{A_i}$ of
a uniform family, allowing an interpretation of (extensional) dependent type
theory in the category of modest sets.
\fi

\iflong
As an example of a uniform family we consider the cyclic group
$(\ZZ_n, 0, {-}, {+})$ of order~$n$. To keep things simple, we assume
that~$n$ ranges over natural numbers that can be represented by
type~$\cint$ (i.e., $\typeOf{N}=\cint$), and that 
$v \rz_N n \iff v = n$.
%
The uniform family $\family{Z_n}{n \in N}$ is then like the cyclic group of order~$7$, with $7$ replaced by~$n$:
%
\begin{align*}
  & \setOf{Z_n} = \ZZ_n = \set{0, 1, \ldots, n - 1}
  \\
  & \typeOf{Z_n} = \cint
%  \\
%  & v \rz_{Z_n} k \iff v \mathbin{\mathrm{mod}} n = k
\end{align*}
%
Negation would now be specified as a constant of dependent type
$\Pi_{n{:}N}. \ZZ_n\to\ZZ_n$.  Its realizer \texttt{neg}
would then have type $\typeOf{N}\to\typeOf{\ZZ_n}\to{\typeOf{\ZZ_n}}$,
i.e., $\cint\to\cint\to\cint$, so that $\mathtt{neg}(n)$ would
be a realizer for negation on $\ZZ_n$.   The realizer for addition would
similarly take an extra argument $n$.  

Any of the implementations suggested for $\ZZ_7$ would work here, with
$7$ replaced by the parameter $n$; in one case we would have
$v \rz_{Z_n} k \iff v = k$ and in the other
$v \rz_{Z_n} k \iff v \mathbin{\mathrm{mod}} n = k$.
\fi % \iflong


%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "cie"
%%% End: 
