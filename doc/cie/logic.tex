% ASCII syntax
\iffalse
\newcommand{\ip}{p}
\newcommand{\ix}{x}
\newcommand{\is}{s}
\newcommand{\ie}{e}
\newcommand{\iP}{P}
\newcommand{\iS}{S}
\newcommand{\iprop}{\mathtt{prop}}
\newcommand{\itrue}{\mathtt{true}}
\newcommand{\ifalse}{\mathtt{false}}
\newcommand{\inot}[1]{\mathtt{not}\,#1}
\newcommand{\iimply}[2]{#1\,\mbox{\texttt{->}}\,#2}
\newcommand{\iiff}[2]{#1\,\mbox{\texttt{<->}}\,#2}
\newcommand{\iequal}[2]{#1\,\mathtt{=}\,#2}
\newcommand{\iands}[2]{#1\,\mathtt{/\backslash}\, #2}
\newcommand{\iors}[2]{#1\,\mathtt{\backslash/}\,#2}
\newcommand{\iforall}[3]{\texttt{forall}\,#1\,\texttt{:}\,#2\texttt{,}\ #3}
\newcommand{\iexists}[3]{\texttt{exists}\,#1\,\texttt{:}\,#2\texttt{,}\ #3}
\newcommand{\iunique}[3]{\texttt{unique}\,#1\,\texttt{:}\,#2\texttt{,}\ #3}
\newcommand{\ilambda}[3]{\texttt{lambda}\,#1\,\texttt{:}\,#2\texttt{,}\ #3}
\newcommand{\iapps}[3]{#1\ #2\,\cdots\,#3}

\newcommand{\ituples}[2]{\texttt{(}#1\texttt{,}\ldots\texttt{,}#2\texttt{)}}
\newcommand{\iproj}[2]{#1\texttt{.}#2}
\newcommand{\iconstrain}[2]{#1\,\texttt{:}\,#2}
\newcommand{\ithe}[3]{\texttt{the}\,#1\,\texttt{:}\,#2\texttt{,}\, #3}
\newcommand{\ilet}[3]{\texttt{let}\,#1\,\texttt{=}\,#2\,\texttt{in}\, #3}
\newcommand{\iquot}[2]{#1\,\texttt{\%}\,#2}
\newcommand{\iletquot}[4]{\texttt{let}\ #1\texttt{\%}\,#2\,\texttt{=}\,#3\ \texttt{in}\ #4}
\newcommand{\irz}[1]{\texttt{rz}\,#1}
\newcommand{\iletrz}[3]{\texttt{let}\ \texttt{rz}\,#1\,\texttt{=}\,#2\ \texttt{in}\ #3}

\newcommand{\iprods}[2]{#1\,\texttt{*}\cdots\texttt{*}\,#2}
\newcommand{\isums}[2]{#1\,\texttt{+}\cdots\texttt{+}\,#2}
\fi

% Spiffed up syntax using mathematical symbols
\newcommand{\ip}{\varphi}
\newcommand{\ipp}{\rho}
\newcommand{\ix}{x}
\newcommand{\is}{s}
\newcommand{\ie}{e}
\newcommand{\iP}{p}
\newcommand{\iS}{\alpha}
\newcommand{\itrue}{\top}
\newcommand{\ifalse}{\bot}
\newcommand{\inot}[1]{\lnot #1}
\newcommand{\iimply}[2]{#1\Rightarrow #2}
\newcommand{\iiff}[2]{#1 \Leftrightarrow #2}
\newcommand{\iequal}[2]{#1 = #2}
\newcommand{\iand}[2]{#1\land #2}
\newcommand{\ior}[2]{#1\lor #2}
\newcommand{\iforall}[3]{\forall #1{:}#2.\ #3}
\newcommand{\iexists}[3]{\exists #1{:}#2.\ #3}
\newcommand{\iunique}[3]{\exists! #1{:}#2.\ #3}
\newcommand{\ilambda}[3]{\lambda #1{:}#2.\ #3}
\newcommand{\iapp}[2]{#1\ #2}

\newcommand{\ituple}[2]{(#1,\ldots,#2)}
\newcommand{\iproj}[2]{\mathop{\pi_{#2}} #1}
\newcommand{\iconstrain}[2]{#1:#2}
\newcommand{\ithe}[3]{\iota\,#1{:}#2{.}\, #3}
\newcommand{\ilet}[3]{\textsf{let}\,#1{=}#2\,\textsf{in}\, #3}
\newcommand{\ieclass}[2]{[#1]_{#2}}
\newcommand{\ileteclass}[4]{\textsf{let}\ [#1]_{#2}\,{=}#3\ \textsf{in}\ #4}
\newcommand{\irz}[1]{\textsf{rz}\,#1}
\newcommand{\iletrz}[3]{\textsf{let}\ \textsf{rz}\,#1\,{=}\,#2\ \textsf{in}\ #3}
\newcommand{\iinj}[2]{#1\,#2}
\newcommand{\imatches}[7]{\textsf{match}\,#1\,\textsf{with}\,\iinj{#2}{#3}\Rightarrow{#4}\,|\cdots|\iinj{#5}{#6}\Rightarrow{#7}}
\newcommand{\imatch}[7]{\textsf{match}\,#1\,\textsf{with}\,\iinj{#2}{#3}\Rightarrow{#4}\,|\,\iinj{#5}{#6}\Rightarrow{#7}}
\newcommand{\iselect}[2]{#1{.}#2}

\newcommand{\itag}{\mathit{tag}}
\newcommand{\iprod}[3]{#1{:}#2\times#3}
\newcommand{\isum}[4]{#1{:}#2+#3{:}#4}
\newcommand{\iquot}[2]{#1{\bigm/} #2}
\newcommand{\isubset}[3]{\{\,#1{:}#2\ |\ #3\,\}}

\newcommand{\iDefinition}[2]{\mathsf{Definition}\ #1\ :=\ #2.}
\newcommand{\iParameter}[2]{\mathsf{Parameter}\ #1\ : #2.}
\newcommand{\iAxiom}[2]{\mathsf{Axiom}\ #1\ : #2.}
\newcommand{\ipt}{\tau}
\newcommand{\ik}{\kappa}
\newcommand{\idarrow}[3]{(#1{:}#2){\to}#3}
\newcommand{\ite}{\theta}
\newcommand{\ith}{\Theta}
\newcommand{\iTH}{T}
\newcommand{\ithy}[1]{\mathsf{thy}\ #1\ \mathsf{end}}
\newcommand{\im}{M}
\newcommand{\iM}{m}
\newcommand{\il}{l}
\newcommand{\iSet}{\mathsf{Set}}
\newcommand{\iStable}{\mathsf{Stable}}
\newcommand{\iProp}{\mathsf{Prop}}
\newcommand{\iEquiv}[1]{\mathsf{Equiv}(#1)}
\newcommand{\ibar}{\ |\ }

\section{The Input Language}
\label{sec:input-language}

\begin{figure}[htbp]
\VerbatimInput{kuratowski.thy}
	\caption{caption}
	\label{fig:typicalinput}
\end{figure}


A RZ \emph{theory} is a generalized
logical signature with associated axioms, similar to a Coq module signature.
Theories are descriptions of \emph{models}, or implementations. The input is the
definition of one or more \emph{theories}; 
Figure~\ref{fig:typicalinput} shows a sample input for the RZ system. 
(RZ does not permit models to be written directly, but it does let you
assume that a model of a theory exists.)

The simplest theory $\ith$ is a list of \emph{theory element}\/s $\ite$. A theory element may specify that a certain set, set element, proposition or predicate, or model must exist (i.e.,
\textsf{Parameter} specifications). It may also provide a definition of a set, term, proposition, predicate, or theory (i.e., \textsf{Definition} specifications). Finally, a theory element can be
a named axiom that must hold. (i.e., \textsf{Axiom} specifications).

More complex theories can be parameterized by models (e.g., a theory of real numbers
can be written in terms of one unspecified but arbitrary model of the natural numbers);
in figure~\ref{fig:typicalinput} \texttt{Kuratowski} is a theory parameterized by a
model choosing an implementation of a single set.  For any such model $\im$, then,
$\mathtt{Kuratowski}(\im)$ is a theory describing a model of finite sets whose elements are
in the set $\iselect{\im}{\mathtt{a}}$.   Alternatively, a theory can describe a 
uniform family of models (e.g., a single model of real numbers written in terms of an arbitrary
model of the natural numbers); this would correspond to a single implementation that works for any 
model $\im$ satisfying the parameter theory.  In contrast, a parameterized theory permits
completely unrelated implementations for $\mathtt{Kuratowski}(\im_1)$ and $\mathtt{Kuratowski(\im_2)}$.}

As shown in in Figure~\ref{fig:typicalinput}, propositions and predicates
appearing in theories may use full first-order constructive logic, not just the
negative fragment. The grammar for logical inputs is shown in
Figure~\ref{fig:input}. Most of this should be familiar, including the use of
lambda abstraction are to define predicates.

The language of sets is rich, going well beyond the type systems of typical
programming languages. In addition to any base sets postulated in a theory, one
can construct dependent cartesian products and dependent function spaces. We
also supports disjoint unions (with labeled tags), quotient spaces (a set
modulo an equivalence relation), subsets (elements of a set satisfying a
predicate). RZ even permits explicit references to sets of realizers.

The term language follows the structure of the set level by providing
introduction and elimination constructs. For product sets we have tuples and
projections ($\iproj{\ie}{1}$, $\iproj{\ie}{2}$, \ldots), and for function spaces we have lambda abstractions and
application. One can inject a term into a tagged dependent union, or do case analyses
on the members of a union. We can produce the equivalence class of a given
term, or pick a representative of a given equivalence class (as long as what we
do with it does not depend on the particular representative). Very similarly,
we can produce the set of realizers for a term, or choose a representative from
a given set of realizers (as long as what we do with it does not depend on the
particular representative). We can inject a term into a subset (if it satisfies
the appropriate predicate), or project an element of a subset into the
enclosing set. Finally, the term language also allows local definitions of term
variables, and definite descriptions (as long as there is a unique element
satisfying the predicate in question).

From the parenthesized qualifiers in the previous paragraph, it is clear that checking the
well-formedness of terms is not decidable. RZ checks what it can, but does not
attempt any serious theorem proving.  Uncheckable constraints remain as
explicitly-marked \emph{obligations} in the final output, and must be verified
by other means; the output can then be trusted to the extent that the obligations are satisfied.



\begin{figure}
	\[
	\begin{array}{rl@{\qquad}l}
		\noalign{\textbf{Propositions/Predicates}}
		\ip,\ipp ::= 
		    & \iP\ |\ \iselect{\im}{\iP}&\mbox{Predicate/proposition names}\\
		  | & \itrue \ | \ \ifalse\ |\ \inot{\ip}\ |\ \iand{\ip}{\ip}\ |\ 
		       \ior{\ip}{\ip}\ | \ \iimply{\ip}{\ip}\ |\ \iiff{\ip}{\ip} & \mbox{Predicate logic}\\
		  | & \ilambda{\ix}{\is}{\ip} \ |\ \iapp{\ip}{\ie} & \mbox{Predicates and application}\\
		  | & \iequal{\ie}{\ie} & \mbox{Term equality}\\
		  | & \iforall{\ix}{\is}{\ip} \ |\ 
		      \iexists{\ix}{\is}{\ip} \ |\
		      \iunique{\ix}{\is}{\ip} & \mbox{Term quantifiers}\\[5pt]
		
		\noalign{\textbf{Sets}}
		\is ::= 
		    & \iS \ |\ \iselect{\im}{\iS} &\mbox{Set names}\\
		  | & ()\ |\ \iprod{\ix}{\is_1}{\is_2} &\mbox{Unit and cartesian product}\\
		  | & \isum{\il_1}{\is_1}{\il_2}{\is_2} &\mbox{Disjoint union}\\
		  | & \ilambda{\ix}{\is_1}{\is_2}\ |\ 
		      \iapp{\is}{\ie} &\mbox{Dependent set and application}\\
		  | & \iquot{\is}{\ipp} & \mbox{Set quotient by an equivalence relation}\\
		  | & \isubset{\ix}{\is}{\ipp} & \mbox{Subset satisfying a predicate}\\
		  | & \irz{\is}&\mbox{Realizers of a set}\\[5pt] 
		
		\noalign{\textbf{Terms}}	
		\ie ::=
		    & \ix\ |\ \iselect{\im}{\ix} &\mbox{Term names}\\
		  | & \ilambda{\ix}{\is_1}{\ie}\ |\ 
		      \iapp{\ie_1}{\ie_2} &\mbox{Function and application}\\
		  | & \ituple{\ie_1}{\ie_2} 
		      \ibar \iproj{\ie}{n}&\mbox{Tuple and projection}\\
		  | & \iinj{\il}{\ie} 
		      \ibar (\imatch{\ie_0}{\il_1}{\ix_1}{\ie_1}{\il_2}{\ix_2}{\ie_2})&\mbox{Injection and projection from a union}\\
		  | & \ieclass{\ie}{\ipp}
		      \ibar \ileteclass{\ix}{\ipp}{\ie_1}{\ie_2}&\mbox{Equivalence class and picking a representative}\\
		  | & \irz{\ie}
		      \ibar \iletrz{\ix}{\ie_1}{\ie_2}&\mbox{Realized value and picking a realizer}\\
		  | & \iconstrain{\ie}{\is}&\mbox{Type coercion (e.g., in or out of a subset)}\\
		  | & \ithe{\ix}{\is}{\ip}&\mbox{Definite description}\\
		  | & \ilet{\ix}{\ie_1}{\ie_2}&\mbox{Local definition}\\[5pt]
		
		\noalign{\textbf{Models}}		
		\im ::= 
		    & \iM \ |\ \iselect{\im}{\iM}&\mbox{Model names}\\
		  | & \iapp{\im_1}{\im_2}&\mbox{Application of parameterized model}\\[5pt]
		
		\noalign{\textbf{Proposition Kinds}}
		\ipt ::=
		    & \iProp & \mbox{Classifier for propositions}\\
		    & \iStable & \mbox{Classifier for stable propositions}\\
		    & \iEquiv{\is} &\mbox{Classifier for equivalence relations}\\
		    & \idarrow{\ix}{\is}{\ipt} & \mbox{Classifier for a predicate/relation}\\[5pt] 
		
		\noalign{\textbf{Set Kinds}}
		\ik ::= 
		    & \iSet &\mbox{Classifier for a proper set}\\
		   | & \idarrow{\ix}{\is}{\ik} &\mbox{Classifier for a dependent set}\\[5pt]
		

		\noalign{\textbf{Theory Elements}}
		\ite ::=
		     & \iDefinition{\ix}{\ie}&\mbox{Name for a term}\\
		   | & \iDefinition{\iS}{\is}&\mbox{Name for a set}\\
		   | & \iDefinition{\iP}{\ip}&\mbox{Name for a proposition/predicate}\\
		   | & \iDefinition{\iTH}{\ith}&\mbox{Name for a theory}\\
		   | & \iParameter{\ix}{\is}&\mbox{Require an element in the given set}\\
		   | & \iParameter{\iS}{\ik}&\mbox{Require a set of the given kind}\\
		   | & \iParameter{\iP}{\ipt}&\mbox{Require a proposition/predicate of the given sort}\\
		   | & \iParameter{\iM}{\ith}&\mbox{Require a model of the given theory}\\
		   | & \iAxiom{\iP}{\ip}&\mbox{Axiom that must hold}\\[5pt]

  		\noalign{\textbf{Theory}}
		\ith ::= 
		     & \iTH\\
%		   | & \iselect{\im}{\iTH}\\
		   	| & \ithy{\ite_1,\ldots,\ite_n}\\
		 	| & \idarrow{\iM}{\ith_1}{\ith_2} &\mbox{Theory of a uniform family of models}\\
		  	| & \ilambda{\iM}{\ith_1}{\ith_2}\ |\ 
		      \iapp{\ith}{\iM}\\
	\end{array}
	\]
	\label{fig:input}
	\caption{Input Syntax (Simplified)}
\end{figure}



Explain the input language and its semantics.



\internal{AB}{The plan here seems to be as follows. Before this
  section we will say that assertions are written in the negative
  fragment, and that in the input language we use constructive logic,
  which turns out to be more convenient. So just go ahead and
  introduce constructive logic without worrying what its
  interpretation might be. Then in the translation section we'll
  explain the realizability interpretation of constructive logic.
  Actually, the logic is first-order intuitionistic logic. The fact
  the the logic is intuitionistic is not a choice but reality: the
  interpretation does not validate the Law of Excluded Middle. This
  should be commented on.}


%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "cie"
%%% End: 
%!TEX root = cie

