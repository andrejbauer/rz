\section{Introduction}
\label{sec:introduction}

Given the constants, functions, relations, and axioms of a mathematical
structure, what qualifies as a correct and complete computer implementation?

For some familiar cases, the answer is obvious. Code implementing a group must
have a type to represent the group elements, as well as a constant, a unary
operator, and a binary operator, each satisfying appropriate axioms (the
constant is the neutral element, the unary operator computes inverses, and that
the binary operator is associative).

But for more interesting structures, especially those arising in
mathematical analysis, the answer is much less obvious. How do we
implement the real numbers (a Cauchy-complete Archimedean ordered
field), or a compact metric space, or a space of smooth functions?
Significant research goes into finding representations that provide a
satisfactory theory of computability on such
structures~\cite{Wei00,TZ98,Bla97,EL00}, and implementations of exact
real arithmetic~\cite{Mue00,Lam05a} show that the theory can be put
into practice quite successfully.

The theory of realizability provides guidance in development of
computable mathematics.   We show that, in addition to being a
fundamental tool in logic and theory of computability, realizability
has direct application to the design and implementation of programs.
It can be used to find a description of the data structure directly
corresponding to a mathematical specification.

Unfortunately, extracting code interfaces by hand from mathematical axioms
quickly grows tedious. Worse, different but logically equivalent sets of axioms
correspond to different, although interdefinable, interfaces for code. One
might want to compare several variations, since some interfaces can be more
useful than others in practice.

And few programmers --- even those with strong backgrounds in
mathematics and classical logic --- are familiar with constructive logic or
realizability. Programmers are more familiar with language constructs
describing interfaces (e.g., C++ header files, ML signatures, or Java
interfaces) and logical assertions (e.g., preconditions
and postconditions).

\bigskip

We have therefore implemented a system, called RZ, to serve as a bridge between
the logical world and the programming world. RZ automatically translates
specifications in constructive logic into actual interface code in a
programming language (currently Objective Caml~\cite{ocaml}, but we are
considering other languages as well).

The constructive part of the original specification turns into interface code
listing types and values that must exist in an implementation. The remainder of
the specification is maintained as assertions about these types and values.
Because these assertions have no computational content, they can be interpreted
constructively or classically equally well, and in particular make equal sense
to programmers (and mathematicians) who are more comfortable thinking in
classical logic.

\bigskip

RZ was specifically designed as a lightweight system. Although the
realizability translation can be extended to transforming complete
proofs into complete code~\cite{komagata+:tr95}, we have not
implemented this. Other systems, including Coq~\cite{coqart}, already
perform this task well.

But Coq works best when the entire task (from specification to code
generation) is performed within the same system. In contrast, the
interfaces generated by RZ can be implemented in any fashion, as long
as the assertions are satisfied. Code can be written by hand ---
allowing imperative, concurrent, and other arbitrary language
features, not just a ``functional'' subset. Or, the system could
generate a Coq interface as an \emph{input}, where the distinction
between computational (Set) and non-computational (Prop) is
automatically determined, and a corresponding implementation can be
provided through logical techniques.


\internal{AB}{from here on the introduction seems ``undone''}

The RZ system translates this to the language understood by many
programmers (typed interfaces with assertions in classical logic)

\bigskip

In this paper we show how RZ makes practical use of realizability and
other theoretical techniques, and provide some interesting motivational
examples.


%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "cie"
%%% End: 
