\section{Introduction}
\label{sec:introduction}

Given a description of a mathematical structure (constants,
functions, relations, and axioms), what should a computer
implementation look like?

For many simple cases, the answer is obvious. A
group would have a type whose values represent group elements, as well
as a binary operation that is associative, a constant 
neutral element, and a unary inverse operator.

But for more interesting structures, especially those arising in
mathematical analysis, the answer is much less obvious. How do we
implement the real numbers (a Cauchy-complete Archimedean ordered
field)? Or, design the operations supported by a compact metric
space or a space of smooth functions? Significant research goes into
finding representations that provide a satisfiedisfactory theory of
computability on such structures~\cite{Wei00,TZ98,Bla97,EL00}, and
implementations of exact real arithmetic~\cite{Mue00,Lam05a} show that
the theory can be put into practice quite successfully.

The theory of realizability provides guidance in development of
computable mathematics.  Our work shows that realizability is
not only  a
fundamental tool in logic and computability, but also
has direct application to the design and implementation of programs:
it can produce a description of the data structure (a code interface)
directly corresponding to a mathematical specification.

However, doing this by hand quickly grows tedious. Worse, different
but logically equivalent sets of axioms correspond to different,
although interdefinable, interfaces for code; one might then want to
compare several variations, since some interfaces will be more useful
than others in practice.

And few programmers --- even those with strong backgrounds in
mathematics and classical logic --- are familiar with constructive logic or
realizability.  Programmers are used to language constructs
describing interfaces (e.g., C++ header files, ML signatures, or Java
interfaces) and logical assertions (e.g., preconditions
and postconditions).

%\bigskip

We have therefore implemented a system, called RZ, to serve as a
bridge between the logical world and the programming world.\footnote{RZ
  is publicly available for download at
  \url{http://math.andrej.com/rz/}, together with a longer version of
  this paper.} RZ translates specifications in
constructive logic into standard interface code in a programming
language (currently Objective Caml~\cite{ocaml}, but other languages
could be used).

The constructive part of the original specification turns into
interface code,
listing types and values to be implemented. The remainder of
the specification becomes assertions about these types and values.
Assertions have no computational content so their constructive
and classical meanings agree, and they can
be understood by programmers and mathematicians accustomed to
classical logic.

%\bigskip

RZ was designed as a lightweight system
supporting a rich input language. Although the
realizability translation can be extended to transforming complete
proofs into complete code~\cite{komagata+:tr95}, we have not
implemented this. Other systems, including Coq~\cite{coqart} and
Minlog~\cite{benl98:_proof_theor_work}, already have good support for
extracting programs from proofs. But they work best when the entire
task (from specification to code generation) is performed within the
same system. In contrast, the interfaces generated by RZ can be
implemented in any fashion, as long as the assertions are satisfied.
Code can be written by hand, using not just a ``purely functional'' subset
but imperative, concurrent, and other language features. At the other
extreme, the output of RZ can be viewed as a possible \emph{input} to
a program extraction tool, where the the distinction between
computational and non-computational parts (in Coq these are
$\mathtt{Set}$ and $\mathtt{Prop}$, respectively) has been
automatically determined; a corresponding implementation would then be
provided through theorem-proving and program extraction.

%\bigskip

The paper is organized as follows. In
Section~\ref{sec:typed-realizability} we present a version of
realizability which is most suitable for our purposes.
Sections~\ref{sec:input-language} and~\ref{sec:spec-sign-assert}
describe the input and the output language of RZ, while in
Section~\ref{sec:translation} we explain how RZ translates from one to
the other. Various implementation issues are discussed in
Section~\ref{sec:implementation}, and examples of RZ at work are shown
in Section~\ref{sec:examples}. We conclude with remarks on related
work in Section~\ref{sec:related-work}.


%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "cie"
%%% End: 
