\section{Introduction}
\label{sec:introduction}

\internal{Andrej}{I am actually quite happy with the introduction. It
  will appeal to constructive mathematicians. It will appeal to the
  Type Two Effectivity people when we tell them it's all Type Two
  Effectivity, anyhow. Then there is Coquand, who will probably say
  ``oh yes'' with a French accent, and will want to know exactly how
  it's different from Coq. The implementors of exact real arithmetic
  will like it if Iztok and I manage to implement something using RZ
  for the CCA conference. There won't be many PL people in Siena. I
  think we're fine. So I'd rather get the rest of the paper done. I
  don't think the introduction neds to be rewritten.}

Given the specification of a mathematical structure (constants,
functions, relations, and axioms), how do you know when a computer
implementation is both correct and complete?

For many simple cases, the answer is obvious. Code implementing a
group must have a type whose values represent group elements, as well
as a binary operation that is associative, a constant that is a
neutral element, and a unary operator that computes inverses.

But for more interesting structures, especially those arising in
mathematical analysis, the answer is much less obvious. How do we
implement the real numbers (a Cauchy-complete Archimedean ordered
field)? Or, what operations should be supported by a compact metric
space, or a space of smooth functions? Significant research goes into
finding representations that provide a satisfactory theory of
computability on such structures~\cite{Wei00,TZ98,Bla97,EL00}, and
implementations of exact real arithmetic~\cite{Mue00,Lam05a} show that
the theory can be put into practice quite successfully.

The theory of realizability provides guidance in development of
computable mathematics. We show that, in addition to being a
fundamental tool in logic and theory of computability, realizability
has direct application to the design and implementation of programs:
it can produce a description of the data structure (a code interface)
directly corresponding to a mathematical specification.

However, doing this by hand quickly grows tedious. Worse, different
but logically equivalent sets of axioms correspond to different,
although interdefinable, interfaces for code; one might then want to
compare several variations, since some interfaces will be more useful
than others in practice.

And few programmers --- even those with strong backgrounds in
mathematics and classical logic --- are familiar with constructive logic or
realizability.  Programmers are more familiar with language constructs
describing interfaces (e.g., C++ header files, ML signatures, or Java
interfaces) and logical assertions (e.g., preconditions
and postconditions).

%\bigskip

We have therefore implemented a system, called RZ, to serve as a bridge between
the logical world and the programming world. RZ automatically translates
specifications in constructive logic into actual interface code in a
programming language. (Currently we produce interfaces in 
Objective Caml~\cite{ocaml}, but other languages are possible
as well.)

The constructive part of the original specification turns into interface code
listing types and values that must exist in an implementation. The remainder of
the specification is maintained as assertions about these types and values.
Because these assertions have no computational content, they can be interpreted
either constructively or classically equally well, and in particular can
be understood by programmers (and mathematicians) who are more used to
classical logic.

%\bigskip

RZ was specifically designed as a lightweight system. Although the
realizability translation can be extended to transforming complete
proofs into complete code~\cite{komagata+:tr95}, we have not
implemented this. Other systems, including Coq~\cite{coqart} and
Minlog~\cite{benl98:_proof_theor_work}, already have good support for
extracting programs from proofs. But they work best when the entire
task (from specification to code generation) is performed within the
same system. In contrast, the interfaces generated by RZ can be
implemented in any fashion, as long as the assertions are satisfied.
Code can be written by hand, using not just a ``functional'' subset
but imperative, concurrent, and other language features. At the other
extreme, the output of RZ can be viewed as a possible \emph{input} to
a program extraction tool, where the the distinction between
computational and non-computational parts (in Coq these are
$\mathtt{Set}$ and $\mathtt{Prop}$, respectively) has been
automatically determined; a corresponding implementation would then be
provided through logical techniques.

%\bigskip

The paper is organized as follows. In
Section~\ref{sec:typed-realizability} we present a version of
realizability which is most suitable for our purposes.
Sections~\ref{sec:input-language} and~\ref{sec:spec-sign-assert}
describe the input and the output language of RZ, while in
Section~\ref{sec:translation} we explain how RZ translates from one to
the other. Various implementation issues are discussed in
Section~\ref{sec:implementation}, and examples of RZ at work are shown
in Section~\ref{sec:examples}. We conclude with remarks on related
work in Section~\ref{sec:related-work}.


%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "cie"
%%% End: 
