\section{Introduction}
\label{sec:introduction}

Given the specification of a mathematical structure (constants, functions, relations, and axioms), 
how do you know when a computer implementation is both correct and complete?

For many simple cases, the answer is obvious.  Code implementing a group must
have a type whose values represent group elements, as well as a binary operation that is associative,
a constant that is a neutral element, and a unary operator that computes inverses.

But for more interesting structures, especially those arising in
mathematical analysis, the answer is much less obvious.  How do we
implement the real numbers (a Cauchy-complete Archimedean ordered
field)?  Or, what operations should be supported by a compact metric space, 
or a space of smooth functions?
Significant research goes into finding representations that provide a
satisfactory theory of computability on such
structures~\cite{Wei00,TZ98,Bla97,EL00}, and implementations of exact
real arithmetic~\cite{Mue00,Lam05a} show that the theory can be put
into practice quite successfully.

The theory of realizability provides guidance in development of
computable mathematics.   We show that, in addition to being a
fundamental tool in logic and theory of computability, realizability
has direct application to the design and implementation of programs:
it can produce a description of the data structure (a code interface) directly
corresponding to a mathematical specification.

However, doing this by hand quickly grows tedious. Worse, different but logically equivalent sets of axioms
correspond to different, although interdefinable, interfaces for code; one
might then want to compare several variations, since some interfaces will be more
useful than others in practice.

And few programmers --- even those with strong backgrounds in
mathematics and classical logic --- are familiar with constructive logic or
realizability.  Programmers are more familiar with language constructs
describing interfaces (e.g., C++ header files, ML signatures, or Java
interfaces) and logical assertions (e.g., preconditions
and postconditions).

\bigskip

We have therefore implemented a system, called RZ, to serve as a bridge between
the logical world and the programming world. RZ automatically translates
specifications in constructive logic into actual interface code in a
programming language. (Currently we produce interfaces in 
Objective Caml~\cite{ocaml}, but other languages are possible
as well.)

The constructive part of the original specification turns into interface code
listing types and values that must exist in an implementation. The remainder of
the specification is maintained as assertions about these types and values.
Because these assertions have no computational content, they can be interpreted
either constructively or classically equally well, and in particular can
be understood programmers (and mathematicians) who are more used to
classical logic.

\bigskip

RZ was specifically designed as a lightweight system. Although the
realizability translation can be extended to transforming complete
proofs into complete code~\cite{komagata+:tr95}, we have not
implemented this. Other systems, including Coq~\cite{coqart}, already
have good support for extracting programs from proofs.

But Coq works best when the entire task (from specification to code
generation) is performed within the same system.  In contrast, the
interfaces generated by RZ can be implemented in any fashion, as long
as the assertions are satisfied. Code can be written by hand, using
not just a ``functional'' subset but imperative,
concurrent, and other language features.  At the other extreme, the output
of RZ can be viewed as a possible \emph{input} to Coq, where the
the distinction
between computational (\texttt{Set}) and non-computational (\texttt{Prop}) parts
has been automatically determined;
a corresponding implementation would then be
provided through logical techniques.



%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "cie"
%%% End: 
