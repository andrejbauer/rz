\section{Introduction}
\label{sec:introduction}

Given the constants, relations, and axioms of a mathematical
structure, what must a programmer do in order to implement that
mathematical structure?

For some familiar cases, the answer is obvious. Code implementing a
group must have a type to represent the group elements, a constant, a
unary operator, and a binary operator, each satisfying appropriate
axioms that guarantee the constant is the neutral element, the unary
operator computes inverses, and that the binary operator is
associative.

But for more interesting structures, especially those arising in
mathematical analysis, the answer is much less obvious. How do we
implement the real numbers (a Cauchy-complete Archimedean ordered
field), or a compact metric space, or a space of smooth functions?
Significant research goes into finding representations that provide a
satisfactory theory of computability on such
structures~\cite{Wei00,TZ98,Bla97,EL00}, and several implementations
of exact real arithmetic~\cite{Mue00,Lam05a} show that the theory can
be put into practice quite successfully.

The theory of realizability provides guidance in development of
computable mathematics. We show not only that realizability is a
fundamental tool in logic and theory of computability, but also that
it has direct application to the design and implementation of
programs. It can be used to find a description of the data structure
directly corresponding to a mathematical specification.

Extracting code interfaces by hand from mathematical axioms quickly
grows tedious, especially because different but logically equivalent
sets of axioms correspond to different, although interdefinable,
interfaces for code. One might want to see several of these, since
some interfaces can be more useful than others in practice.

And few programmers --- even those with solid backgrounds in
mathematics and logic --- are familiar with constructive logic or
realizability. Programmers are more familiar with language constructs
describing interfaces: C++ header files, ML signatures, Java
interfaces, and the like.

\bigskip

We have therefore implemented a system, called RZ, which serves as a
bridge between the logical world and the programming world. It
automatically translates specifications in constructive logic into
actual interface code in a programming language (currently Objective
Caml~\cite{ocaml}, but we are considering other languages as well). The
constructive part of the original specification turns into interface
code listing types and values that must exist in an implementation.

The remainder of the specification is maintained as assertions about
these types and values. Because these assertions have no computational
content, they can be interpreted constructively or classically equally
well, and in particular make equal sense to programmers (and
mathematicians) who are used to working in classical logic.

\bigskip

RZ was specifically designed as a lightweight system. Although the
realizability translation can be extended to transforming complete
proofs into complete code~\cite{komagata+:tr95}, we have not
implemented this. Other systems, including Coq~\cite{coq}, already
perform this task well.

But Coq works best when the entire task (from specification to code
generation) is performed within the same system. In contrast, the
interfaces generated by RZ can be implemented in any fashion, as long
as the assertions are satisfied. Code can be written by hand ---
allowing imperative, concurrent, and other arbitrary language
features, not just a ``functional'' subset. Or, the system could
generate a Coq interface as an \emph{input}, where the distinction
between computational (Set) and non-computational (Prop) is
automatically determined, and a corresponding implementation can be
provided through logical techniques.

\internal{AB}{I wrote the following paragraph to make a connection
  with the ``old'' schools of computability. It is rather terse now.
  If you fit it in the introduction somewhere, it can stay such. If
  you move it to the conclusion, I can expand it, if needed.}

We briefly explain the relationships between our setup and other
common approaches. Most formulations of computable mathematics are
based on realizability models~\cite{Bauer:00}, even though they are
usually not presented as such: Recursive
Mathematics~\cite{recursive-math} is based on the original
realizability by Turing machines~\cite{KleeneSC:intint}; Type Two
Effectivity~\cite{Wei00} on function
realizability~\cite{KleeneSC:fouim} and relative function
realizability~\cite{BirkedalL:devttc}, while topological and domain
representations~\cite{Bla97a,Bauer:Birkedal:Scott:98} are based on
realizability over the graph model
$\mathcal{P}\omega$~\cite{ScottD:dattl}. A common feature of these is
that they use models of computation which are suitable for the
theoretical studies of computability, rather than for practical
programming. Since we want to emphasize the practical aspects of
realizability, we have chosen instead an actual real-world programming
language.

\internal{AB}{from here on the introduction seems ``undone''}

The RZ system translates this to the language understood by many
programmers (typed interfaces with assertions in classical logic)

\bigskip

In this paper we show how RZ makes practical use of realizability and
other theoretical techniques, and provide some interesting motivational
examples.


%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "cie"
%%% End: 
