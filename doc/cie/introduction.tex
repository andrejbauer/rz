\section{Introduction}
\label{sec:introduction}

Given the constants, relations, and axioms of a mathematical structure,
expressed in constructive logic, what must a programmer do in order to
implement that mathematical structure?

For some familiar cases, the answer is obvious. Code implementing a
group must have a type to represent the group elements, a constant, a
unary operator, and a binary operator, each satisfying appropriate
axioms that guarantee the constant is a unit of the binary operator,
the unary operator computes inverses, and that the binary operator is
associative.

But for more interesting structures, especially those arising in
constructive analysis, the answer is much less obvious. Significant
research goes into finding suitable representations~\cite{???}. What
do you need to implement the real numbers (a complete, ordered field)?
What about a complete metric space? Or a [cs: I'm hoping Andrej will
fix this part up and add more interesting examples examples.] Â`
\bigskip

The theory of realizability provides guidance in this task.
Realizability is a fundamental theoretical tool for the study of
logic, but it also has direct application to the design and
implementation of programs. It can be used to find a description of
the data structure directly corresponding to a mathematical
specification.

Extracting code interfaces by hand from mathematical axioms quickly
grows tedious, especially because different but logically equivalent
sets of axioms correspond to different, although interdefinable,
interfaces for code. One might want to see several of these, since
some interfaces can be more useful than others in practice.

And few programmers --- even those with solid backgrounds in
mathematics and logic --- are familiar with constructive logic or
realizability. Programmers are more familiar with language constructs
describing interfaces: C++ header files, ML signatures, Java
interfaces, and the like.

\bigskip

We have therefore implemented a system, called RZ, which serves as a
bridge between the logical world and the programming world. It
automatically translates specifications in constructive logic into
actual interface code in a programming language (currently Objective
Caml~\cite{ocaml}, but we are considering other languages as well). The
constructive part of the original specification turns into interface
code listing types and values that must exist in an implementation.

The remainder of the specification is maintained as assertions about
these types and values. Because these assertions have no computational
content, they can be interpreted constructively or classically equally
well, and in particular make equal sense to programmers (and
mathematicians) who are used to working in classical logic.

\bigskip

RZ was specifically designed as a lightweight system. Although the
realizability translation can be extended to transforming complete
proofs into complete code~\cite{komagata+:tr95}, we have not
implemented this. Other systems, including Coq~\cite{coq}, already
perform this task well.

But Coq works best when the entire task (from specification to code
generation) is performed within the same system. In contrast, the
interfaces generated by RZ can be implemented in any fashion, as long
as the assertions are satisfied. Code can be written by hand ---
allowing imperative, concurrent, and other arbitrary language
features, not just a ``functional'' subset. Or, the system could
generate a Coq interface as an \emph{input}, where the distinction
between computational (Set) and non-computational (Prop) is
automatically determined, and a corresponding implementation can be
provided through logical techniques.

The RZ system translates this to the language understood by many
programmers (typed interfaces with assertions in classical logic)

\bigskip

In this paper we show how RZ makes practical use of realizability and
other theoretical techniques, and provide some interesting motivational
examples.


%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "cie"
%%% End: 
