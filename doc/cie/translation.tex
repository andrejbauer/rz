\section{Translation}
\label{sec:translation}

Having seen the input and output languages for RZ, we now explain how
the translation from one to the other works. The mathematical basis
for the translation procedure is the \emph{realizability
  interpretation} of constructive type theory and logic in the
category of modest sets, which was described in
Section~\ref{sec:modest-sets-pers}. A theory is translated to a
specification, where the theory elements are translated as follows.


\subsection{Translation of sets and terms}
\label{sec:transl-sets-terms}

\internal{Andrej}{I still have to insert interpretations of terms
  here. Will keep it short and point out where obligations are
  emitted.}

A set declaration $\iParameter{s}{\iSet}$ is translated to
%
\begin{align*}
  & \otyspec{s}. \\
  & \opropspec{({\approx_{s}})}{\oarrow{s}{\oarrow{s}{\oProp}}}.\\
  & \oassertion{\mathrm{per}_{s}}{
    \begin{aligned}[t]
      & \oforall{x\,y}{s}{(\oimply{\oper{s}{x}{y}}{\oper{s}{y}{x}})}
        \land {} \\
      & \oforall{x\,y\,z}{s}{(
        \oimply{
          \oper{s}{x}{y} \land \oper{s}{y}{z}
          }{\oper{s}{x}{z}}
        )}.
    \end{aligned}
  }
\end{align*}
%
This says that the programmer should define a type~$s$, and a binary
predicate~$\approx_s$ on $\values{s}$ which is symmetric and
transitive.\footnote{The predicate is \emph{not} an ocaml value of
  type $s \to s \to \mathtt{bool}$, but an abstract relation on the
  set $\values{s} \times \values{s}$. Only in special cases can we
  implement the per as a decidable test.} When a dependent set is
declared in the input, e.g., $\iParameter{t}{s \to \iSet}$, the
translation follows the interpretation of dependent sets as uniform
families, cf.\ Section~\ref{sec:uniform-families}. The underlying
output type is still non-dependent, but the per
$\approx_{\oapp{t}{{-}}}$ is parametrized by~$s$, so it is declared to
have type $\oarrow{s}{\oarrow{t}{\oarrow{t}{\oProp}}}$.

An element declaration $\iParameter{x}{s}$ is translated to
%
\begin{align*}
  & \ovalspec{x}{s} \\
  & \oassertion{\mathrm{support}_x}{\ototal{x}{s}}
\end{align*}
%
which requires the definition of a value~$x$ of type~$s$ which is in
the support of~$s$. When $s$ is not a basic set, RZ computes the
interpretation of the underlying type and support.

Constructions of sets in the input language are translated to
corresponding constructions of modest sets. In
Section~\ref{sec:modest-sets-pers} we saw how products, exponentials
and their dependent versions are formed. We briefly review the
remaining constructions. A disjoint union of modest sets
$\isum{\il_1}{A}{\il_2}{B}$ is the modest set whose underlying type is
the sum of underlying types,
%
\begin{equation*}
  \typeOf{\isum{\il_1}{A}{\il_2}{B}} =
  \osumtyx{\il_1}{\typeOf{A}}{\il_2}{\typeOf{B}},
\end{equation*}
%
and the per is the disjoint union of pers $\per_{A}$ and $\per{B}$, so
that we have
%
\begin{align*}
  \oper{\isum{\il_1}{A}{\il_2}{B}}{\oinj{\il_1}{u}}{\oinj{\il_1}{v}}
  &\iff \oper{s_1}{u}{v},
  \\
  \oper{\isum{\il_1}{A}{\il_2}{B}}{\oinj{\il_2}{u}}{\oinj{\il_2}{v}}
  &\iff \oper{s_2}{u}{v}.
\end{align*}
%

The construction of modest subsets may look surprising at first, but
it makes sense computationally. Given a modest sets~$A$ and a
predicate~$\phi$ on~$A$, the modest subset $\set{x : A \such \phi(x)}$
has the underlying set
%
\begin{equation*}
  \setOf{\set{x : A \such \phi(x)}} =
  \set{x \in \setOf{A} \such \xsome{v}{\typeOf{\phi}}{v \rz \phi(x)}},
\end{equation*}
%
and the underlying type with the realizability relation
%
\begin{align*}
  \typeOf{\set{x : A \such \phi(x)}} &= \typeOf{A} \times
  \typeOf{\phi},\\
  (u,v) \rz_{\set{x : A \such \phi(x)}} x &\iff
  u \rz_A x \land v \rz \phi(x).
\end{align*}
%
This means that to represent an element~$x$ of a subset we must
provide a realizer~$u$ for the element itself, as well as~$v$
witnessing~$\phi(x)$. The per which we get from this is
%
\begin{equation*}
    (u_1, v_1) \per_{\set{x : A \such \phi(x)}} (u_2, v_2) \iff
    u_1 \per_A u_2.
\end{equation*}

The category of modest sets has coequalizers, hence a quotient modest
set $A/\rho$ may be constructed for an any equivalence relaton~$\rho$
on~$A$. However, because equality does not carry any computational
content, equality of equivalence classes $\ieclass{x}{\rho} =
\ieclass{y}{\rho}$ implies only $\inot{\inot{\rho(x,y)}}$, not the
usual~$\rho(x,y)$. Because this may cause a great deal of confusion
and mistakes, it is better to consider only quotients by \emph{stable}
equivalence relations, which behave as expected.
%
Given a modest set~$A$ and a stable equivalence relation~$\rho$
on~$A$, the quotient $A/\rho$ is the modest set determined by
%
\begin{align*}
  \setOf{A/\rho} &= \set{\ieclass{x}{\rho} \such x \in A} \\
  \typeOf{A/\rho} &= \typeOf{A} \\
  u \rz_{A/\rho} \xi &\iff \some{y}{\xi}{u \rz_A y}.
\end{align*}
%
Luckily, it seems that many equivalence relations occuring in
computable mathematics are stable, or can be made stable with a little
bit of manipulation. For example, Cauchy sequences $(a_n)_{n\in\NN}$
and $(b_n)_{n\in\NN}$ represent the same real number when
%
\begin{equation}
  \label{eq:cauchy}%
  \xall{i}{\NN}{
    \xsome{j}{\NN}{
      \forall m,n \geq j.\,|a_m - b_n| \leq 2^{-i}
    }
  } \;.
\end{equation}
%
This defines an equivalence relation on the set of Cauchy sequences
which does not seem to be stable. However, if we restrict attention
just to the \emph{rapid} Cauchy sequences, i.e., those satisfying
$\xall{i}{\NN}{|a_{i+1} - a_i| \leq 2^{-i}}$, then the equivalence
relation becomes
%
\begin{equation*}
  \xall{i}{\NN}{|a_i - b_i| \leq 2^{-i+3}},
\end{equation*}
%
which is a negative formula. It is also interesting that most
practical implementations of real numbers present real numbers with
rapid Cauchy sequences so that they can avoid the overhead of carrying
with each sequence a realizer for~\eqref{eq:cauchy}.

A specific kind of construction on a modest set~$A$ is the underlying
modest set of realizers $\irz{A}$, defined by
%
\begin{align*}
  \setOf{\irz{A}} &= \values{\typeOf{A}} \\
  \typeOf{\irz{A}} &= \typeOf{A} \\
  u \rz_{\irz{A}} v &\iff u = v,
\end{align*}
%
where by $u = v$ we mean observational equality of values~$u$ and~$v$.
The corresponding per is
%
\begin{equation*}
  u_1 \per_{\irz{A}} u_2 \iff u_1 \in \support{A} \land u_1 = u_2.
\end{equation*}
%
It validates Aczel's presentation axiom, see
Section~\ref{sec:axiom-choice}. In the input language it gives us
access to realizers which is useful because many constructions in
computable mathematics, such as those in Type Two
Effectivity~\cite{Wei00}, are explicitly expressed in terms of
realizers.


\subsection{Translation of propositions}
\label{sec:transl-prop}

The driving force behind the translation of logic is a theorem, see
e.g.\ \cite[Thm.~4.4.10]{Troelstra:van-Dalen:88:1}, which says that
under the realizability interpretation every formula~$\phi$ is
equivalent to one that says, informally speaking, ``there exists~$u
\in \typeOf{\phi}$, such that $u$ realizes $\phi$''. Furthermore, the
formula ``$u$ realizes $\phi$'' is computationally trivial. The
translation of a predicate $\phi$ then consists of its underlying type
$\typeOf{\phi}$ and the relation $u \rz \phi$, expressed as a negative
formula.

In RZ we avoid the explicit realizer notation $u \rz \phi$ in order to
make the output easier to read. A basic predicate declaration
$\iParameter{p}{\iarrow{s}{\iProp}}$ is translated to
%
\begin{align*}
  & \otyspec{ty\_p} \\
  & \opropspec{p}{s \to ty\_p \to \oProp} \\
  & \oassertion{\mathsf{strict}_p}{
    \oforall{x}{s}{
      \oforall{a}{ty\_p}{
        (\oimply
        {\oapp{\oapp{p}{x}}{a}}
        {\ototal{x}{s}
        })
      }
    }
  } \\
  & \oassertion{\mathsf{extensional}_p}{
    \oforallt{x,y}{s}{
      \oforall{a}{ty\_p}{
          (\oimply{\oper{s}{x}{y}}
          {\oimply{\oapp{\oapp{p}{x}}{a}}{\oapp{\oapp{p}{y}}{a}}})
          }}}
\end{align*}
%
We see that the predicate~$p$ has gained an additional argument of
type $ty\_p$ (which the programmer is supposed to define in an
implementation), and we write $\oapp{\oapp{p}{x}{a}}$ instead of $a
\rz \oapp{p}{x}$. The two assertions require that $p$ be strict and
extensional with respect to $\per_s$.

Frequently we know that a predicate is stable, which can be taken into
account when computing its realizability interpretation. For this
purpose the input language has the subkind $\iStable$ of $\iProp$.
When RZ encounters a predicate which is declared to be stable, such as
$p : \iarrow{s}{\iStable}$, it does not generate a declaration of
$ty\_p$ and it does not give $p$ an extra argument.

Another special kind in RZ input language is the kind $\iEquiv{s}$ of
stable equivalence relations on a set~$s$. When an equivalence
relation is declared with $\iParameter{p}{\iEquiv{s}}$, RZ will output
assertions stating that $p$ is strict, extensional, as well as
reflexive, symmetric and transitive.

An axiom $\iAxiom{A}{\phi}$ in the input is translated to
%
\begin{align*}
  & \ovalspec{u}{\typeOf{\phi}} \\
  & \oassertion{A}{u \rz \phi},
\end{align*}
%
which requires the programmer to validate~$\phi$ by providing a
realizer for it. When $\phi$ is a compound statement RZ computes the
meaning of $u \rz \phi$, as described in Figure~\ref{fig:rz-logic}.



%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "cie"
%%% End: 
