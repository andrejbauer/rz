\section{Translation}
\label{sec:translation}

Having seen the input and output languages for RZ,
%
\iflong
we now explain how the translation from one to the other works.
\else
we briefly review the translation from ont to the other.
\fi
%
The mathematical basis for the translation procedure is the
\emph{realizability interpretation} of constructive type theory and
logic in the category of modest sets, which was described in
Section~\ref{sec:modest-sets-pers}. A theory is translated to a
specification, where the theory elements are translated as follows.



\subsection{Translation of sets and terms}
\label{sec:transl-sets-terms}

A set declaration $\iParameter{s}{\iSet}$ is translated to
%
\[
\begin{array}{ll}
  & \otyspec{s} \\
  & \opropspec{({\approx_{s}})}{\oarrow{s}{\oarrow{s}{\oProp}}}\\
  & \oassertion{\mathrm{symmetric}\_{s}}{
    \oforall{x,y}{s}{(\oimply{\oper{s}{x}{y}}{\oper{s}{y}{x}})}
  }
  \\
  & \oassertion{\mathrm{transitive}\_{s}}{
    \oforall{x,y,z}{s}{(
      \oimply{
        \oper{s}{x}{y} \land \oper{s}{y}{z}
      }{\oper{s}{x}{z}}
      )}
  }
\end{array}
\]
%
This says that the programmer should define a type~$s$ and a per
$\per_s$ on~$\values{s}$. Here~$\per_s$ is \emph{not} an OCaml value
of type $s \to s \to \mathtt{bool}$, but an abstract relation on the
set $\values{s} \times \values{s}$. Only in special cases can we
expect to be able to implement~$\per_s$ as a decidable test.  


\iflong
The translation of the declaration of a dependent set
$\iParameter{t}{s \to \iSet}$ follows the interpretation of dependent
sets as uniform families (Section~\ref{sec:uniform-families}):
%
\[
\begin{array}{ll}  
  & \otyspec{t} \\
  & \opropspec{({\approx_{t}})}{\oarrow{s}{\oarrow{t}{\oarrow{t}{\oProp}}}}\\
  & \oassertion{\mathrm{strict}\_{t}}{
    \oforall{x}{s}{
      \oforall{y,z}{t}{
        (\oimply{\oper{\oapp{t}{x}}{y}{z}}{\ototal{x}{s}})
      }
    }
  } \\
  & \oassertion{\mathrm{extensional}\_{t}}{
    \oforall{x,y}{s}{
      \oforall{z,w}{t}{
        (\oimply{\oper{s}{x}{y}}{
          \oimply{\oper{\oapp{t}{x}}{z}{w}}{\oper{\oapp{t}{y}}{z}{w}}
        })
      }
    }
  } \\
  & \oassertion{\mathrm{symmetric}\_{t}}{
    \oforall{x}{s}{
      \oforall{y,z}{t}{(\oimply{\oper{\oapp{t}{x}}{y}{z}}{\oper{\oapp{t}{x}}{z}{y}})}
    }
  }
  \\
  & \oassertion{\mathrm{transitive}\_{t}}{
    \oforall{x}{s}{
      \oforall{y,z,w}{t}{(
        \oimply{
          \oper{\oapp{t}{x}}{y}{z} \land \oper{\oapp{t}{x}}{z}{w}
        }{\oper{\oapp{t}{x}}{y}{w}}
        )}
    }
  }
\end{array}
\]
%
The underlying output type~$t$ is still non-dependent, but the per is
parameterized by~$s$.
\else % \iflong
The translation of the declaration of a dependent set
$\iParameter{t}{s \to \iSet}$ uses uniform families (Section~\ref{sec:uniform-families}). The
underlying type~$t$ is non-dependent, but the per $\per_t$ receives an
additional parameter $x : \values{s}$.
\fi % \iflong

A value declaration $\iParameter{x}{s}$ is translated to
%
\[
\begin{array}{ll}
  & \ovalspec{x}{s} \\
  & \oassertion{\mathrm{support}\_x}{\ototal{x}{s}}
\end{array}
\]
%
which requires the definition of a value~$x$ of type~$s$ which is in
the support of~$s$.
\iflong
When $s$ is not a basic set, RZ computes the
interpretation of the underlying type and support.
\fi

A value definition $\iDefinition{x}{e}$ where~$e$ is an expression
denoting an element of~$s$ is translated to
%
\[
\begin{array}{ll}
  & \ovalspec{x}{s} \\
  & \oassertion{x\_\mathrm{def}}{\oper{s}{x}{e}}
\end{array}
\]
%
The assertion does \emph{not} force~$x$ to be defined as~$e$, only to
be equivalent to it with respect to~$\per_s$. This is welcome, as
often the easiest way to define a value is not the most efficient
way to compute it.

Constructions of sets in the input language are translated to
corresponding constructions of modest sets.
%
\iflong
In Section~\ref{sec:modest-sets-pers} we saw how products,
exponentials and their dependent versions are formed. We briefly
review the remaining constructions of modest sets. We only consider
those constructions of terms that are not entirely straightforward.
%
\else
%
We comment on those that are least familiar.
%
\fi

\iflong
\paragraph{Disjoint union.}
%
A disjoint union of modest sets $\isum{\il_1}{A}{\il_2}{B}$ is the
modest set whose underlying type is the sum of underlying types,
%
\begin{equation*}
  \typeOf{\isum{\il_1}{A}{\il_2}{B}} =
  \osumtyx{\il_1}{\typeOf{A}}{\il_2}{\typeOf{B}},
\end{equation*}
%
and the per is the disjoint union of pers $\per_{A}$ and $\per_{B}$, so
that we have
%
\begin{align*}
  \oper{\isum{\il_1}{A}{\il_2}{B}}{\oinj{\il_1}{u}}{\oinj{\il_1}{v}}
  &\iff \oper{s_1}{u}{v},
  \\
  \oper{\isum{\il_1}{A}{\il_2}{B}}{\oinj{\il_2}{u}}{\oinj{\il_2}{v}}
  &\iff \oper{s_2}{u}{v}.
\end{align*}
\fi % \iflong

\paragraph{Subsets.}
%
\iflong
The construction of modest subsets may look surprising at first, but
it makes sense computationally.
\fi % \iflong
Given a modest sets~$A$ and a
predicate~$\phi$ on~$A$, the modest subset $\set{x : A \such \phi(x)}$
\iflong
has the underlying set
%
\begin{equation*}
  \setOf{\set{x : A \such \phi(x)}} =
  \set{x \in \setOf{A} \such \xsome{v}{\typeOf{\phi}}{v \rz \phi(x)}},
\end{equation*}
%
and the underlying type with the realizability relation
%
\begin{align*}
  \typeOf{\set{x : A \such \phi(x)}} &= \typeOf{A} \times
  \typeOf{\phi},\\
  (u,v) \rz_{\set{x : A \such \phi(x)}} x &\iff
  u \rz_A x \land v \rz \phi(x).
\end{align*}
\else % \iflong
consists of 
$\setOf{\set{x : A \such \phi(x)}} =
\set{x \in \setOf{A} \such \xsome{v}{\typeOf{\phi}}{v \rz \phi(x)}}$,
$\typeOf{\set{x : A \such \phi(x)}} = \typeOf{A} \times
\typeOf{\phi}$, and
$(u,v) \rz_{\set{x : A \such \phi(x)}} x \iff
u \rz_A x \land v \rz \phi(x)$.
\fi % \iflong
%
This means that to represent an element~$x$ of a subset we must
provide a realizer~$u$ for the element itself, as well as~$v$
witnessing~$\phi(x)$. The per which we get from this is
%
\iflong
\begin{equation*}
  (u_1, v_1) \per_{\set{x : A \such \phi(x)}} (u_2, v_2) \iff
  v_1 \rz \phi(u_1) \land v_2 \rz \phi(u_2) \land
  u_1 \per_A u_2.
\end{equation*}
\else % \iflong
$(u_1, v_1) \per_{\set{x : A \such \phi(x)}} (u_2, v_2) \iff
v_1 \rz \phi(u_1) \land v_2 \rz \phi(u_2) \land
u_1 \per_A u_2$.
\fi 
%
A type coercion $\icoerce{e}{t}$ can convert an element of the subset $s =
\set{x : t \such \phi(x)}$ to an element of~$t$. At the level of
realizers this is achieved by the first projection, which keeps a
realizer for the element but forgets the one for~$\phi(e)$. The
opposite type coercion $\icoerce{e'}{s}$ takes an $e' \in t$ and converts it
to an element of the subset. This is only well-formed when $\phi(e')$
is valid. Then, if $u \rz_t e'$ and $v \rz \phi(e')$, a realizer for
$\icoerce{e'}{s}$ is $(u, v)$. However, since RZ cannot in general find
a~$v$ which validates~$\phi(e')$, it emits an obligation $(u,
(\ooblig{v}{\typeOf{\phi}}{\oapp{\oapp{\phi}{u}}{v}}{v}))$.

\paragraph{Quotients.}
%
The category of modest sets has coequalizers, hence a quotient modest
set $A/\rho$ may be constructed for an any equivalence relation~$\rho$
on~$A$. 
%
Given a modest set~$A$ and a stable equivalence relation~$\rho$
on~$A$, the quotient $A/\rho$ is the modest set determined by
\iflong
\begin{align*}
  \setOf{A/\rho} &= \set{\ieclass{x}{\rho} \such x \in A} \\
  \typeOf{A/\rho} &= \typeOf{A} \\
  u \rz_{A/\rho} \xi &\iff \some{y}{\xi}{u \rz_A y}.
\end{align*}
\else % \iflong
$\setOf{A/\rho} = \set{\ieclass{x}{\rho} \such x \in A}$,
$\typeOf{A/\rho} = \typeOf{A}$, and
$u \rz_{A/\rho} \xi \iff \some{y}{\xi}{u \rz_A y}$.
\fi % \iflong
%
However, because equality does not carry any computational
content, equality of equivalence classes $\ieclass{x}{\rho} =
\ieclass{y}{\rho}$ implies only $\inot{\inot{\rho(x,y)}}$, not the
usual~$\rho(x,y)$. Because this may cause a great deal of confusion
and mistakes, it is better to permit only quotients by \emph{stable}
equivalence relations, which behave as expected.
%

Luckily, it seems that many equivalence relations occurring in
computable mathematics are stable, or can be made stable with a little
bit of manipulation.
%
\iflong
For example, Cauchy sequences $(a_n)_{n\in\NN}$
and $(b_n)_{n\in\NN}$ represent the same real number when
%
\begin{equation}
  \label{eq:cauchy}%
  \xall{i}{\NN}{
    \xsome{j}{\NN}{
      \forall m,n \geq j.\,|a_m - b_n| \leq 2^{-i}
    }
  } \;.
\end{equation}
%
This defines an equivalence relation on the set of Cauchy sequences
which does not seem to be stable; intuitively a realizer for this
equivalence would be a computation telling us at what point
in the sequence the terms will be within~$2^{-i}$ of each other.
%
However, if we restrict attention just to the \emph{rapid} Cauchy
sequences, i.e., those satisfying $\xall{i}{\NN}{|a_{i+1} - a_i| \leq
  2^{-i}}$, then the equivalence relation becomes
%
\begin{equation*}
  \xall{i}{\NN}{|a_i - b_i| \leq 2^{-i+3}},
\end{equation*}
%
which is a negative formula; the above realizer is rendered
unnecessary.
%
\else % iflong
%
For example, the coincidence relation on Cauchy sequences is expressed
by a $\forall\exists\forall$~formula, but if we restrict to the
\emph{rapid} Cauchy sequences, it becomes a (negative)
$\forall$~formula.
%
\fi % iflong
It is interesting that most practical implementations of
real numbers follow this line of reasoning and represent real numbers to
avoid annotating every sequence with its rate of convergence.

Translation of an equivalence class $\ieclass{e}{\rho}$ is quite
simple: since a realizer for~$e$ also realizes $\ieclass{e}{\rho}$, RZ
uses the same realizer. The elimination term
$\ileteclass{x}{\rho}{\xi}{e}$, means ``let $x$ be any element
of $\rho$-equivalence class $\xi$ in~$e$''.
It is only well-formed when $e$ does not depend on the choice of~$x$,
but this is something RZ cannot check. Therefore, if $u$ realizes
$\xi$, RZ uses $u$ as a realizer for~$x$ and emits an obligation
saying that the choice of a realizer for~$x$ does not affect~$e$.

\paragraph{The underlying set of realizers.}
%
A specific kind of construction on a modest set~$A$ is the underlying
modest set of realizers $\irz{A}$, defined by
%
\iflong
\[
\begin{array}{ll}
  \setOf{\irz{A}} &= \values{\typeOf{A}} \\
  \typeOf{\irz{A}} &= \typeOf{A} \\
  u \rz_{\irz{A}} v &\iff u = v,
\end{array}
\]
\else  % \iflong
$\setOf{\irz{A}} = \values{\typeOf{A}}$,  
$\typeOf{\irz{A}} = \typeOf{A}$, and 
$u \rz_{\irz{A}} v \iff u = v$, 
\fi % \iflong
%
where by $u = v$ we mean observational equality of values~$u$ and~$v$.
The corresponding per is
%
\iflong
\begin{equation*}
  u_1 \per_{\irz{A}} u_2 \iff u_1 \in \support{A} \land u_1 = u_2.
\end{equation*}
\else
$u_1 \per_{\irz{A}} u_2 \iff u_1 \in \support{A} \land u_1 = u_2$.
%
An element $r \in \irz{A}$ realizes a unique element $\irz{r} \in A$.
The elimination term $\iletrz{x}{e_1}{e_2}$, which means ``let $x$ be
any realizer for~$e_1$ in $e_2$'', is only well-formed if $e_2$ does
not depend on the choice of~$x$. This is an uncheckable conditions,
hence RZ emits a suitable obligation in the output, and uses for $x$
the same realizer as for~$e_2$.

The construction $\irz{A}$ validates the Presentation Axiom (see
Section~\ref{sec:axiom-choice}). In the input language it gives us
access to realizers, which is useful because many constructions in
computable mathematics, such as those in Type Two
Effectivity~\cite{Wei00}, are explicitly expressed in terms of
realizers.

\iflong
\paragraph{Definite description.}
%
Russell's definite description operator $\ithe{x}{s}{\phi(x)}$ denotes
the unique element of $\isubset{x}{s}{\phi(x)}$. In case such an~$x$
does not exist, or if there are several, the term is not well formed.
The RZ translation essentially just asks the programmer to provide
suitable realizers for $x$ and for $\phi(x)$, and to check uniqueness,
%
\begin{equation*}
  \ooblig{x{:}s,b}{\typeOf{\phi}}{
    (\ototal{x}{s} \land \oapp{\oapp{\phi}{x}}{b} \land
    \oforall{x'}{s}{
      \oforall{c}{\typeOf{\phi}}{
        (\oimply{\oapp{\oapp{\phi}{x'}}{c}}{\oper{s}{x}{x'}})
      }
    })
    }{(x,b)}.
\end{equation*}
%
This is the best RZ can do, since in general it can check neither
that~$x$ exists, nor that it is unique.
\fi

\subsection{Translation of propositions}
\label{sec:transl-prop}

The driving force behind the translation of logic is a theorem
\cite[4.4.10]{Troelstra:van-Dalen:88:1} that says that under the
realizability interpretation every formula~$\phi$ is equivalent to one
that says, informally speaking, ``there exists~$u \in \typeOf{\phi}$,
such that $u$ realizes $\phi$''. Furthermore, the formula ``$u$
realizes $\phi$'' is computationally trivial. The translation of a
predicate $\phi$ then consists of its underlying type $\typeOf{\phi}$
and the relation $u \rz \phi$, expressed as a negative formula.

In RZ we avoid the explicit realizer notation $u \rz \phi$ in order to
make the output easier to read.
%
\iflong
%
A basic predicate declaration $\iParameter{p}{\iarrow{s}{\iProp}}$ is
translated to
%
\begin{align*}
  & \otyspec{ty\_p} \\
  & \opropspec{p}{s \to ty\_p \to \oProp} \\
  & \oassertion{\mathsf{strict}\_p}{
    \oforall{x}{s}{
      \oforall{a}{ty\_p}{
        (\oimply
        {\oapp{\oapp{p}{x}}{a}}
        {\ototal{x}{s}
        })
      }
    }
  } \\
  & \oassertion{\mathsf{extensional}\_p}{
    \oforallt{x,y}{s}{
      \oforall{a}{ty\_p}{
          (\oimply{\oper{s}{x}{y}}
          {\oimply{\oapp{\oapp{p}{x}}{a}}{\oapp{\oapp{p}{y}}{a}}})
          }}}
\end{align*}
%
We see that the predicate~$p$ has gained an additional argument of
type $ty\_p$ (which the programmer is supposed to define in an
implementation), and we write $\oapp{\oapp{p}{x}}{a}$ instead of $a
\rz \oapp{p}{x}$. The two assertions require that $p$ be strict and
extensional with respect to $\per_s$.
%
\else % iflong
%
A basic predicate declaration $\iParameter{p}{\iarrow{s}{\iProp}}$ is
translated to a type declaration $\otyspec{ty\_p}$ and a predicate
declaration $\opropspec{p}{s \to ty\_p \to \oProp}$ together with
assertions that~$p$ is strict and extensional.
%
\fi % iflong

Frequently we know that a predicate is stable, which can be taken into
account when computing its realizability interpretation. For this
purpose the input language has the subkind $\iStable$ of $\iProp$.
When RZ encounters a predicate which is declared to be stable, such as
$p : \iarrow{s}{\iStable}$, it does not generate a declaration of
$ty\_p$ and it does not give $p$ an extra argument.

Another special kind in RZ input language is the kind $\iEquiv{s}$ of
stable equivalence relations on a set~$s$. When an equivalence
relation is declared with $\iParameter{p}{\iEquiv{s}}$, RZ will output
assertions stating that $p$ is strict, extensional, as well as
reflexive, symmetric and transitive.

An axiom $\iAxiom{A}{\phi}$ in the input is translated to
%
\[
\begin{array}{ll}
  & \ovalspec{u}{\typeOf{\phi}} \\
  & \oassertion{A}{u \rz \phi},
\end{array}
\]
%
which requires the programmer to validate~$\phi$ by providing a
realizer for it. When $\phi$ is a compound statement RZ computes the
meaning \iflong of $u \rz \phi$\fi as described in Figure~\ref{fig:rz-logic}.



%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "cie"
%%% End: 
