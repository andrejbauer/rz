\section{Translation}
\label{sec:translation}

Having seen the input and output languages for RZ, we now explain how
the translation from one to the other works. The mathematical basis
for the translation procedure is the \emph{realizability
  interpretation} of constructive type theory and logic in the
category of modest sets, which was described in
Section~\ref{sec:modest-sets-pers}. A theory is translated to a
specification, where the theory elements are translated as follows.


\subsection{Translation of sets and terms}
\label{sec:transl-sets-terms}

A set declaration $\iParameter{s}{\iSet}$ is translated to
%
\begin{align*}
  & \otyspec{s} \\
  & \opropspec{({\approx_{s}})}{\oarrow{s}{\oarrow{s}{\oProp}}}\\
  & \oassertion{\mathrm{symmetric}\_{s}}{
    \oforall{x,y}{s}{(\oimply{\oper{s}{x}{y}}{\oper{s}{y}{x}})}
  }
  \\
  & \oassertion{\mathrm{transitive}\_{s}}{
    \oforall{x,y,z}{s}{(
      \oimply{
        \oper{s}{x}{y} \land \oper{s}{y}{z}
      }{\oper{s}{x}{z}}
      )}
  }
\end{align*}
%
This says that the programmer should define a type~$s$ and a per
$\per_s$ on~$\values{s}$. Here~$\per_s$ is \emph{not} an OCaml value
of type $s \to s \to \mathtt{bool}$, but an abstract relation on the
set $\values{s} \times \values{s}$. Only in special cases can we
expect to be able to implement~$\per_s$ as a decidable test.  

The translation of the declaration of a dependent set
$\iParameter{t}{s \to \iSet}$ follows the interpretation of dependent
sets as uniform families, cf.\ Section~\ref{sec:uniform-families}:
%
\begin{align*}  
  & \otyspec{t} \\
  & \opropspec{({\approx_{t}})}{\oarrow{s}{\oarrow{t}{\oarrow{t}{\oProp}}}}\\
  & \oassertion{\mathrm{strict}\_{t}}{
    \oforall{x}{s}{
      \oforall{y,z}{t}{
        (\oimply{\oper{\oapp{t}{x}}{y}{z}}{\ototal{x}{s}})
      }
    }
  } \\
  & \oassertion{\mathrm{extensional}\_{t}}{
    \oforall{x,y}{s}{
      \oforall{z,w}{t}{
        (\oimply{\oper{s}{x}{y}}{
          \oimply{\oper{\oapp{t}{x}}{z}{w}}{\oper{\oapp{t}{y}}{z}{w}}
        })
      }
    }
  } \\
  & \oassertion{\mathrm{symmetric}\_{t}}{
    \oforall{x}{s}{
      \oforall{y,z}{t}{(\oimply{\oper{\oapp{t}{x}}{y}{z}}{\oper{\oapp{t}{x}}{z}{y}})}
    }
  }
  \\
  & \oassertion{\mathrm{transitive}\_{t}}{
    \oforall{x}{s}{
      \oforall{y,z,w}{t}{(
        \oimply{
          \oper{\oapp{t}{x}}{y}{z} \land \oper{\oapp{t}{x}}{z}{w}
        }{\oper{\oapp{t}{x}}{y}{w}}
        )}
    }
  }
\end{align*}
%
The underlying output type~$t$ is still non-dependent, but the per is
parameterized by~$s$.

An element declaration $\iParameter{x}{s}$ is translated to
%
\begin{align*}
  & \ovalspec{x}{s} \\
  & \oassertion{\mathrm{support}_x}{\ototal{x}{s}}
\end{align*}
%
which requires the definition of a value~$x$ of type~$s$ which is in
the support of~$s$. When $s$ is not a basic set, RZ computes the
interpretation of the underlying type and support.

Constructions of sets in the input language are translated to
corresponding constructions of modest sets. In
Section~\ref{sec:modest-sets-pers} we saw how products, exponentials
and their dependent versions are formed. We briefly review the
remaining constructions of modest sets. We only consider those
constructions of terms that are not entirely straightforward.

\paragraph{Disjoint union.}
%
A disjoint union of modest sets $\isum{\il_1}{A}{\il_2}{B}$ is the
modest set whose underlying type is the sum of underlying types,
%
\begin{equation*}
  \typeOf{\isum{\il_1}{A}{\il_2}{B}} =
  \osumtyx{\il_1}{\typeOf{A}}{\il_2}{\typeOf{B}},
\end{equation*}
%
and the per is the disjoint union of pers $\per_{A}$ and $\per_{B}$, so
that we have
%
\begin{align*}
  \oper{\isum{\il_1}{A}{\il_2}{B}}{\oinj{\il_1}{u}}{\oinj{\il_1}{v}}
  &\iff \oper{s_1}{u}{v},
  \\
  \oper{\isum{\il_1}{A}{\il_2}{B}}{\oinj{\il_2}{u}}{\oinj{\il_2}{v}}
  &\iff \oper{s_2}{u}{v}.
\end{align*}
%

\paragraph{Subsets.}
%
The construction of modest subsets may look surprising at first, but
it makes sense computationally. Given a modest sets~$A$ and a
predicate~$\phi$ on~$A$, the modest subset $\set{x : A \such \phi(x)}$
has the underlying set
%
\begin{equation*}
  \setOf{\set{x : A \such \phi(x)}} =
  \set{x \in \setOf{A} \such \xsome{v}{\typeOf{\phi}}{v \rz \phi(x)}},
\end{equation*}
%
and the underlying type with the realizability relation
%
\begin{align*}
  \typeOf{\set{x : A \such \phi(x)}} &= \typeOf{A} \times
  \typeOf{\phi},\\
  (u,v) \rz_{\set{x : A \such \phi(x)}} x &\iff
  u \rz_A x \land v \rz \phi(x).
\end{align*}
%
This means that to represent an element~$x$ of a subset we must
provide a realizer~$u$ for the element itself, as well as~$v$
witnessing~$\phi(x)$. The per which we get from this is
%
\begin{equation*}
  (u_1, v_1) \per_{\set{x : A \such \phi(x)}} (u_2, v_2) \iff
  v_1 \rz \phi(u_1) \land v_2 \rz \phi(u_2) \land
  u_1 \per_A u_2.
\end{equation*}
%
The coercion $\isubout{e}{s}$ converts an element of the subset $s =
\set{x : t \such \phi(x)}$ to an element of~$t$. At the level of
realizers this is achieved by the first projection, which keeps a
realizer for the element but forgets the one for~$\phi(e)$. The
opposite coercion $\isubout{e}{s}$ takes an $e \in t$ and converts it
to an element of the subset. This is only well-formed when $\phi(e)$
is valid. Then, if $u \rz_t e$ and $v \rz \phi(e)$, a realizer for
$\isubin{e}{s}$ is $(u, v)$. However, since RZ cannot in general find
a~$v$ which validates~$\phi(e)$, it emits an obligation $(u,
(\ooblig{v}{\typeOf{\phi}}{\oapp{\oapp{\phi}{u}}{v}}{v}))$.

\paragraph{Quotients.}
%
The category of modest sets has coequalizers, hence a quotient modest
set $A/\rho$ may be constructed for an any equivalence relation~$\rho$
on~$A$. However, because equality does not carry any computational
content, equality of equivalence classes $\ieclass{x}{\rho} =
\ieclass{y}{\rho}$ implies only $\inot{\inot{\rho(x,y)}}$, not the
usual~$\rho(x,y)$. Because this may cause a great deal of confusion
and mistakes, it is better to consider only quotients by \emph{stable}
equivalence relations, which behave as expected.
%
Given a modest set~$A$ and a stable equivalence relation~$\rho$
on~$A$, the quotient $A/\rho$ is the modest set determined by
%
\begin{align*}
  \setOf{A/\rho} &= \set{\ieclass{x}{\rho} \such x \in A} \\
  \typeOf{A/\rho} &= \typeOf{A} \\
  u \rz_{A/\rho} \xi &\iff \some{y}{\xi}{u \rz_A y}.
\end{align*}
%
Translation of and equivalence class $\ieclass{e}{\rho}$ is quite
simple: since a realizer for~$e$ also realizes $\ieclass{e}{\rho}$, RZ
simply uses the same realizer. The elimination term
$\ileteclass{x}{\rho}{\xi}{e}$, which means ``let $x$ be any element
of $\rho$-equivalence class $\xi$ in~$e$'', is trickier to translate.
It is only well-formed when $e$ does not depend on the choice of~$x$,
but this is something RZ cannot check. Therefore, if $u$ realizes
$\xi$, RZ uses $u$ as a realizer for~$x$ and emits an obligation
saying that the choice of a realizer for~$x$ does not affect~$e$.

Luckily, it seems that many equivalence relations occurring in
computable mathematics are stable, or can be made stable with a little
bit of manipulation. For example, Cauchy sequences $(a_n)_{n\in\NN}$
and $(b_n)_{n\in\NN}$ represent the same real number when
%
\begin{equation}
  \label{eq:cauchy}%
  \xall{i}{\NN}{
    \xsome{j}{\NN}{
      \forall m,n \geq j.\,|a_m - b_n| \leq 2^{-i}
    }
  } \;.
\end{equation}
%
This defines an equivalence relation on the set of Cauchy sequences
which does not seem to be stable; intuitively a realizer for this
equivalence would be a computation telling us at what point
in the sequence the terms converge to within $2^{-i}$.

\internal{Chris}{Did I get the intuition right?}

 However, if we restrict attention
just to the \emph{rapid} Cauchy sequences, i.e., those satisfying
$\xall{i}{\NN}{|a_{i+1} - a_i| \leq 2^{-i}}$, then the equivalence
relation becomes
%
\begin{equation*}
  \xall{i}{\NN}{|a_i - b_i| \leq 2^{-i+3}},
\end{equation*}
%
which is a negative formula; the above realizer is rendered
unnecessary. It is also interesting that most
practical implementations of real numbers present real numbers with
rapid Cauchy sequences so that they can avoid the overhead of carrying
with each sequence a realizer for~\eqref{eq:cauchy}.


\paragraph{The underlying set of realizers.}
%
A specific kind of construction on a modest set~$A$ is the underlying
modest set of realizers $\irz{A}$, defined by
%
\begin{align*}
  \setOf{\irz{A}} &= \values{\typeOf{A}} \\
  \typeOf{\irz{A}} &= \typeOf{A} \\
  u \rz_{\irz{A}} v &\iff u = v,
\end{align*}
%
where by $u = v$ we mean observational equality of values~$u$ and~$v$.
The corresponding per is
%
\begin{equation*}
  u_1 \per_{\irz{A}} u_2 \iff u_1 \in \support{A} \land u_1 = u_2.
\end{equation*}
%
An element $r \in \irz{A}$ realizes a unique element $\irz{r} \in A$.
The elimination term $\iletrz{x}{e_1}{e_2}$, which means ``let $x$ be
any realizer for~$e_1$ in $e_2$'', is only well-formed if $e_2$ does
not depend on the choice of~$x$. This is an uncheckable conditions,
hence RZ emits a suitable obligation in the output, and uses for $x$
the same realizer as for~$e_2$.

The construction $\irz{A}$ validates Aczel's presentation axiom. (See
Section~\ref{sec:axiom-choice}.) In the input language it gives us
access to realizers. This is useful because many constructions in
computable mathematics, such as those in Type Two
Effectivity~\cite{Wei00}, are explicitly expressed in terms of
realizers.


\paragraph{Definite description.}
%
Russell's definite description operator $\ithe{x}{s}{\phi(x)}$ denotes
the unique element of $\isubset{x}{s}{\phi(x)}$. In case such an~$x$
does not exists, or if there are several, the term is not well formed.
The RZ translation essentially just asks the programmer to provide a
suitable realizer $(x,b)$,
%
\begin{equation*}
  \ooblig{x{:}s,b}{\typeOf{\phi}}{
    (\ototal{x}{s} \land \oapp{\oapp{\phi}{x}}{b} \land
    \oforall{x'}{s}{
      \oforall{c}{\typeOf{\phi}}{
        (\oimply{\oapp{\oapp{\phi}{x'}}{c}}{\oper{s}{x}{x'}})
      }
    })
    }{(x,b)}.
\end{equation*}
%
This is the best RZ can do, since in general it can check neither
that~$x$ exists, nor that it is unique.


\subsection{Translation of propositions}
\label{sec:transl-prop}

The driving force behind the translation of logic is a theorem 
(see\ \cite[Thm.~4.4.10]{Troelstra:van-Dalen:88:1}) that says that
under the realizability interpretation every formula~$\phi$ is
equivalent to one that says, informally speaking, ``there exists~$u
\in \typeOf{\phi}$, such that $u$ realizes $\phi$''. Furthermore, the
formula ``$u$ realizes $\phi$'' is computationally trivial. The
translation of a predicate $\phi$ then consists of its underlying type
$\typeOf{\phi}$ and the relation $u \rz \phi$, expressed as a negative
formula.

In RZ we avoid the explicit realizer notation $u \rz \phi$ in order to
make the output easier to read. A basic predicate declaration
$\iParameter{p}{\iarrow{s}{\iProp}}$ is translated to
%
\begin{align*}
  & \otyspec{ty\_p} \\
  & \opropspec{p}{s \to ty\_p \to \oProp} \\
  & \oassertion{\mathsf{strict}\_p}{
    \oforall{x}{s}{
      \oforall{a}{ty\_p}{
        (\oimply
        {\oapp{\oapp{p}{x}}{a}}
        {\ototal{x}{s}
        })
      }
    }
  } \\
  & \oassertion{\mathsf{extensional}\_p}{
    \oforallt{x,y}{s}{
      \oforall{a}{ty\_p}{
          (\oimply{\oper{s}{x}{y}}
          {\oimply{\oapp{\oapp{p}{x}}{a}}{\oapp{\oapp{p}{y}}{a}}})
          }}}
\end{align*}
%
We see that the predicate~$p$ has gained an additional argument of
type $ty\_p$ (which the programmer is supposed to define in an
implementation), and we write $\oapp{\oapp{p}{x}}{a}$ instead of $a
\rz \oapp{p}{x}$. The two assertions require that $p$ be strict and
extensional with respect to $\per_s$.

\internal{Andrej}{Maybe we should mention the kinds $\iStable$ and
  $\iEquiv{s}$ in Section~\ref{sec:input-language} so we do not have
  to introduce them here.}

Frequently we know that a predicate is stable, which can be taken into
account when computing its realizability interpretation. For this
purpose the input language has the subkind $\iStable$ of $\iProp$.
When RZ encounters a predicate which is declared to be stable, such as
$p : \iarrow{s}{\iStable}$, it does not generate a declaration of
$ty\_p$ and it does not give $p$ an extra argument.

Another special kind in RZ input language is the kind $\iEquiv{s}$ of
stable equivalence relations on a set~$s$. When an equivalence
relation is declared with $\iParameter{p}{\iEquiv{s}}$, RZ will output
assertions stating that $p$ is strict, extensional, as well as
reflexive, symmetric and transitive.

An axiom $\iAxiom{A}{\phi}$ in the input is translated to
%
\begin{align*}
  & \ovalspec{u}{\typeOf{\phi}} \\
  & \oassertion{A}{u \rz \phi},
\end{align*}
%
which requires the programmer to validate~$\phi$ by providing a
realizer for it. When $\phi$ is a compound statement RZ computes the
meaning of $u \rz \phi$, as described in Figure~\ref{fig:rz-logic}.



%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "cie"
%%% End: 
