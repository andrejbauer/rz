\section{Implementation}
\label{sec:implementation}

The RZ implementation consists of several sequential passes.

After the initial parsing, a \emph{type reconstruction} phase checks
that the input is well-typed (and checks for well-formedness to the
extent that it is easily decidable), and if successful produces an
annotated result with all variables explicitly tagged with types. The
type checking phase uses a system of dependent types, with limited
subtyping (implicit coercions) for sum types and subset types. The
details are fairly standard, so are omitted here. One non-obvious
consequence of the realizability translation, however, is that the
subset types $\isubset{\ix}{\iS}{\iand{\ipp_1(\ix)}{\ipp_2(\ix)}}$ and
$\isubset{\ix}{\iS}{\iand{\ipp_2(\ix)}{\ipp_1(\ix)}}$ are not
equal, but only isomorphic in general. An
explicit coercion is required to go from one type to the other,
because subset values are pairs containing realizers for
$\iand{\ipp_1(\ix)}{\ipp_2(\ix)}$ and
$\iand{\ipp_2(\ix)}{\ipp_1(\ix)}$, and these realizers have
potentially different types $|\ipp_1(\ix)|\mathtt{*}|\ipp_2(\ix)|$ and
$|\ipp_2(\ix)|\mathtt{*}|\ipp_1(\ix)|$ respectively.

Next the realizability translation is performed as described in
Section~\ref{sec:translation}, producing interface code. The
flexibility of the full input language (e.g., $n$-ary sum types and
dependent product types) makes the translation code fairly involved,
and so it is performed in a ``naive'' fashion whenever possible. The
immediate result of the translation is not easily readable.
 
Thus, three more passes simplify the output before it is displayed to
the user. A \emph{thinning} pass removes all references to trivial
realizers produced by stable formulas. For example, direct translation
of the $\mathtt{free}$ axiom in the output for Kuratowski-finite sets
yields a value specification for $\mathtt{free}$ of type
%
\begin{equation*}
  (\mathtt{A.a} \to \mathtt{S.s}) \to 
  (\mathtt{fin} \to \mathtt{S.s}) * (\ounit * (\mathtt{A.a} \to
  \ounit) *
  (\mathtt{fin} \to \mathtt{fin} \to \ounit))
\end{equation*}
%
where $\ounit$ is the unit (terminal) type classifying the trivial
realizer. Thinning replaces this by the isomorphic type
%
\begin{equation*}
  (\mathtt{A.a} \to \mathtt{S.s}) \to \mathtt{fin} \to \mathtt{S.s}
\end{equation*}
%
and appropriately modifies references to $\mathtt{free}$ in the assertions to account for this change in type.

Next, an \emph{optimization} pass applies an ad-hoc collection of
basic logical and term simplifications in order to make the output more readable. 
Logical simplifications include applications of truth table rules
($\iand{\itrue}{\ip}$ becomes $\ip$), detection of syntactically
identical premises and conclusions
($\iimply{\ip_1}{\iand{\ip_1}{\ip_2}}$ becomes
$\iimply{\ip_1}{\ip_2}$), and optimization of other common patterns we have
seen arise
($\iforall{\ix}{\is}{\iimply{(\iequal{\ix}{\ie})}{\ipp(\ix)}}$ becomes
$\ipp(\ie)$). We do not attempt real theorem proving 
so some redundancy may remain, but in practice the optimization pass
can help significantly.

Finally, the user can specify whether two optional steps occur.
RZ can optionally performs a \emph{phase-splitting} pass~\cite{harper+:popl90}. 
This is an ML-specific transformation that replace certain
uses of parameterized modules (a heavyweight language construct) by
parameterized types and polymorphic values. The idea is that although
functors map modules containing types and terms to other modules containing types
and terms, constraints on the programming language ensure that output types
depend only on input types (and not input terms).  Thus, we can split each
functor into a mapping from input types to output types, and then a separate
(polymorphic) term mapping input types and terms to an output term.

For example (ignoring
assertions for simplicity) the entire module
\begin{source}
module Free : functor (S : Semilattice) ->
                    sig
                      val free : (A.a -> S.s) -> fin -> S.s
                    end	
\end{source}   
appearing in the output of the Kuratowski example can be replaced by the single polymorphic function
\begin{source}
val free : 's -> ('s -> 's -> 's) -> (A.a -> 's) -> fin -> 's	
\end{source}
which replaces the module parameter \texttt{S} by two extra term arguments term (corresponding to the module components \texttt{S.zero} and \texttt{S.join}) 
and a type argument \texttt{'s} for the type of lattice elements (corresponding to the module input \texttt{S.s}).

The other optional transformation is a \emph{hoisting} pass which lifts obligations in the output out to top-level positions.  This can make it easier to see exactly what one is obliged to provide.  When identical obligations appear in separate subterms of a term, hoisting can lift and merge these obligations, reducing redundancy.  However, moving obligations far from where they are used can make it harder to see why the obligation is required at all (and hence how one might satisfy the obligation), and so hoisting is turned off by default.

For example, in the following input (extracted from a larger description of an ordered field)
\begin{Verbatim}
Parameter s : Set.
Parameter zero : s.
Parameter inverse : {x : s | not (x = zero)} -> s.

Parameter lt : s -> s -> Stable.
Definition positive (x:s) := lt zero x.
Axiom lt_irr: forall x:s, not (lt x x).

Axiom order_inv: forall x:s, positive x -> positive (inverse x).
\end{Verbatim}
the axiom translates to the assertion:
\begin{Verbatim}
	(**  Assertion order_inv = 
          forall (x:||s||),  positive x ->
            positive (inv (assure (not (x =real= zero)) in x))
   *).
\end{Verbatim}
Here the system has noticed that for \Verb|inverse x| to make sense, we must know that
\Verb|x| is non-zero.   This requires non-trivial theorem proving and hence remains as 
an obligation for the user.  

We must prove \Verb|not (x =s= zero)| not for all \Verb|x|, but only under
the premises in force where the obligation occurs.  This is slightly clearer when hoisting moves the
obligation to the top level, after which it could be verified in the same way as all other assertions:
\begin{Verbatim}
   (**  Assertion order_inv = 
          assure (forall (x:||real||),  positive x -> not (x =real= zero))
            in forall (x:||real||),  positive x -> positive (inv x)
   *)	
\end{Verbatim}


%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "cie"
%%% End: 
