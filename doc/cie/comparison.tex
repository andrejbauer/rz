\section{Related Work}
\subsection{Coq}
\label{sec:comparison-with-coq}


1. Choose Coq if you want complete machinery for producing code.

     * Complete theorems can be turned into (trusted) code

2. Choose RZ if you want lightweight machinery for specifying the required code.

     * It's possible that programmers *should* be doing theorem proving,
       but this is not always practical.

     * Clarifies the constructive content (e.g., what should be in Set
       and what can be left in Prop), and could serve as a front-end to
       Coq.

     * Grunt-work of computing realizability interpretations, but without
        requiring full code/proofs

     * Provides a way to talk with programmers (e.g., about the impliciations
       of constructive logic.) without full theorem proving

\subsection{Other tools}

Komagata and Schmidt~\cite{komagata+:tr95} describe a system that uses
a similar realizability translation to ours.  Like Coq, the system
translates formal proofs to programs, rather than 

An interesting technical difference is that the algorithm they use,
attributed to John Hatcliff, does thinning as it goes along, rather
than making this a separate pass.  For example, the translation of the
conjunction-introduction rule has four cases, depending on whether the
left and/or right propositions being proved are [almost?] negative, in which
case the trivial contribution can be immediately discarded.

\subsection{Models of Computability}
\label{sec:models-of-computability}
Most formulations of
computable mathematics are based on realizability
models~\cite{Bauer:00}, even though they were not initially developed,
nor are they usually presented within the framework of realizability:
Recursive Mathematics~\cite{ershov98:_handb_recur_mathem} is based on
the original realizability by Turing machines~\cite{KleeneSC:intint};
Type Two Effectivity~\cite{Wei00} on function
realizability~\cite{KleeneSC:fouim} and relative function
realizability~\cite{BirkedalL:devttc}, while topological and domain
representations~\cite{Bla97a,Bauer:Birkedal:Scott:98} are based on
realizability over the graph model
$\mathcal{P}\omega$~\cite{ScottD:dattl}. A common feature of these is
that they use models of computation which are suitable for the
theoretical studies of computability, rather than for practical
programming. Since we want to emphasize the practical aspects of
realizability, we have chosen instead an actual real-world programming
language.

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "cie"
%%% End: 
