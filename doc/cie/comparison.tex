\section{Related Work}
\subsection{Coq}
\label{sec:comparison-with-coq}

Coq is a very flexible system, with complete support for theorem-proving and creating trusted code.  One common pattern of use for Coq is to write code in Coq's functional language (values whose types are \texttt{Set} in Coq), to state and prove theorems stating that the code behaves correctly (where the theorems are Coq values whose types are \texttt{Prop} in Coq), and then have Coq produce guaranteed correct code in ML.  In such cases, RZ is complementary to Coq.  RZ can clarify the constructive content of mathematical structures and hence suggest an appropriate division between \texttt{Set} and \texttt{Prop}, i.e., which values and which theorems should appear in the input to Coq.  (It should be easy to have RZ produce output in Coq syntax, and we hope to do this eventually.)

In general, RZ is a smaller and more lightweight system and thus more flexible where it applies.  It is not always practical or necessary to do theorem proving in order to provide an implementation; interfaces generated by RZ can be implemented in any manner from theorem proving to directly writing code.  And, RZ provides a way to talk with programmers about implications for constructive without bringing in full theorem proving.

\subsection{Other tools}

Komagata and Schmidt~\cite{komagata+:tr95} describe a system that uses
a similar realizability translation to ours.  Like Coq, the system
translates formal proofs to programs, rather than 

An interesting technical difference is that the algorithm they use,
attributed to John Hatcliff, does thinning as it goes along, rather
than making this a separate pass.  For example, the translation of the
conjunction-introduction rule has four cases, depending on whether the
left and/or right propositions being proved are [almost?] negative, in which
case the trivial contribution can be immediately discarded.

\subsection{Models of Computability}
\label{sec:models-of-computability}
Most formulations of
computable mathematics are based on realizability
models~\cite{Bauer:00}, even though they were not initially developed,
nor are they usually presented within the framework of realizability:
Recursive Mathematics~\cite{ershov98:_handb_recur_mathem} is based on
the original realizability by Turing machines~\cite{KleeneSC:intint};
Type Two Effectivity~\cite{Wei00} on function
realizability~\cite{KleeneSC:fouim} and relative function
realizability~\cite{BirkedalL:devttc}, while topological and domain
representations~\cite{Bla97a,Bauer:Birkedal:Scott:98} are based on
realizability over the graph model
$\mathcal{P}\omega$~\cite{ScottD:dattl}. A common feature of these is
that they use models of computation which are suitable for the
theoretical studies of computability, rather than for practical
programming. Since we want to emphasize the practical aspects of
realizability, we have chosen instead an actual real-world programming
language.

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "cie"
%%% End: 
