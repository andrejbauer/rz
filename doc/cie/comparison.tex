\section{Related Work}
\label{sec:related-work}

\subsection{Coq}
\label{sec:comparison-with-coq}

Coq is a very flexible system, with complete support for
theorem-proving and creating trusted code. One common pattern of use
for Coq is to write code in Coq's functional language (values whose
types are \texttt{Set} in Coq), to state and prove theorems stating
that the code behaves correctly (where the theorems are Coq values
whose types are \texttt{Prop} in Coq), and then have Coq produce
guaranteed correct code in ML. In such cases, RZ is complementary to
Coq. RZ can clarify the constructive content of mathematical
structures and hence suggest an appropriate division between Coq's
\texttt{Set} and \texttt{Prop}, i.e., which values and which theorems
should appear in the input to Coq. (It should be easy to have RZ
produce output in Coq syntax, and we hope to do this eventually.)

In general, RZ is a smaller and more lightweight system and thus more
flexible where it applies. It is not always practical or necessary to
do theorem proving in order to provide an implementation; interfaces
generated by RZ can be implemented in any manner from theorem proving
to directly writing code. And, RZ provides a way to talk with
programmers about implications of constructive mathematics for their work without bringing in
full theorem proving.


\subsection{Other tools}

Komagata and Schmidt~\cite{komagata+:tr95} describe a system that uses
a similar realizability translation to ours. Like Coq, the system
translates formal proofs to programs.
%
An interesting technical difference is that the algorithm they use,
attributed to John Hatcliff, does thinning as it goes along, rather
than making this a separate pass. For example, the translation of the
conjunction-introduction rule has four cases, depending on whether the
left and/or right propositions being proved are [almost?] negative, in
which case the trivial contribution can be immediately discarded.

\subsection{Other Models of Computability}
\label{sec:models-of-computability}

Many formulations of computable mathematics are based on realizability
models~\cite{Bauer:00}, even though they were not initially developed,
nor are they usually presented within the framework of realizability:
Recursive Mathematics~\cite{ershov98:_handb_recur_mathem} is based on
the original realizability by Turing machines~\cite{KleeneSC:intint};
Type Two Effectivity~\cite{Wei00} on function
realizability~\cite{KleeneSC:fouim} and relative function
realizability~\cite{BirkedalL:devttc}, while topological and domain
representations~\cite{Bla97a,Bauer:Birkedal:Scott:98} are based on
realizability over the graph model
$\mathcal{P}\omega$~\cite{ScottD:dattl}. A common feature of these is
that they use models of computation which are suitable for the
theoretical studies of computability, rather than for practical
programming. 

Other approaches are based on programming languages augmented with
datatypes for real numbers~\cite{Escardo:97,marcial-romero04:_seman}
and topological algebras~\cite{TZ98}, or machine models augmented with
(suitably chosen subsets of) real numbers such as Real
RAM~\cite{borodin75}, the Blum-Smale-Shub
model~\cite{blum98:_compl_real_comput}, and the Exact Geometric
Computation model~\cite{yap06:_theor_real_comput_egc}. The motivation
behind these ranges from purely theoretical concerns about
computability and complexity to practical issues in the design of
programming languages and algorithms in computational geometry. RZ
attempts to improve on practicality by interfacing with an actual
real-world programming language, and by providing an input language
which is rich enough to allow descriptions of involved mathematical
structures that go well beyond the real numbers.

Finally, we hope that RZ and, hopefully, its forthcoming applications,
give plenty of evidence for the \emph{practical} value of Constructive
Mathematics~\cite{Bishop:Bridges:85}.



%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "cie"
%%% End: 
