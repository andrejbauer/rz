\section{Specifications as signatures with assertions}
\label{sec:spec-sign-assert}


In programming we distinguish between \emph{impementation} and
\emph{specification} of a structure. In OCaml these two notions are
expressed with modules and module types, respectively.\footnote{In
  object-oriented languages implementations and specifications are
  expressed with classes and interfaces, while in Haskell they
  correspond to ??? and ???.} A module defines types
and values, while a module type simply lists the types and values provided
by a module. In Figure~\ref{fig:module-example} we see the
definition of a module type $\mathtt{AbelianGroup}$ and a
module~$\mathtt{Z7}$ satisfying~$\mathtt{AbelianGroup}$.
%
\begin{figure}
  \centering
  \VerbatimInput{group.ml}
  \caption{The module type $\mathtt{AbelianGroup}$ and module
    $\mathtt{Z7}$.}
  \label{fig:module-example}
\end{figure}
%
Even though we may guess that $\mathtt{Z7}$ implements the
group~$\ZZ_7$, this is not clear from the bare definitions of types
and values. We still need to specify a per~$\perty{t}$ on
$\values{\mathtt{t}}$ that tells us when two integers represent the
same element of~$\ZZ_7$, e.g.,
%
\begin{equation*}
  u \perty{t} v \iff
  u \mathbin{\mathrm{mod}} 7 = v \mathbin{\mathrm{mod}} 7 \;.
\end{equation*}
%
Similiarly, $\mathtt{AbelianGroup}$ by itself does not describe an
Abelian group, only its signature. A complete description would
contain the following further \emph{assertions}:
%
\begin{enumerate}
\item there is a per $\perty{t}$ on $\values{\mathtt{t}}$,
\item
  \label{enum:zero-total}%
  $\mathtt{zero} \in \support{\mathtt{t}}$, where $\support{t} =
  \set{u \in \values{\mathtt{t}} \such u \perty{t} u}$.
\item
  \label{enum:neg-total}%
  for all $u, v \in \values{\mathtt{t}}$, if $u \perty{t} v$ then
  $\mathtt{neg} \; u \perty{t} \mathtt{neg} \; v$,
\item
  \label{enum:add-total}%
  for all $u_1, u_2, v_1, v_2 \in \values{\mathtt{t}}$, if $u_1
  \perty{t} v_1$ and $u_2 \perty{t} v_2$ then $\mathtt{add} \; (u_1,
  u_2) \perty{t} \mathtt{add} \; (v_1, v_2)$,
\item 
  \label{enum:ab-group-axiom-1}%
  for all $u \in \support{\mathtt{t}}$, $\mathtt{add} \;
  (\mathtt{zero}, u) \perty{t} u$,
\item
  \label{enum:ab-group-axiom-2}%
  for all $u \in \support{\mathtt{t}}$, $\mathtt{add} \; (u,
  \mathtt{neg} \; u) \perty{t} \mathtt{zero}$,
\item
  \label{enum:ab-group-axiom-3}%
  for all $u, v, w \in \support{\mathtt{t}}$, $\mathtt{add} \;
  (\mathtt{add} \; (u, v), w) \perty{t} \mathtt{add} \; (u,
  \mathtt{add} \; (v, w))$,
\item
  \label{enum:ab-group-axiom-4}%
  for all $u, v \in \support{\mathtt{t}}$, $\mathtt{add} \; (u, v)
  \perty{t} \mathtt{add} (v, u)$.
\end{enumerate}
%
Assertions \ref{enum:zero-total}--\ref{enum:add-total} state that
$\mathtt{zero}$, $\mathtt{neg}$, and $\mathtt{add}$ realize a
constant, a unary, and a binary operation, respectively, while
assertions \ref{enum:ab-group-axiom-1}--\ref{enum:ab-group-axiom-4}
state that they have the desired properties. We call a module type
together with a list of assertions a \emph{specification}.

RZ generates specifications from descriptions of mathematical
structures written in constructive logic. The above module type
$\mathtt{AbelianGroup}$ and assertions are generated by RZ from input
shown in Figure~\ref{fig:ab-group-thy}.
%
\begin{figure}
  \centering
  \VerbatimInput{group.thy}
  \caption{A sample input for RZ.}
  \label{fig:ab-group-thy}
\end{figure}

\internal{Andrej}{Should change ASCII notation to improved notation in
  the above example.}

In this section we present the logical language of assertions. To be
continued\dots

\begin{figure}
	\[
	\begin{array}{rl@{\qquad}l}
		\noalign{\textbf{Types}}
		\oty ::= 
		    & \oTY  \obar \oselect{\oM}{\oTY} &\mbox{Type names}\\
		  | & \ounit \obar \oprod{\oty_1}{\oty_2} &\mbox{Unit and cartesian product}\\
		  | & \oarrow{\oty_1}{\oty_2} & \mbox{Function type}\\
		  | & \osumty{\ol_1}{\oty_1}{\ol_n}{\oty_n} &\mbox{Disjoint sum}\\
                  | & \opty & \mbox{Polymorphic types}\\[5pt]
		
		\noalign{\textbf{Terms}}	
		\oe ::=
		    & \ox \obar \oselect{\oM}{\ox} &\mbox{Term names}\\
		  | & \olambda{\ox}{\oty_1}{\oe} \obar 
		      \oapp{\oe_1}{\oe_2} &\mbox{Abstraction and application}\\
		  | & \otuple{\oe_1}{\oe_n} 
		      \obar \oproj{\oe}{n}&\mbox{Tuple and projection}\\
		  | & \oinj{\ol}{\oe} 
		      \obar (\omatches{\oe_0}{\ol_1}{\ox_1}{\oe_1}{\ol_n}{\ox_n}{\oe_n})&\mbox{Injection and projection from a sum}\\
		  | & \ooblig{\ox}{\op}{\oe} \obar \oobligx{\op}{\oe} &\mbox{Obligation}\\
		  | & \olet{\ox}{\oe_1}{\oe_2}&\mbox{Local definition}\\[5pt]
		

		\noalign{\textbf{Propositions (negative fragment)}}
		\op ::= 
		    & \oP \obar \oselect{\oM}{\oP}&\mbox{Atomic
                      proposition}\\
		  | & \otrue  \obar \ofalse \obar \onot{\op_1} \obar \oand{\op_1}{\op_2} \obar 
		      \oimply{\op_1}{\op_2} \obar \oiff{\op_1}{\op_2} & \mbox{Predicate logic}\\
		  | & \olambda{\ox}{\oty}{\op}  \obar \oapp{\op}{\oe} & \mbox{Predicates and application}\\
                    | & \oper{\os}{\oe_1}{\oe_2} \obar \ototal{\oe}{\os} & \mbox{Pers and support} \\
		  | & \oequal{\oe_1}{\oe_2} & \mbox{(Observational) term equality}\\
		  | & \oforall{\ox}{\oty}{\op}  \obar 
		      \oforallt{\ox}{\os}{\op} & \mbox{Term quantifiers}\\[5pt]
		
		\noalign{\textbf{Basic modest sets}}
                \os ::=
                    & \oS \obar \oapp{\os}{\oe} & \\[5pt]

		\noalign{\textbf{Modules}}		
		\om ::= 
		    & \oM  \obar \oselect{\om}{\oM}&\mbox{Model names}\\
		  | & \oapp{\om_1}{\om_2}&\mbox{Application of parameterized model}\\[5pt]
		
		\noalign{\textbf{Proposition Kinds}}
		\opt ::=
		    & \oProp & \mbox{Classifier for propositions}\\
		   |& \oarrow{\oty}{\opt} & \mbox{Classifier for a predicate/relation}\\[5pt] 
		
		\noalign{\textbf{Module Type Elements}}
		\ote ::=
		     & \ovalspec{\ox}{\oty}&\mbox{Value specification}\\
		   | & \otyspec{\oTY}&\mbox{Type specification}\\
                   | & \otydef{\oTY}{\oty}&\mbox{Type definition}\\
		   | & \omodulespec{\om}{\omt}&\mbox{Module specification}\\
		   | & \osignatdef{\oMT}{\omt}&\mbox{Module type definition}\\
                   | & \ospropspec{\oP}{\opt}&\mbox{Proposition specification}\\
                   | & \oassertion{A}{\op}&\mbox{Assertion}\\[5pt]

  		\noalign{\textbf{Module Type}}
		\omt ::= 
		     & \oMT \obar \oselect{\om}{\oMT} & \mbox{Module type names}\\
		   	| & \osig{\ote_1 \ldots \ote_n}\\
                        | & \ofunctor{\om}{\omt_1}{\omt_2} & \mbox{Parametrized module type}\\
		  	| & \oapp{\omt}{\om} & \mbox{Module type application}
	\end{array}
	\]
	\label{fig:input}
	\caption{Output Syntax (Simplified)}
\end{figure}


\internal{Andrej}{Do we discuss functors here as well?}


%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "cie"
%%% End: 
