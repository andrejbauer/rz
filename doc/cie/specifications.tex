\section{Specifications as signatures with assertions}
\label{sec:spec-sign-assert}


In programming we distinguish between \emph{impementation} and
\emph{specification} of a structure. In OCaml these two notions are
expressed with modules and module types, respectively.\footnote{In
  object-oriented languages implementations and specifications are
  expressed with classes and interfaces, while in Haskell they
  correspond to ??? and ???.} A module defines types
and values, while a module type simply lists the types and values provided
by a module. In Figure~\ref{fig:module-example} we see the
definition of a module type $\mathtt{AbelianGroup}$ and a
module~$\mathtt{Z7}$ satisfying~$\mathtt{AbelianGroup}$.
%
\begin{figure}
  \centering
  \VerbatimInput{group.ml}
  \caption{The module type $\mathtt{AbelianGroup}$ and module
    $\mathtt{Z7}$.}
  \label{fig:module-example}
\end{figure}
%
Even though we may guess that $\mathtt{Z7}$ implements the
group~$\ZZ_7$, this is not clear from the bare definitions of types
and values. We still need to specify a per~$\perty{t}$ on
$\values{\mathtt{t}}$ that tells us when two integers represent the
same element of~$\ZZ_7$, e.g.,
%
\begin{equation*}
  u \perty{t} v \iff
  u \mathbin{\mathrm{mod}} 7 = v \mathbin{\mathrm{mod}} 7 \;.
\end{equation*}
%
Similiarly, $\mathtt{AbelianGroup}$ by itself does not describe an
Abelian group, only its signature. A complete description would
contain the following further \emph{assertions}:
%
\begin{enumerate}
\item there is a per $\perty{t}$ on $\values{\mathtt{t}}$,
\item
  \label{enum:zero-total}%
  $\mathtt{zero} \in \support{\mathtt{t}}$, where $\support{t} =
  \set{u \in \values{\mathtt{t}} \such u \perty{t} u}$.
\item
  \label{enum:neg-total}%
  for all $u, v \in \values{\mathtt{t}}$, if $u \perty{t} v$ then
  $\mathtt{neg} \; u \perty{t} \mathtt{neg} \; v$,
\item
  \label{enum:add-total}%
  for all $u_1, u_2, v_1, v_2 \in \values{\mathtt{t}}$, if $u_1
  \perty{t} v_1$ and $u_2 \perty{t} v_2$ then $\mathtt{add} \; (u_1,
  u_2) \perty{t} \mathtt{add} \; (v_1, v_2)$,
\item 
  \label{enum:ab-group-axiom-1}%
  for all $u \in \support{\mathtt{t}}$, $\mathtt{add} \;
  (\mathtt{zero}, u) \perty{t} u$,
\item
  \label{enum:ab-group-axiom-2}%
  for all $u \in \support{\mathtt{t}}$, $\mathtt{add} \; (u,
  \mathtt{neg} \; u) \perty{t} \mathtt{zero}$,
\item
  \label{enum:ab-group-axiom-3}%
  for all $u, v, w \in \support{\mathtt{t}}$, $\mathtt{add} \;
  (\mathtt{add} \; (u, v), w) \perty{t} \mathtt{add} \; (u,
  \mathtt{add} \; (v, w))$,
\item
  \label{enum:ab-group-axiom-4}%
  for all $u, v \in \support{\mathtt{t}}$, $\mathtt{add} \; (u, v)
  \perty{t} \mathtt{add} (v, u)$.
\end{enumerate}
%
Assertions \ref{enum:zero-total}--\ref{enum:add-total} state that
$\mathtt{zero}$, $\mathtt{neg}$, and $\mathtt{add}$ realize a
constant, a unary, and a binary operation, respectively, while
assertions \ref{enum:ab-group-axiom-1}--\ref{enum:ab-group-axiom-4}
state that they have the desired properties. We call a module type
together with a list of assertions a \emph{specification}.

RZ generates specifications from descriptions of mathematical
structures written in constructive logic. The above module type
$\mathtt{AbelianGroup}$ and assertions are generated by RZ from input
shown in Figure~\ref{fig:ab-group-thy}.
%
\begin{figure}
  \centering
  \VerbatimInput{group.thy}
  \caption{A sample input for RZ.}
  \label{fig:ab-group-thy}
\end{figure}

\internal{Andrej}{Should change ASCII notation to improved notation in
  the above example.}

In this section we present the logical language of assertions. To be
continued\dots


\internal{Andrej}{Do not forger to mention \emph{assure}!}
\internal{Andrej}{Do we discuss functors here as well?}


%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "cie"
%%% End: 
