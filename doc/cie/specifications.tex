\section{Specifications as signatures with assertions}
\label{sec:spec-sign-assert}


In programming we distinguish between \emph{impementation} and
\emph{specification} of a structure. In OCaml these two notions are
expressed with modules and module types, respectively.\footnote{In
  object-oriented languages implementations and specifications are
  expressed with classes and interfaces, while in Haskell they
  correspond to ??? and ???.} A module defines types
and values, while a module type simply lists the types and values provided
by a module. In Figure~\ref{fig:module-example} we see the
definition of a module type $\mathtt{AbelianGroup}$ and a
module~$\mathtt{Z7}$ satisfying~$\mathtt{AbelianGroup}$.
%
\begin{figure}
  \centering
  \VerbatimInput{group.ml}
  \caption{The module type $\mathtt{AbelianGroup}$ and module
    $\mathtt{Z7}$.}
  \label{fig:module-example}
\end{figure}
%
Even though we may guess that $\mathtt{Z7}$ implements the
group~$\ZZ_7$, this is not clear from the bare definitions of types
and values. We still need to specify a per~$\perty{t}$ on
$\values{\mathtt{t}}$ that tells us when two integers represent the
same element of~$\ZZ_7$, e.g.,
%
\begin{equation*}
  u \perty{t} v \iff
  u \mathbin{\mathrm{mod}} 7 = v \mathbin{\mathrm{mod}} 7 \;.
\end{equation*}
%
Similiarly, $\mathtt{AbelianGroup}$ by itself does not describe an
Abelian group, only its signature. A complete description would
contain the following further \emph{assertions}:
%
\begin{enumerate}
\item there is a per $\perty{t}$ on $\values{\mathtt{t}}$,
\item
  \label{enum:zero-total}%
  $\mathtt{zero} \in \support{\mathtt{t}}$, where $\support{t} =
  \set{u \in \values{\mathtt{t}} \such u \perty{t} u}$.
\item
  \label{enum:neg-total}%
  for all $u, v \in \values{\mathtt{t}}$, if $u \perty{t} v$ then
  $\mathtt{neg} \; u \perty{t} \mathtt{neg} \; v$,
\item
  \label{enum:add-total}%
  for all $u_1, u_2, v_1, v_2 \in \values{\mathtt{t}}$, if $u_1
  \perty{t} v_1$ and $u_2 \perty{t} v_2$ then $\mathtt{add} \; (u_1,
  u_2) \perty{t} \mathtt{add} \; (v_1, v_2)$,
\item 
  \label{enum:ab-group-axiom-1}%
  for all $u \in \support{\mathtt{t}}$, $\mathtt{add} \;
  (\mathtt{zero}, u) \perty{t} u$,
\item
  \label{enum:ab-group-axiom-2}%
  for all $u \in \support{\mathtt{t}}$, $\mathtt{add} \; (u,
  \mathtt{neg} \; u) \perty{t} \mathtt{zero}$,
\item
  \label{enum:ab-group-axiom-3}%
  for all $u, v, w \in \support{\mathtt{t}}$, $\mathtt{add} \;
  (\mathtt{add} \; (u, v), w) \perty{t} \mathtt{add} \; (u,
  \mathtt{add} \; (v, w))$,
\item
  \label{enum:ab-group-axiom-4}%
  for all $u, v \in \support{\mathtt{t}}$, $\mathtt{add} \; (u, v)
  \perty{t} \mathtt{add} (v, u)$.
\end{enumerate}
%
Assertions \ref{enum:zero-total}--\ref{enum:add-total} state that
$\mathtt{zero}$, $\mathtt{neg}$, and $\mathtt{add}$ realize a
constant, a unary, and a binary operation, respectively, while
assertions \ref{enum:ab-group-axiom-1}--\ref{enum:ab-group-axiom-4}
state that they have the desired properties. We call a module type
together with a list of assertions a \emph{specification}.

RZ generates specifications from descriptions of mathematical
structures written in constructive logic. The above module type
$\mathtt{AbelianGroup}$ and assertions are generated by RZ from input
shown in Figure~\ref{fig:ab-group-thy}.
%
\begin{figure}
  \centering
  \VerbatimInput{group.thy}
  \caption{A sample input for RZ.}
  \label{fig:ab-group-thy}
\end{figure}

\internal{Andrej}{Should change ASCII notation to improved notation in
  the above example.}

In this section we present the logical language of assertions. To be
continued\dots

\begin{figure}
	\[
	\begin{array}{rl@{\qquad}l}
          \noalign{(I am going to change this to out syntax.)}
		\noalign{\textbf{Assertions}}
		\ip ::= 
		    & \iP\ |\ \iselect{\im}{\iP}&\mbox{Atomic
                      proposition}\\
                    | & \ie : \support{\iapp{\iS}{\ie_1 \ldots
                        \ie_n}} \ | \ \ie_1 \iper{\iapp{\iS}{\ie_1
                        \ldots \ie_n}} \ie_2 \\
		  | & \itrue \ | \ \ifalse\ |\ \inot{\ip_1}\ |\ \iand{\ip_1}{\ip_2}\ |\ 
		       \iimply{\ip_1}{\ip_2}\ |\ \iiff{\ip_1}{\ip_2} & \mbox{Predicate logic}\\
		  | & \ilambda{\ix}{\ity}{\ip} \ |\ \iapp{\ip}{\ie} & \mbox{Predicates and application}\\
		  | & \iequal{\ie_1}{\ie_2} & \mbox{Term equality}\\
		  | & \iforall{\ix}{\is}{\ip} \ |\ 
		      \iforall{\ix}{\support{\is}}{\ip} & \mbox{Term quantifiers}\\[5pt]
		
		\noalign{\textbf{Types}}
		\is ::= 
		    & \iS \ |\ \iselect{\im}{\iS} &\mbox{Type names}\\
		  | & ()\ |\ \iprod{\ix}{\is_1}{\is_2} &\mbox{Unit and cartesian product}\\
		  | & \isum{\il_1}{\is_1}{\il_2}{\is_2} &\mbox{Disjoint union}\\
		  | & \ilambda{\ix}{\is_1}{\is_2}\ |\ 
		      \iapp{\is}{\ie} &\mbox{Dependent set and application}\\
		  | & \iquot{\is}{\ipp} & \mbox{Set quotient by an equivalence relation}\\
		  | & \isubset{\ix}{\is}{\ipp} & \mbox{Subset satisfying a predicate}\\
		  | & \irz{\is}&\mbox{Realizers of a set}\\[5pt] 
		
		\noalign{\textbf{Terms}}	
		\ie ::=
		    & \ix\ |\ \iselect{\im}{\ix} &\mbox{Term names}\\
		  | & \ilambda{\ix}{\is_1}{\ie}\ |\ 
		      \iapp{\ie_1}{\ie_2} &\mbox{Function and application}\\
		  | & \ituple{\ie_1}{\ie_2} 
		      \ibar \iproj{\ie}{n}&\mbox{Tuple and projection}\\
		  | & \iinj{\il}{\ie} 
		      \ibar (\imatch{\ie_0}{\il_1}{\ix_1}{\ie_1}{\il_2}{\ix_2}{\ie_2})&\mbox{Injection and projection from a union}\\
		  | & \ieclass{\ie}{\ipp}
		      \ibar \ileteclass{\ix}{\ipp}{\ie_1}{\ie_2}&\mbox{Equivalence class and picking a representative}\\
		  | & \irz{\ie}
		      \ibar \iletrz{\ix}{\ie_1}{\ie_2}&\mbox{Realized value and picking a realizer}\\
		  | & \iconstrain{\ie}{\is}&\mbox{Type coercion (e.g., in or out of a subset)}\\
		  | & \ithe{\ix}{\is}{\ip}&\mbox{Definite description}\\
		  | & \ilet{\ix}{\ie_1}{\ie_2}&\mbox{Local definition}\\[5pt]
		
		\noalign{\textbf{Models}}		
		\im ::= 
		    & \iM \ |\ \iselect{\im}{\iM}&\mbox{Model names}\\
		  | & \iapp{\im_1}{\im_2}&\mbox{Application of parameterized model}\\[5pt]
		
		\noalign{\textbf{Proposition Kinds}}
		\ipt ::=
		    & \iProp & \mbox{Classifier for propositions}\\
		    & \iStable & \mbox{Classifier for stable propositions}\\
		    & \iEquiv{\is} &\mbox{Classifier for equivalence relations}\\
		    & \idarrow{\ix}{\is}{\ipt} & \mbox{Classifier for a predicate/relation}\\[5pt] 
		
		\noalign{\textbf{Set Kinds}}
		\ik ::= 
		    & \iSet &\mbox{Classifier for a proper set}\\
		   | & \idarrow{\ix}{\is}{\ik} &\mbox{Classifier for a dependent set}\\[5pt]
		

		\noalign{\textbf{Theory Elements}}
		\ite ::=
		     & \iDefinition{\ix}{\ie}&\mbox{Name for a term}\\
		   | & \iDefinition{\iS}{\is}&\mbox{Name for a set}\\
		   | & \iDefinition{\iP}{\ip}&\mbox{Name for a proposition/predicate}\\
		   | & \iDefinition{\iTH}{\ith}&\mbox{Name for a theory}\\
		   | & \iParameter{\ix}{\is}&\mbox{Require an element in the given set}\\
		   | & \iParameter{\iS}{\ik}&\mbox{Require a set of the given kind}\\
		   | & \iParameter{\iP}{\ipt}&\mbox{Require a proposition/predicate of the given sort}\\
		   | & \iParameter{\iM}{\ith}&\mbox{Require a model of the given theory}\\
		   | & \iAxiom{\iP}{\ip}&\mbox{Axiom that must hold}\\[5pt]

  		\noalign{\textbf{Theory}}
		\ith ::= 
		     & \iTH\\
%		   | & \iselect{\im}{\iTH}\\
		   	| & \ithy{\ite_1,\ldots,\ite_n}\\
		 	| & \idarrow{\iM}{\ith_1}{\ith_2} &\mbox{Theory of a uniform family of models}\\
		  	| & \ilambda{\iM}{\ith_1}{\ith_2}\ |\ 
		      \iapp{\ith}{\iM}\\
	\end{array}
	\]
	\label{fig:input}
	\caption{Input Syntax (Simplified)}
\end{figure}



\internal{Andrej}{Do not forger to mention \emph{assure}!}
\internal{Andrej}{Do we discuss functors here as well?}


%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "cie"
%%% End: 
