\chapter{Introduction}
\label{cha:introduction}

RZ is a program that translates mathematical theories to programming
specifications. The translation is done according to the realizability
interpretation of logic, discovered by Kleene~\cite{KleeneSC:intint}.

The original motivation for RZ came from the desire to make explicit
the relationship between constructive mathematics and programming
practice. As is well known, there is a tight relationship between
constructive mathematics and programming, formally expressed as
Curry-Howard propositions-as-types correspondence, and similarly (but
not equivalently) as the realizability interpretation of logic. It
makes sense to exploit this relationship not only in theory but also
in practice. Unfortunately, there seem to be few people who are
trained in constructive logic and are at the same time experienced
programmers. Thus we developed a tool that connects mathematician's
and programmer's worlds by translating mathematical theories to
programming specifications.

Experts in the area of type theory and program specifications often
wonder why there is a need to translate mathematical theories to
specifications. In their view a specification \emph{is} a theory
(whose model is an implementation)? While this is true in a certain
sense, it is not very helpful. Specifications are typically expressed
in a specialized language, such as a variant of Martin-L\"of type
theory, that only specialists are able to use as their ``working
language''. And even they will quickly get lost when it comes to
writing down complex mathematical theories. For a workable enviroment,
we need a mathematical language that is sufficiently close to what is
used in practice. But this makes the language so rich that a tool
which automatically translates it to the world of programing languages
turns out to be very helpful.

RZ can be used also as an aid to teach constructive mathematics.
Because it translates mathematical statements expressed in
constructive logic to specifications expressed in classical
mathematics, it should prove useful as a way of explaining the
computational content of constructive statements. In fact, in the
computable mathematics community a fair amount of time is spent on
finding correct representations of various mathematical
structures---either in terms of numbered sets, as is done in Recursive
Mathematics, or admissible Baire space representations, as is done in
Type Two Effectivity. This task is automated by RZ, which finds
representations in terms of abstract data types that can actually be
compiled on a computer.


\subsection*{What RZ is not}
\label{sec:what-rz-not}

RZ translates theories to specifications. It does \emph{not} translate
proofs to programs, and in fact there is no way to even write down a
proof in RZ. Neither does RZ extract programs from specifications.
While program extraction is an important idea and a worthwhile
endeavor, there are several reasons why we have avoided it in RZ.
First, if one wants to extract programs from proofs or specifications
that are expressed in a rich mathematical language, such as the one
supported by RZ, then it is already non-trivial to compute the types
of extracted programs and assertions they should satisfy. Hence it
makes sense to write such a tool as a first step. Second, formal
proofs are much harder to write and to come by than formalized
theories. We cannot realistically expect ordinary programers to write
formal proofs---at best we can hope they will worry about obtaining a
specification of what is needed \emph{before} writing the program.
Third, until program extraction has made major advances, programers
will write more efficient programs than the current state-of-the-art
program extractors do. Last, it is not our aim to create a tool that
will impress logicians, but rather one that will help in the real
world of programming. Because of this, it is better not to attempt to
write programs that need to solve arbitrarily hard mathematical
problems in order to perform their tasks, which is what the ideal
program extractor is expected to do.


\subsection*{How to read this document}
\label{sec:how-read-this}

RZ relates several aspects of mathematics, logic, and the theory of
programming languages. People who work in these areas have different
points of view and different backgrounds. We have targeted the
document at a reader who poseses basic knowledge of mathematics, and
is interested in programming. In particular, we assume familiarity
with an ML-like programming language, although we explain the
important programming concepts as we go along. Formal logic and
realizability theory are not prerequisites. Naturally, knowledge of
these topics will make it much easier to understand the subject.

Those who are familiar with the theory of realizability will see that
RZ is just an application of familiar techniques and ideas. It is a
demonstration of how realizability can be used in practice.

Most mathematicians are classical by virtue of their education.
Nevertheless, many are curious about constructive logic. RZ may serve
them as (one possible) explanation of constructive logic, motivated by
examples from computer science.

For computer scientists RZ is a connection to constructive
mathematics, as it can be used to translate constructive mathematics
so the language of program specifications.


%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "userman"
%%% End: 
